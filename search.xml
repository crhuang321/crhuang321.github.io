<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于深度学习的图像超分方法整理</title>
    <url>/2019/12/05/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>本文整理了一些基于深度学习的图像超分方法：SRCNN、FSRCNN、ESPCN、VDSR、DRCN、RED、DRRN、LapSRN、DBPN……</p>
<a id="more"></a>

<h2 id="1-SRCNN"><a href="#1-SRCNN" class="headerlink" title="1 SRCNN"></a>1 SRCNN</h2><p>Image Super-Resolution Using Deep Convolutional Networks</p>
<p>SRCNN是⾸个使⽤CNN结构（即基于深度学习）的端到端的超分辨率算法。⾸先输⼊预处理：对输⼊的LR图像⽤bicubic算法放⼤为⽬标尺⼨。然后将放⼤后的LR图像经过卷积⽹络处理，最终得到SR图像。该过程包含以下三步：块提取及特征表示、⾮线性映射、重建。</p>
<p>关键点：</p>
<ul>
<li>卷积核数量越多，即特征向量维数越高，实验效果越好，但会影响算法速度</li>
<li>没有池化层和全连接层，导致网络对初始参数和学习率非常敏感，网络越深会使训练难以收敛</li>
<li>以MSE（等价于PSNR）为Loss函数得到的解往往是可能解的平均，而非最优</li>
<li>以MSE为Loss的SR算法得到的结果有些区域看起来过于模糊，缺乏应有的细节</li>
<li>RGB通道联合训练效果最好</li>
<li>YCbCr通道下，Cb、Cr通道对性能提升基本无帮助，只基于Y通道的训练效果更好</li>
</ul>
<p>SRCNN提出轻量的端到端网络SRCNN来解决超分问题，在当时取得了比传统方法性能更强、速度更快的效果。另外作者将基于稀疏编码的超分方法理解为卷积神经网络的一种形式，也是本文非常值得阅读的亮点。</p>
<h2 id="2-FSRCNN"><a href="#2-FSRCNN" class="headerlink" title="2 FSRCNN"></a>2 FSRCNN</h2><p>Accelerating the Super-Resolution Convolutional Neural Network</p>
<p>在SRCNN中到底是什么拖慢了重建速度呢？</p>
<ul>
<li>将Interpolated LR投入网络，带来巨大计算开销（放大n倍时，计算复杂度上升到了n^2）</li>
<li>非线性层映射的参数太过臃肿</li>
</ul>
<p>如何解决？</p>
<ul>
<li>取消ILR输入，采用LR输入，在最后使用反卷积放大尺寸</li>
<li>改变特征维数，用更小的卷积核和更多的映射层</li>
<li>共享映射层，如需训练不同上采样倍率的模型，只需fine-tuning最后的反卷积层</li>
</ul>
<h2 id="3-ESPCN"><a href="#3-ESPCN" class="headerlink" title="3 ESPCN"></a>3 ESPCN</h2><p>Real-Time Single Image and Video Super-Resolution Using an EfficientSub-Pixel Convolutional Neural Network</p>
<p>解决了什么问题？</p>
<ul>
<li>将插值后的低分辨率图像输入到网络（类似SRCNN），即要在较高的分辨率上进行卷积，增加了计算复杂度</li>
<li>本文提出了一种直接在低分辨率图像尺寸上提取特征，计算得到高分辨率图像的高效方法</li>
</ul>
<p>主要创新点？</p>
<ul>
<li>尺寸放大的插值函数被隐含地包含在前面的卷积层中，可自动学习到</li>
<li>卷积运算都是在低分辨率图像尺寸大小上进行，因此效率较高</li>
<li>在模型末端进行上采样，使得在低分辨率空间保留更多的纹理区域，在视频超分中也可以做到实时</li>
<li>模块末端直接使用亚像素卷积的方式来进行上采样，可以学习到更好、更为复杂的方式，获得更好的重建效果</li>
</ul>
<h2 id="4-VDSR"><a href="#4-VDSR" class="headerlink" title="4 VDSR"></a>4 VDSR</h2><p>Accurate Image Super-Resolution Using Very Deep Convolutional Networks</p>
<p>解决了什么问题？</p>
<ul>
<li>解决了网络结构较深时无法训练的问题，同时性能也得到了提升</li>
<li>感受野小，太依赖小区域内容</li>
<li>模型只对某个放大比例有效</li>
</ul>
<p>主要创新点？</p>
<ul>
<li>LR和HR在很大程度上是相似的，即两者的低频信息相近，训练时只需学习两者之间的高频部分残差</li>
<li>加深了网络结构（20层），使得越深的网络层拥有更大的感受野</li>
<li>残差图像比较稀疏，大部分值都为0或者比较小，因此收敛速度快</li>
<li>应用自适应梯度裁剪，将梯度限制在某一范围，也能加快收敛过程</li>
<li>实验证明补0操作能提升对边界像素的预测结果</li>
<li>将不同倍数的图像混合在一起训练，这样训练出来的一个模型就可以解决不同倍数的超分辨率问题</li>
</ul>
<h2 id="5-DRCN"><a href="#5-DRCN" class="headerlink" title="5 DRCN"></a>5 DRCN</h2><p>Deeply-Recursive Convolutional Network for Image Super-Resolution</p>
<p>解决了什么问题？</p>
<ul>
<li>对于图像复原问题的操作问题，深度学习处理的时候时不使用pooling层</li>
<li>使用递归神经网络解决：网络较深时有较多参数，导致的过拟合，模型过大、难以存储和重现</li>
<li>采用skip connection 结构解决了：梯度消失、爆炸，不易收敛</li>
</ul>
<p>主要创新点？</p>
<ul>
<li>DRCN第一次将之前已有的递归神经网络(Recursive Neural Network)结构应用在超分辨率处理中</li>
<li>利用残差学习的思想(文中的跳跃连接)，加深了网络结构(16个递归)，增加了网络感受野，提升了性能</li>
<li>DRCN输入的是插值后的图像。Embedding network相当于特征提取，Inference network相当于特征的非线性映射，Reconstruction network从特征图像恢复最后的重建结果</li>
<li>Inference network是一个递归网络，即数据循环地通过该层多次，等效于使用同一组参数的多个串联的卷积层</li>
</ul>
<h2 id="6-RED"><a href="#6-RED" class="headerlink" title="6 RED"></a>6 RED</h2><p>Image Restoration Using Convolutional Auto-encoders with Symmetric Skip Connections</p>
<p>解决了什么问题？</p>
<ul>
<li>编码-解码框架能够让反向传播信号直接传递到底层，解决了梯度消失问题</li>
<li>编码-解码框架可以将卷积层的细节传递给反卷积层，能够恢复出更干净的图片</li>
</ul>
<p>主要创新点？</p>
<ul>
<li>提出了卷积反卷积对称网络结构，可用于多种任务：image denoising、image super-resolution、JPEG deblocking、 non-blind image deblurring、image inpainting……</li>
<li>卷积：图像特征被提取，同时噪声被降低</li>
<li>反卷积：针对特征的上采样，完成由图像特征到图像的转换，由于利用的是过滤后的噪声后的图像特征，因此达到了降噪、图像修复的目的</li>
<li>实验说明利用反卷积结构而不用Padding和Upsampling的原因：反卷积对图像细节有补偿作用</li>
</ul>
<h2 id="7-DRRN"><a href="#7-DRRN" class="headerlink" title="7 DRRN"></a>7 DRRN</h2><p>Image Super-Resolution via Deep Recursive Residual Network</p>
<p>DRRN的方法来用于单图Y通道上的超分，作者应该是受到了ResNet、VDSR和DRCN的启发，采用了更深的网络结构来获取性能的提升。DRRN中的每个残差单元都共同拥有一个相同的输入，即递归块中的第一个卷积层的输出。每个残差单元都包含2个卷积层。在一个递归块内，每个残差单元内对应位置相同的卷积层参数都共享。总之，DRRN就是通过对之前已有的ResNet等结构进行调整，采取更深的网络结构得到结果的提升。</p>
<p>作者列出了ResNet、VDSR、DRCN和DRRN四者的主要策略：</p>
<ul>
<li>ResNet是链模式的局部残差学习。</li>
<li>VDSR是全局残差学习。</li>
<li>DRCN是全局残差学习+单权重的递归学习+多目标优化。</li>
<li>DRRN是多路径模式的局部残差学习+全局残差学习+多权重的递归学习。</li>
</ul>
<p>创新点：</p>
<ul>
<li>使用VDSR的调整梯度裁剪和DRCN的递归学习来解决深度增加的网络对梯度传播带来困难</li>
<li>递归模块中权重共享减少了模型所需要的参数，从而保证不发生梯度爆炸或者梯度消失</li>
<li>学习残差的好处就是对网络的参数要求低，网络不需要记忆太多的图片细节，从而有利于梯度传输，防止梯度消失或者梯度爆炸</li>
<li>全局和局部残差学习。每个递归块中都使用局部残差学习，然后总体在模型的输出层那里加上一个全局残差学习，整体模型中只有一个全局残差学习和多个局部残差学习。</li>
</ul>
<h2 id="8-LapSRN"><a href="#8-LapSRN" class="headerlink" title="8 LapSRN"></a>8 LapSRN</h2><p>Deep Laplacian Pyramid Networks for Fast and Accurate Super-Resolution</p>
<p>之前的方法存在有三点问题：</p>
<ul>
<li>输入网络前上采样操作增加了额外的计算开销，同时也会导致可见的重建伪影。使用了亚像素卷积层或者反卷积层这样的操作来替换预先定义好的上采样操作相对比较简单，性能较差，并不能学好低分辨率图像到高分辨率图像复杂的映射</li>
<li>使用 L2 型损失函数不可避免地会产生模糊的预测，恢复出的高分辨率图片往往会太过于平滑</li>
<li>在重建高分辨率图像时，如果只用一次上采样的操作，在获得大倍数(8倍以上)的上采样因子时就会比较困难。而且在不同的应用时，需要训练不同上采样倍数的模型。</li>
</ul>
<p>关键点：</p>
<ul>
<li>LapSRN的结构可以看成有多级，每一级完成一次2倍的上采样操作，要实现8倍的上采样就需要有三级。</li>
<li>在每一级中，先通过一些级联的卷积层提取特征，接着通过一个反卷积层将提取出的特征的尺寸上采样2倍。</li>
<li>反卷积层后连有两个卷积层，一个卷积层的作用是继续提取特征，另外一个卷积层的作用是预测出这一级的残差。</li>
<li>输入图像在每一级也经过一个反卷积层使尺寸上采样2倍，再与对应级的残差相加，就能重构出这一级的上采样结果。</li>
<li>LapSRN通过逐步上采样，一级一级预测残差的方式，在做高倍上采样时，也能得到中间低倍上采样结果的输出。由于尺寸是逐步放大，不是所有的操作都在大尺寸特征上进行，因此速度比较快。</li>
<li>LapSRN设计了损失函数来训练网络，对每一级的结果都进行监督，因此取得了不错的结果。</li>
</ul>
<h2 id="9-DBPN"><a href="#9-DBPN" class="headerlink" title="9 DBPN"></a>9 DBPN</h2><p>Deep Back-Projection Networks(DBPN)提出了⼀种不断迭代地进⾏增采样和降采样的⽹络，为每个阶段的映射错误提供错误反馈机制，构建了相互连接的上采样和下采样阶段，每个阶段代表不同类型的图像退化和HR分量。</p>
<p>未完待续……</p>
]]></content>
      <tags>
        <tag>深度学习</tag>
        <tag>超分辨率</tag>
        <tag>图像超分</tag>
      </tags>
  </entry>
  <entry>
    <title>Video Captioning</title>
    <url>/2019/09/19/Video-Captioning/</url>
    <content><![CDATA[<p>为一张图片产生一个描述被称为image caption任务，为一个视频产生一个描述成为vedio caption，但视频可以理解为在时间上有连续性的一组图片，因此可以理解成为一组图片产生一个描述。Vedio caption是属于对vedio analysis的高层语义分析。描述一般描述两个方向，属性和相互关系。</p>
<a id="more"></a>

<h2 id="三种基本方法"><a href="#三种基本方法" class="headerlink" title="三种基本方法"></a>三种基本方法</h2><ul>
<li>基于模版的方法：较为简单，caption质量在很大程度上取决于句子的模板，句子用句法结构生成，多样性较差。</li>
<li>基于检索的方法：一般来说，这个方法在固定场景内的视频中是有效的，因为嵌入空间可以很好地推广，并且更丰富的模型结构提高了性能。 然而，当遇到以前从未见过的情况的视频时，效果会很差。 此外，由于嵌入是固定长度的，因此它限制了视频和文本描述可以携带的信息量。</li>
<li>基于编码的方法： 更正式地说，这些工作提出的框架是一个编码器 - 解码器结构，它将视频编码为语义表示特征向量，然后解码为自然语言。</li>
</ul>
<h2 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h2><h3 id="3D卷积"><a href="#3D卷积" class="headerlink" title="3D卷积"></a>3D卷积</h3><ul>
<li>由于视频帧之间具有时间连续性，普通的2D卷积不能够充分表达这个特性，因此把相邻的几个帧合在一起组成一个具有三个维度的输入向量，同时在这三个维度进行卷积。</li>
<li>3D卷积也只是一种增加时间信息的补充手段，实际使用中2D卷积的结果+3D卷积结果fusion一起的效果更好。</li>
<li>3D CNN模型的主要特性有：<ul>
<li>1）通过3D卷积操作核去提取数据的时间和空间特征，在CNN的卷积层使用3D卷积。</li>
<li>2）3D CNN模型可以同时处理多幅图片，达到附加信息的提取。</li>
<li>3）融合时空域的预测。</li>
</ul>
</li>
</ul>
<h3 id="Attention机制"><a href="#Attention机制" class="headerlink" title="Attention机制"></a>Attention机制</h3><p>两种attention机制：软注意力机制（soft-attention）和硬注意力机制（hard-attention）。软注意力机制对每一个图像区域学习一个大小介于0与1之间的注意力权重，其和为1，再将各图像区域进行加权求和。硬注意力机制则将最大权重置为1，而将其他区域权重置0，以达到仅注意一个区域的目的。在实际的应用中软注意力机制得到了更广泛的应用。由于其良好的效果和可解释性，attention机制已经成为一种主流的模型构件。</p>
<p><a href="https://www.cnblogs.com/ydcode/p/11038064.html" target="_blank" rel="noopener">浅谈 Attention 机制的理解</a></p>
<h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><p><a href="https://blog.csdn.net/gzj_1101/article/details/79376798" target="_blank" rel="noopener">LSTM原理及实现</a></p>
<p><a href="https://www.cnblogs.com/bonelee/p/7715131.html" target="_blank" rel="noopener">LSTM入门学习——结合《LSTM模型》文章看</a></p>
<h2 id="Faster-R-CNN-Model"><a href="#Faster-R-CNN-Model" class="headerlink" title="Faster R-CNN Model"></a>Faster R-CNN Model</h2><p><a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">一文读懂Faster RCNN</a></p>
<h3 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h3><p><a href="https://blog.csdn.net/u013181595/article/details/80990930" target="_blank" rel="noopener">ResNet介绍</a></p>
<h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><img src="/assets/blogimg/VideoCaption.jpeg" alt=""></p>
<p>整体分为三部分。</p>
<ul>
<li>第一部分抽取视频特征，有2D卷积帧抽取，3D卷积，以及2D卷积和3D卷积结合的方式</li>
<li>第二部分对抽取出的视频特征进行处理，又称为encoder，有attention机制，直接pooling，LSTM以及多层级的encoder等，这部分的处理目的一般是为了考虑视频帧之间的时间连续性进行处理。</li>
<li>第三部分就是就是常规的的decoder对编码信息进行解码翻译，有LSTM和GRU等。</li>
</ul>
<p>一般情况下大都只是对第一部分和第二部分，重点在于如何充分考虑视频帧之间的的时间特性来抽取特征和对于抽取出来的特征如何进行更好的再编码。也有用强化学习做video captioning，另18CVPR提出四部分的video caption，多了一个reconstructor部分，达到了目前的state-of-the-art。</p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>首先介绍一下近几年最常用的两个数据库。</p>
<p><a href="http://2016.ms-multimedia-challenge.com/challenge" target="_blank" rel="noopener">MSR-VTT dataset:</a> 该数据集为ACM Multimedia 2016 的 Microsoft Research - Video to Text (MSR-VTT) Challenge。该数据集包含10000个视频片段（video clip），被分为训练，验证和测试集三部分。每个视频片段都被标注了大概20条英文句子。此外，MSR-VTT还提供了每个视频的类别信息（共计20类），这个类别信息算是先验的，在测试集中也是已知的。同时，视频都是包含音频信息的。该数据库共计使用了四种机器翻译的评价指标，分别为：METEOR, BLEU@1-4,ROUGE-L,CIDEr。</p>
<p><a href="https://www.microsoft.com/en-us/download/details.aspx?id=52422&from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fdownloads%2F38cf15fd-b8df-477e-a4e4-a4680caa75af%2Fdefault.aspx" target="_blank" rel="noopener">YouTube2Text dataset</a>(or called MSVD dataset):该数据集同样由Microsoft Research提供。该数据集包含1970段YouTube视频片段（时长在10-25s之间），每段视频被标注了大概40条英文句子。</p>
<p>可以看出，这两个数据库都是trimmed video clip 到 sentences的翻译。而这两年的论文基本上使用这两个数据库为主，说明目前的研究还主要集中在trimmed video clip 到 sentences的翻译。</p>
<h2 id="任务关键点分析"><a href="#任务关键点分析" class="headerlink" title="任务关键点分析"></a>任务关键点分析</h2><p>video captioning任务可以理解为视频图像序列到文本序列的seq2seq任务。在近年的方法中，大部分文章都使用了LSTM来构造encoder-decoder结构，即使用lstm encoder来编码视频图像序列的特征，再用lstm decoder解码出文本信息。这样的video captioning模型结构最早在ICCV2015的”Sequence to Sequence – Video to Text”一文中提出，如下图所示。</p>
<p><img src="/assets/blogimg/videocaption1.png" alt="img"></p>
<p>基于上图中的结构，构造一个encoder-decoder结构的模型主要包括几个关键点：</p>
<ol>
<li>输入特征：即如何提取视频中的特征信息，在很多篇文章中都使用了多模态的特征。主要包括如下几种：</li>
</ol>
<p>基于视频图像的信息：包括简单的用CNN（VGGNet, ResNet等）提取图像(spatial)特征，用action recognition的模型(如C3D)提取视频动态(spatial+temporal)特征</p>
<p>基于声音的特征：对声音进行编码，包括BOAW（Bag-of-Audio-Words)和FV(Fisher Vector)等</p>
<p>先验特征：比如视频的类别，这种特征能提供很强的先验信息</p>
<p>基于文本的特征：此处基于文本的特征是指先从视频中提取一些文本的描述，再將这些描述作为特征，来进行video captioning。这类特征我看到过两类，一类是先对单帧视频进行image captioning,将image captioning的结果作为video captioning的输入特征，另外一类是做video tagging，将得到的标签作为特征。</p>
<p>2.encoder-decoder构造：虽然大部分工作都是用lstm做encoder-decoder，但各个方法的具体配置还是存在着一定的差异。</p>
<p>3.输出词汇的表达：主要包括两类，一类是使用Word2Vec这种词向量表示，另外就是直接使用词袋表示。</p>
<p>4.其它部分：比如训练策略，多任务训练之类的。</p>
<h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><h3 id="BLEU"><a href="#BLEU" class="headerlink" title="BLEU"></a>BLEU</h3><p>bleu是一种文本评估算法，它是用来评估机器翻译跟专业人工翻译之间的对应关系，核心思想就是机器翻译越接近专业人工翻译，质量就越好，经过bleu算法得出的分数可以作为机器翻译质量的其中一个指标。</p>
<ul>
<li>优点：方便、快速，结果比较接近人类评分。</li>
<li>缺点：<ul>
<li>不考虑语言表达（语法）上的准确性；</li>
<li>测评精度会受常用词的干扰；</li>
<li>短译句的测评精度有时会较高；</li>
<li>没有考虑同义词或相似表达的情况，可能会导致合理翻译被否定；<br>BLEU本身就不追求百分之百的准确性，也不可能做到百分之百，它的目标只是给出一个快且不差的自动评估解决方案。</li>
</ul>
</li>
</ul>
<h3 id="Meteor"><a href="#Meteor" class="headerlink" title="Meteor"></a>Meteor</h3><p>METEOR标准于2004年由Lavir发现在评价指标中召回率的意义后提出[3]，他们的研究表明，召回率基础上的标准相比于那些单纯基于精度的标准(如BLEU)，其结果和人工判断的结果有较高相关性；METEOR测度基于单精度的加权调和平均数和单字召回率，其目的是解决一些BLEU标准中固有的缺陷；METEOR也包括其他指标没有发现一些其他功能，如同义词匹配等；计算METEOR需要预先给定一组校准(alignment)m，而这一校准基于WordNet的同义词库，通过最小化对应语句中连续有序的块(chunks)ch来得出。和BLEU不同，METEOR同时考虑了基于整个语料库上的准确率和召回率，而最终得出测度；</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_43624538/article/details/87863463" target="_blank" rel="noopener">Video captioning——Video Analysis视频to文字描述任务</a><br><a href="https://blog.csdn.net/sinat_35177634/article/details/88568491" target="_blank" rel="noopener">视频描述（video caption）历年突破性论文总结</a><br><a href="http://www.cvmart.net/community/article/detail/41" target="_blank" rel="noopener">Video Analysis 相关领域解读之Video Captioning(视频to文字描述)</a></p>
]]></content>
      <tags>
        <tag>Video Captioning</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习术语表</title>
    <url>/2019/09/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8/</url>
    <content><![CDATA[<p>本术语表中列出了一般的机器学习术语和 TensorFlow 专用术语的定义。</p>
<a id="more"></a>

<p>了解详情，请访问 <a href="https://developers.google.cn/machine-learning/glossary/" target="_blank" rel="noopener">机器学习术语表</a>。</p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法汇总</title>
    <url>/2019/07/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>排序算法汇总。动画演示：<a href="https://mp.weixin.qq.com/s/FVOllQoELEK3rvjpdLAxIQ" target="_blank" rel="noopener">一份清晰又全面的排序算法攻略</a></p>
<a id="more"></a>

<ul>
<li><strong>内排序</strong><ul>
<li><a href="#1.插入排序">1.插入排序</a>（稳定）</li>
<li><a href="#2.二分插入排序">2.二分插入排序</a>（稳定）</li>
<li><a href="#3.冒泡排序">3.冒泡排序</a>（稳定）</li>
<li><a href="#4.鸡尾酒排序（冒泡排序的改进）">4.鸡尾酒排序</a>（稳定）</li>
<li><a href="#5.选择排序">5.选择排序</a>（不稳定）</li>
<li><a href="#6.希尔排序">6.希尔排序</a>（不稳定）</li>
<li><a href="#7.快速排序">7.快速排序</a>（不稳定）</li>
<li><a href="#8.归并排序">8.归并排序</a>（稳定）</li>
<li><a href="#9.堆排序">9.堆排序</a>（不稳定）</li>
<li><a href="#10.桶排序">10.桶排序</a></li>
<li><a href="#11.基数排序">11.基数排序</a></li>
</ul>
</li>
<li><strong>外排序</strong><ul>
<li><a href="#12多路归并">12.多路归并</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>稳定性：相同的元素在排序前和排序后的前后位置是否发生改变，没有改变则排序是稳定的，改变则排序是不稳定的 <a href="https://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" target="_blank" rel="noopener">——八大排序算法的稳定性</a></p>
</blockquote>
<h2 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1.插入排序"></a>1.插入排序</h2><p>逐个处理待排序的记录，每个记录与前面已排序已排序的子序列进行比较，将它插入子序列中正确位置</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">inssort</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">1</span> &amp;&amp; A[j]&lt;A[j<span class="number">-1</span>]; j--)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            swap(A, j, j<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><ul>
<li>最佳：升序。时间复杂度为O(n)</li>
<li>最差：降序。时间复杂度为O(n^2)</li>
<li>平均：对于每个元素，前面有一半元素比它大。时间复杂度为O(n^2)</li>
<li>辅助空间：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<blockquote>
<p>如果待排序数据已经“基本有序”，使用插入排序可以获得接近O(n)的性能</p>
</blockquote>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">inssort</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> tp = A[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(; j&gt;=<span class="number">1</span> &amp;&amp; tp&lt;A[j<span class="number">-1</span>]; j--)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A[j] = A[j - <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A[j] = tp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h2 id="2-二分插入排序"><a href="#2-二分插入排序" class="headerlink" title="2.二分插入排序"></a>2.二分插入排序</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">InsertionSortDichotomy</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span>   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> <span class="built_in">get</span> = A[i];                 <span class="comment">// 右手抓到一张扑克牌</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;                   <span class="comment">// 拿在左手上的牌总是排序好的，所以可以用二分法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;              <span class="comment">// 手牌左右边界进行初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(left &lt;= right)            <span class="comment">// 采用二分法定位新牌的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (A[mid] &gt; <span class="built_in">get</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                right = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                left = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=left; j--)    <span class="comment">// 将欲插入新牌位置右边的牌整体向右移动一个单位</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            A[j+<span class="number">1</span>] = A[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A[left] = <span class="built_in">get</span>;                  <span class="comment">// 将抓到的牌插入手牌</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h3><ul>
<li>最佳：时间复杂度为O(nlogn)</li>
<li>最差：时间复杂度为O(n^2)</li>
<li>平均：时间复杂度为O(n^2)</li>
<li>辅助空间：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<h2 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h2><p>从数组的底部比较到顶部，比较相邻元素。如果下面的元素更小则交换，否则，上面的元素继续往上比较。这个过程每次使最小元素像个“气泡”似地被推到数组的顶部</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">bubsort</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;i; j--)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[j<span class="number">-1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                swap(A, j, j<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="性能-2"><a href="#性能-2" class="headerlink" title="性能"></a>性能</h3><ul>
<li>最佳：时间复杂度为O(n)</li>
<li>最差：时间复杂度为O(n^2)</li>
<li>平均：时间复杂度为O(n^2)</li>
<li>辅助空间：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>增加一个变量flag，用于记录一次循环是否发生了交换，如果没发生交换说明已经有序，可以提前结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">bubsort</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> flag;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      	flag = <span class="literal">false</span>;           <span class="comment">// 一趟前flag置为假</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>; j&gt;i; j--)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[j<span class="number">-1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	             	swap(A, j, j<span class="number">-1</span>); </span></pre></td></tr><tr><td class="code"><pre><span class="line">	              flag = <span class="literal">true</span>;    <span class="comment">// 一旦有交换，flag置为真</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      	<span class="keyword">if</span>(!flag)               <span class="comment">// 本趟没有发生交换，中途结束算法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          	<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h2 id="4-鸡尾酒排序（冒泡排序的改进）"><a href="#4-鸡尾酒排序（冒泡排序的改进）" class="headerlink" title="4.鸡尾酒排序（冒泡排序的改进）"></a>4.鸡尾酒排序（冒泡排序的改进）</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">CocktailSort</span>(<span class="title">Elem</span> <span class="title">a</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span>   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;                        <span class="comment">// 初始化边界</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(left &lt; right)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;right; i++)    <span class="comment">// 前半轮,将最大元素放到后面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[i+<span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                swap(a[i], a[i+<span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        right--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=right; i&gt;left; i--)    <span class="comment">// 后半轮,将最小元素放到前面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>] &gt; a[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                swap(a[i<span class="number">-1</span>], a[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        left++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="性能-3"><a href="#性能-3" class="headerlink" title="性能"></a>性能</h3><ul>
<li>最佳：时间复杂度为O(n)</li>
<li>最差：时间复杂度为O(n^2)</li>
<li>平均：时间复杂度为O(n^2)</li>
<li>辅助空间：O(1)</li>
<li>稳定性：稳定</li>
</ul>
<h2 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5.选择排序"></a>5.选择排序</h2><p>第i次“选择”数组中第i小的记录，并将该记录放到数组的第i个位置。换句话说，每次从未排序的序列中找到最小元素，放到未排序数组的最前面</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">selsort</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> lowindex = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[lowindex])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                lowindex = j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        swap(A, i, lowindex);  <span class="comment">// n次交换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="性能-4"><a href="#性能-4" class="headerlink" title="性能"></a>性能</h3><p>不管数组是否有序，在从未排序的序列中查找最小元素时，都需要遍历完最小序列，所以时间复杂度为O(n^2)</p>
<ul>
<li>最佳：时间复杂度为O(n^2)</li>
<li>最差：时间复杂度为O(n^2)</li>
<li>平均：时间复杂度为O(n^2)</li>
<li>辅助空间：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><p>每次内层除了找出一个最小值，同时找出一个最大值（初始为数组结尾）。将最小值与每次处理的初始位置的元素交换，将最大值与每次处理的末尾位置的元素交换。这样一次循环可以将数组规模减小2，相比于原有的方案（减小1）会更快</p>
<h2 id="6-希尔排序"><a href="#6-希尔排序" class="headerlink" title="6.希尔排序"></a>6.希尔排序</h2><p>shell排序在不相邻的元素之间比较和交换。利用了插入排序的最佳时间代价特性，它试图将待排序序列变成基本有序的，然后再用插入排序来完成排序工作</p>
<p>在执行每一次循环时，Shell排序把序列分为互不相连的子序列，并使各个子序列中的元素在整个数组中的间距相同，每个子序列用<strong>插入排序</strong>进行排序。每次循环增量是前一次循环的1/2，子序列元素是前一次循环的2倍</p>
<p>最后一轮将是一次“正常的”插入排序（即对包含所有元素的序列进行插入排序）</p>
<p><img src="/assets/blogimg/AllSortAlgorithms.png" alt=""></p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INCRGAP = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">shellsort</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> incr=n/INCRGAP; incr&gt;<span class="number">0</span>; incr/=INCRGAP)  <span class="comment">// 遍历所有增量大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;incr; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 对子序列进行插入排序，当增量为1时，对所有元素进行最后一次插入排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+incr; j&lt;n; j+=incr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=j; k&gt;i&amp;&amp;A[k]&lt;A[k-incr]; k-=incr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    swap(A, k, k-incr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="性能-5"><a href="#性能-5" class="headerlink" title="性能"></a>性能</h3><p>选择适当的增量序列可使Shell排序比其他排序法更有效，一般来说，增量每次除以2时并没有多大效果，而“增量每次除以3”时效果更好</p>
<p>当选择“增量每次除以3”递减时，Shell排序的平均运行时间是O(n^(1.5))</p>
<ul>
<li>最佳：根据步长序列的不同而不同</li>
<li>最差：根据步长序列的不同而不同，已知最好的为O(n(logn)^2)</li>
<li>平均：时间复杂度为O(n)</li>
<li>辅助空间：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<h2 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7.快速排序"></a>7.快速排序</h2><p>首先选择一个轴值，小于轴值的元素被放在数组中轴值左侧，大于轴值的元素被放在数组中轴值右侧，这称为数组的一个分割(partition)。快速排序再对轴值左右子数组分别进行类似的操作</p>
<p>选择轴值有多种方法。最简单的方法是使用首或尾元素。但是，如果输入的数组是正序或者逆序时，会将所有元素分到轴值的一边。较好的方法是随机选取轴值</p>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">int</span> <span class="title">partition</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">i</span>, <span class="title">int</span> <span class="title">j</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 这里选择尾元素作为轴值,轴值的选择可以设计为一个函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果选择的轴值不是尾元素，还需将轴值与尾元素交换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> pivot = A[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = i - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=i; r&lt;j; r++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(A[r] &lt;= pivot)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            swap(A, ++l, r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    swap(A, ++l, j);  <span class="comment">// 将轴值从末尾与++l位置的元素交换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">qsort</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">i</span>, <span class="title">int</span> <span class="title">j</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(j &lt;= i)  <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> p = partition&lt;Elem&gt;(A, i, j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    qsort&lt;Elem&gt;(A, i, p - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    qsort&lt;Elem&gt;(A, p+<span class="number">1</span>, j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="性能-6"><a href="#性能-6" class="headerlink" title="性能"></a>性能</h3><ul>
<li>最佳：时间复杂度为O(nlogn)</li>
<li>最差：每次处理将所有元素划分到轴值一侧，时间复杂度为O(n^2)</li>
<li>平均：时间复杂度为O(nlogn)</li>
<li>辅助空间：O(logn)</li>
<li>稳定性：不稳定</li>
</ul>
<blockquote>
<p>快速排序平均情况下运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。<strong>快速排序是所有内部排序算法中平均性能最优的排序算法</strong></p>
</blockquote>
<h3 id="优化-3"><a href="#优化-3" class="headerlink" title="优化"></a>优化</h3><ol>
<li><p>最明显的改进之处是轴值的选取，如果轴值选取合适，每次处理可以将元素较均匀的划分到轴值两侧：<strong>三者取中法</strong>：三个随机值的中间一个。为了减少随机数生成器产生的延迟，可以选取首中尾三个元素作为随机值</p>
</li>
<li><p>当n很小时，快速排序会很慢。因此当子数组小于某个长度（经验值：9）时，什么也不要做。此时数组已经基本有序，最后调用一次插入排序完成最后处理</p>
</li>
</ol>
<h2 id="8-归并排序"><a href="#8-归并排序" class="headerlink" title="8.归并排序"></a>8.归并排序</h2><p>将一个序列分成两个长度相等的子序列，为每一个子序列排序，然后再将它们合并成一个序列。合并两个子序列的过程称为归并</p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">mergesortcore</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">Elem</span> <span class="title">temp</span>[], <span class="title">int</span> <span class="title">i</span>, <span class="title">int</span> <span class="title">j</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(i == j)  <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid = (i + j)/<span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mergesortcore(A, temp, i, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mergesortcore(A, temp, mid+<span class="number">1</span>, j);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 归并</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i1 = i, i2 = mid + <span class="number">1</span>, curr = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i1&lt;=mid &amp;&amp; i2&lt;=j)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(A[i1] &lt; A[i2])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            temp[curr++] = A[i1++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            temp[curr++] = A[i2++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i1 &lt;= mid)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp[curr++] = A[i1++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i2 &lt;= j)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp[curr++] = A[i2++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(curr = i;curr &lt;= j;curr++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A[curr] = temp[curr];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">mergesort</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">sz</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Elem *temp = <span class="keyword">new</span> Elem[sz]();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = sz - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mergesortcore(A, temp, i, j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">delete</span> [] temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="性能-7"><a href="#性能-7" class="headerlink" title="性能"></a>性能</h3><ul>
<li>最佳：时间复杂度为O(nlogn)</li>
<li>最差：时间复杂度为O(nlogn)</li>
<li>平均：时间复杂度为O(nlogn)</li>
<li>辅助空间：O(n)</li>
<li>稳定性：稳定</li>
</ul>
<h3 id="优化-4"><a href="#优化-4" class="headerlink" title="优化"></a>优化</h3><p>原地归并排序不需要辅助数组即可归并</p>
<p><img src="/assets/blogimg/mergesort.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i &lt; j)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        swap(arr[i++], arr[j--]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> sz, <span class="keyword">int</span> left)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    reverse(arr, left);  <span class="comment">// 翻转左边部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    reverse(arr + left, sz - left);  <span class="comment">// 翻转右边部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    reverse(arr, sz);    <span class="comment">// 翻转所有</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> mid, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="built_in">begin</span>, j = mid, k = <span class="built_in">end</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i&lt;j &amp;&amp; j&lt;=k)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; arr[i]&lt;=arr[j])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ++i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(j&lt;=k &amp;&amp; arr[j]&lt;=arr[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ++j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ++right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        exchange(arr+i, j-i, j-i-right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i += right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h2 id="9-堆排序"><a href="#9-堆排序" class="headerlink" title="9.堆排序"></a>9.堆排序</h2><p>堆排序首先根据数组构建最大堆，然后每次“删除”堆顶元素（将堆顶元素移至末尾）。最后得到的序列就是从小到大排序的序列</p>
<p><img src="/assets/blogimg/heapsort.png" alt=""></p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><p>这里直接使用C++ STL中堆的构建与删除函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Elem</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">heapsort</span>(<span class="title">Elem</span> <span class="title">A</span>[], <span class="title">int</span> <span class="title">n</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Elem mval;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span> = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    make_heap(A, A+<span class="built_in">end</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pop_heap(A, A+<span class="built_in">end</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">end</span>--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果不能使用现成的库函数：实现1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 向堆中插入元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *  hole：新元素所在的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> ********************************************/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> _<span class="title">push_heap</span>(<span class="title">vector</span>&lt;value&gt; &amp;<span class="title">arr</span>,<span class="title">int</span> <span class="title">hole</span>)&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    value v = arr[hole];<span class="comment">//取出新元素，从而产生一个空洞</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> parent = (hole - <span class="number">1</span>) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//建最大堆，如果建最小堆换成 arr[parent] &gt; value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(hole &gt; <span class="number">0</span> &amp;&amp; arr[parent] &lt; v)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[hole] = arr[parent];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hole = parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        parent = (hole - <span class="number">1</span>) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arr[hole] = v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 删除堆顶元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> ********************************************/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> _<span class="title">pop_heap</span>(<span class="title">vector</span>&lt;value&gt; &amp;<span class="title">arr</span>,<span class="title">int</span> <span class="title">sz</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    value v = arr[sz - <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arr[sz - <span class="number">1</span>] = arr[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    --sz;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> hole = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> child = <span class="number">2</span> * (hole + <span class="number">1</span>); <span class="comment">//右孩子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(child &lt; sz)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(arr[child] &lt; arr[child - <span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            --child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[hole] = arr[child];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hole = child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        child = <span class="number">2</span> * (hole + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(child == sz)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[hole] = arr[child - <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hole = child - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    arr[hole] = v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    _push_heap(arr,hole);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 建堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *  sz：删除堆顶元素后的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *  v： 被堆顶元素占据的位置原来的元素的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> ********************************************/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> _<span class="title">make_heap</span>(<span class="title">vector</span>&lt;value&gt; &amp;<span class="title">arr</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sz = arr.<span class="built_in">size</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> parent = (sz - <span class="number">2</span>) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(parent &gt;= <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> hole = parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> child = <span class="number">2</span> * (hole + <span class="number">1</span>); <span class="comment">//右孩子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        value v = arr[hole];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(child &lt; sz)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(arr[child] &lt; arr[child - <span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                --child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            arr[hole] = arr[child];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hole = child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child = <span class="number">2</span> * (hole + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(child == sz)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            arr[hole] = arr[child - <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hole = child - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[hole] = v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _push_heap(arr,hole);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --parent;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">value</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="title">void</span> <span class="title">heap_sort</span>(<span class="title">vector</span>&lt;value&gt; &amp;<span class="title">arr</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _make_heap(arr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sz = arr.<span class="built_in">size</span>();sz &gt; <span class="number">1</span>;sz--)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _pop_heap(arr,sz);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果不能使用现成的库函数：实现2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heapify</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> i, <span class="keyword">int</span> <span class="built_in">size</span>)</span>  <span class="comment">// 从A[i]向下进行堆调整</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> left_child = <span class="number">2</span> * i + <span class="number">1</span>;         <span class="comment">// 左孩子索引</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> right_child = <span class="number">2</span> * i + <span class="number">2</span>;        <span class="comment">// 右孩子索引</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = i;                        <span class="comment">// 选出当前结点与其左右孩子三者之中的最大值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (left_child &lt; <span class="built_in">size</span> &amp;&amp; A[left_child] &gt; A[<span class="built_in">max</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">max</span> = left_child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (right_child &lt; <span class="built_in">size</span> &amp;&amp; A[right_child] &gt; A[<span class="built_in">max</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">max</span> = right_child;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="built_in">max</span> != i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Swap(A, i, <span class="built_in">max</span>);                <span class="comment">// 把当前结点和它的最大(直接)子节点进行交换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Heapify(A, <span class="built_in">max</span>, <span class="built_in">size</span>);          <span class="comment">// 递归调用，继续从当前结点向下进行堆调整</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span>           <span class="comment">// 建堆，时间复杂度O(n)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> heap_size = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = heap_size / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="comment">// 从每一个非叶结点开始向下进行堆调整</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Heapify(A, i, heap_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> heap_size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> heap_size = BuildHeap(A, n);    <span class="comment">// 建立一个最大堆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (heap_size &gt; <span class="number">1</span>)    　　　　　　 <span class="comment">// 堆（无序区）元素个数大于1，未完成排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Swap(A, <span class="number">0</span>, --heap_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Heapify(A, <span class="number">0</span>, heap_size);     <span class="comment">// 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="性能-8"><a href="#性能-8" class="headerlink" title="性能"></a>性能</h3><p>根据已有数组构建堆需要O(n)的时间复杂度，每次删除堆顶元素需要O(logn)的时间复杂度，所以总的时间开销为，O(n+nlogn)，平均时间复杂度为O(nlogn)</p>
<ul>
<li>最佳：时间复杂度为O(nlogn)</li>
<li>最差：时间复杂度为O(nlogn)</li>
<li>平均：时间复杂度为O(nlogn)</li>
<li>辅助空间：O(1)</li>
<li>稳定性：不稳定</li>
</ul>
<blockquote>
<p>注意根据已有元素建堆是很快的，如果希望找到数组中第k大的元素，可以用O(n+klogn)的时间，如果k很小，时间开销接近O(n)</p>
</blockquote>
<h2 id="10-桶排序"><a href="#10-桶排序" class="headerlink" title="10.桶排序"></a>10.桶排序</h2><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PutAt</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> <span class="built_in">max</span>, <span class="keyword">int</span> k)</span></span>&#123; <span class="comment">// 返回数字n应该放入的桶编号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i &lt; k<span class="number">-1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n&gt;<span class="built_in">max</span>*i/k &amp;&amp; n&lt;<span class="built_in">max</span>*(i+<span class="number">1</span>)/k) <span class="comment">// 将0~max划分成k个区间/桶</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span></span>&#123; <span class="comment">// 桶内插入排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;v.<span class="built_in">size</span>(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = v[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; temp&lt;v[j]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v[j + <span class="number">1</span>] = v[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            j--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v[j+<span class="number">1</span>] = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BucketSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> <span class="built_in">max</span>, <span class="keyword">int</span> k)</span> </span>&#123; <span class="comment">// max为数字最大值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; bucket;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bucket.resize(k); <span class="comment">// 默认k个桶</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        bucket[PutAt(v[i], <span class="built_in">max</span>, k)].push_back(v[i]); <span class="comment">//入桶</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;bucket.<span class="built_in">size</span>(); j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// sort(bucket[j].begin(), bucket[j].end()); //快速排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InsertSort(bucket[j]); <span class="comment">//插入排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bucket.<span class="built_in">size</span>(); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;bucket[i].<span class="built_in">size</span>(); j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v[n++] = bucket[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h2 id="11-基数排序"><a href="#11-基数排序" class="headerlink" title="11.基数排序"></a>11.基数排序</h2><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 待排序数组，数字位数，数字个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> count = k + <span class="number">1</span>, <span class="built_in">bit</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data *p, *first, *L = <span class="keyword">new</span> data[<span class="number">10</span>]; <span class="comment">// L是以数字0-9为基础的十个数表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        L[i].link = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(k--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,v; i&lt;n; i++) &#123; <span class="comment">// 将当前位数字值相同的数放入相应的表中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            p = <span class="keyword">new</span> data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;number = A[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;link = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">bit</span> = count - k; <span class="comment">//从个位（bit=1）开始的位数号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(<span class="built_in">bit</span>--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                v = A[i] % <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                A[i] = A[i] / <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(L[v].link == <span class="number">0</span>) </span></pre></td></tr><tr><td class="code"><pre><span class="line">                L[v].link = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                first = L[v].link;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span>(first-&gt;link) </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    first = first-&gt;link;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                first-&gt;link = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,v=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123; <span class="comment">// 所有表的数字从小到大从新组织成序列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            p = L + i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            first = L[i].link;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(first) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                A[v] = first-&gt;number;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                v++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p = first;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                first = first-&gt;link;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">delete</span> p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            L[i].link = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">delete</span> []L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h2 id="12-多路归并"><a href="#12-多路归并" class="headerlink" title="12.多路归并"></a>12.多路归并</h2><p>多路归并是<strong>外部排序最常用</strong>的算法：<strong>将原文件分解成多个能够一次性装入内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行归并排序</strong></p>
<p><img src="/assets/blogimg/al-kmerge.png" alt=""></p>
<h3 id="k的选择"><a href="#k的选择" class="headerlink" title="k的选择"></a>k的选择</h3><p>假设总共m个子文件，每次归并k个子文件，那么一共需要归并$$\log _{k} m$$次（扫描磁盘），在k个元素中找出最小值（或最大值）需要比较k-1次。如果总记录数为N，所以时间复杂度就是$$(k-1) N \log _{k} m=\frac{(k-1)}{\log k} N \log m$$， 由于 $$\frac{(k-1)}{\log k}$$随k的增大而增大，所以比较次数的增加会逐步抵消“低扫描次数”带来的性能增益，所以对于k值的选择，主要涉及两个问题：</p>
<ol>
<li>每一轮归并会将结果写回到磁盘，那么k越小，磁盘与内存之间数据的传输就会越多，增大k可以较少扫描次数</li>
<li>k个元素中选取最小的元素需要比较k-1次，如果k越大，比较的次数就会越大</li>
</ol>
<h3 id="优化-5"><a href="#优化-5" class="headerlink" title="优化"></a>优化</h3><p>可以利用下列方法<strong>减少比较次数</strong>：</p>
<ol>
<li><strong>败者树</strong></li>
<li><strong>建堆</strong>：使用一个k个元素的数组，第一次将k个文件中最小的元素读入数组（并且记录每个元素来自哪个文件），然后建最小堆，将堆顶元素删除，并从堆顶元素的源文件中取出下一个数，插入堆中，调整后重复上述操作。虽然第一次需要遍历k个文件取出最小元素，加上建堆需要一定时间，但是后续操作可以很快完成</li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>蚁群算法解决旅行商问题</title>
    <url>/2019/04/29/%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/旅行推销员问题" target="_blank" rel="noopener">什么是旅行商问题（TSP）？</a><a href="https://www.wikiwand.com/zh-hans/蚁群算法" target="_blank" rel="noopener">什么是蚁群算法？</a></p>
<a id="more"></a>

<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul>
<li>蚂蚁在路径上释放信息素。</li>
<li>碰到还没走过的路口，就随机挑选一条路走。同时，释放与路径长度有关的信息素。</li>
<li>信息素浓度与路径长度成反比。后来的蚂蚁再次碰到该路口时，就选择信息素浓度较高路径。</li>
<li>最优路径上的信息素浓度越来越大。</li>
<li>最终蚁群找到最优寻食路径。</li>
</ul>
<h3 id="人工蚁群与真实蚁群对比"><a href="#人工蚁群与真实蚁群对比" class="headerlink" title="人工蚁群与真实蚁群对比"></a>人工蚁群与真实蚁群对比</h3><ul>
<li>相同点：<ul>
<li>都存在个体相互交流的通信机制</li>
<li>都要完成寻找最短路径的任务</li>
<li>都采用根据当前信息进行路径选择的随机选择策略</li>
</ul>
</li>
<li>不同点：<ul>
<li>人工蚂蚁具有记忆能力</li>
<li>人工蚂蚁选择路径时不是完全盲目的</li>
<li>人工蚂蚁生活在离散时间环境中</li>
</ul>
</li>
</ul>
<h3 id="蚂蚁"><a href="#蚂蚁" class="headerlink" title="蚂蚁"></a>蚂蚁</h3><ul>
<li>每次周游，每只蚂蚁在其经过的支路（i,j）上都留下信息素。</li>
<li>蚂蚁选择城市的概率与城市之间的距离和当前连接支路上所包含的信息素余量有关。</li>
</ul>
<h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><ul>
<li><strong>Alpha</strong>：<strong>信息启发式</strong>，Alpha值越大，蚂蚁选择之前走过路径的可能性就越大；值越小，蚁群搜索范围就越小，容易陷入局部最优。</li>
<li><strong>Beta</strong>：<strong>期望启发式因子</strong>，Beta越大，蚁群越容易选择局部较短路径，这时算法收敛速度加快，但随机性不高，容易得到局部最优解。</li>
<li><strong>M</strong>：<strong>蚁群数量</strong>，M越大，最优解越精确，但会产生重复解，消耗资源，增大时间复杂度。</li>
<li><strong>RHO</strong>：<strong>信息发挥因子</strong>，<strong>1-RHO</strong>表示<strong>残留因子</strong>，RHO过小，各路径上残留信息素过多，导致无效路径继续被搜素，影响算法收敛效率；RHO过大，有效路径可能会被放弃搜索，影响最优解的搜索。</li>
<li><strong>Q</strong>：用于<strong>信息素增量</strong>的设置，在<strong>蚁周模型</strong>下，<strong>信息素增量=Q/当前解路径总长度</strong>。蚁周模型利用的是全局信息，即蚂蚁完成一个循环后更新所有路径上的信息素。</li>
</ul>
<h3 id="蚁群算法中参数的理想设置"><a href="#蚁群算法中参数的理想设置" class="headerlink" title="蚁群算法中参数的理想设置"></a>蚁群算法中参数的理想设置</h3><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Alpha</td>
<td align="center">[0, 5]</td>
</tr>
<tr>
<td align="center">Beta</td>
<td align="center">[0, 5]</td>
</tr>
<tr>
<td align="center">Q</td>
<td align="center">[10, 10000]</td>
</tr>
<tr>
<td align="center">RHO</td>
<td align="center">[0.1, 0.99]</td>
</tr>
</tbody></table>
<h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="/assets/blogimg/TSP_ACO_g.png" alt=""></p>
<h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TSP_ACO: 蚁群算法解决旅行商问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 设置参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">epochs = <span class="number">300</span>  <span class="comment"># 最大代数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ALPHA = <span class="number">1</span>  <span class="comment"># 信息启发因子(值越大，蚂蚁选择之前走过路径的可能性就越大；值越小，蚁群搜索范围就越小，容易陷入局部最优)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">BETA = <span class="number">2</span>  <span class="comment"># Beta越大，蚁群越容易选择局部较短路径，这时算法收敛速度加快，但随机性不高，容易得到局部最优解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">RHO = <span class="number">0.5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Q = <span class="number">100.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 城市数，蚁群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">city_num = <span class="number">20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ant_num = city_num</span></pre></td></tr><tr><td class="code"><pre><span class="line">location_x = [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">178</span>, <span class="number">272</span>, <span class="number">176</span>, <span class="number">171</span>, <span class="number">650</span>, <span class="number">499</span>, <span class="number">267</span>, <span class="number">703</span>, <span class="number">408</span>, <span class="number">437</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">428</span>, <span class="number">614</span>, <span class="number">36</span>, <span class="number">360</span>, <span class="number">482</span>, <span class="number">666</span>, <span class="number">597</span>, <span class="number">209</span>, <span class="number">201</span>, <span class="number">492</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">location_y = [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">170</span>, <span class="number">395</span>, <span class="number">198</span>, <span class="number">151</span>, <span class="number">242</span>, <span class="number">556</span>, <span class="number">57</span>, <span class="number">401</span>, <span class="number">305</span>, <span class="number">421</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">490</span>, <span class="number">213</span>, <span class="number">524</span>, <span class="number">244</span>, <span class="number">114</span>, <span class="number">104</span>, <span class="number">552</span>, <span class="number">70</span>, <span class="number">425</span>, <span class="number">227</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 城市距离和信息素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">distance_graph = [[<span class="number">0.0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(city_num)] <span class="keyword">for</span> raw <span class="keyword">in</span> range(city_num)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">pheromone_graph = [[<span class="number">1.0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(city_num)] <span class="keyword">for</span> raw <span class="keyword">in</span> range(city_num)]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'TSP By ACO......'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The number of cities: '</span>, str(city_num))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 蚂蚁类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ant</span><span class="params">(object)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ID)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.ID = ID  <span class="comment"># ID</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__clean_data()  <span class="comment"># 随机初始化出生点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 初始数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__clean_data</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.path = []  <span class="comment"># 当前蚂蚁的路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.total_distance = <span class="number">0.0</span>  <span class="comment"># 当前路径的总距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.move_count = <span class="number">0</span>  <span class="comment"># 移动次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.current_city = <span class="number">-1</span>  <span class="comment"># 当前停留的城市</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.open_table_city = [<span class="literal">True</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(city_num)]  <span class="comment"># 探索城市的状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        city_index = random.randint(<span class="number">0</span>, city_num - <span class="number">1</span>)  <span class="comment"># 随机初始出生点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.current_city = city_index</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.path.append(city_index)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.open_table_city[city_index] = <span class="literal">False</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.move_count = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 选择下一个城市</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__choice_next_city</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        next_city = <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        select_citys_prob = [<span class="number">0.0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(city_num)]  <span class="comment"># 存储去下个城市的概率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        total_prob = <span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 获取去下一个城市的概率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> self.open_table_city[i]:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment"># 计算概率：与信息素浓度成正比，与距离成反比</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                select_citys_prob[i] = pow(pheromone_graph[self.current_city][i], ALPHA) * pow(</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    (<span class="number">1.0</span> / distance_graph[self.current_city][i]), BETA)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                total_prob += select_citys_prob[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 轮盘选择城市</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> total_prob &gt; <span class="number">0.0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 产生一个随机概率, 0.0～total_prob</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            temp_prob = random.uniform(<span class="number">0.0</span>, total_prob)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> self.open_table_city[i]:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment"># 轮次相减</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    temp_prob -= select_citys_prob[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> temp_prob &lt; <span class="number">0.0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        next_city = i</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> next_city == <span class="number">-1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            next_city = random.randint(<span class="number">0</span>, city_num - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> self.open_table_city[next_city] <span class="keyword">is</span> <span class="literal">False</span>:  <span class="comment"># if==False,说明已经遍历过了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                next_city = random.randint(<span class="number">0</span>, city_num - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 返回下一个城市序号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> next_city</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 计算路径总距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__cal_total_distance</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp_distance = <span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            start, end = self.path[i], self.path[i - <span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            temp_distance += distance_graph[start][end]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 回路</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        end = self.path[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp_distance += distance_graph[start][end]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.total_distance = temp_distance</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 移动操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__move</span><span class="params">(self, next_city)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.path.append(next_city)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.open_table_city[next_city] = <span class="literal">False</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.total_distance += distance_graph[self.current_city][next_city]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.current_city = next_city</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.move_count += <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 搜索路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_path</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 初始化数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__clean_data()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 搜素路径，遍历完所有城市为止</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> self.move_count &lt; city_num:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 移动到下一个城市</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            next_city = self.__choice_next_city()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.__move(next_city)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 计算路径总长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__cal_total_distance()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># TSP问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TSP</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.ants = [Ant(ID) <span class="keyword">for</span> ID <span class="keyword">in</span> range(ant_num)]  <span class="comment"># 初始蚁群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.best_ant = Ant(<span class="number">-1</span>)  <span class="comment"># 初始最优解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.best_ant.total_distance = <span class="number">1</span> &lt;&lt; <span class="number">31</span>  <span class="comment"># 初始最大距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.iter = <span class="number">1</span>  <span class="comment"># 初始化迭代次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 初始城市之间的信息素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pheromone_graph[i][j] = <span class="number">1.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 计算城市之间的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                temp_distance = pow((location_x[i] - location_x[j]), <span class="number">2</span>) + pow((location_y[i] - location_y[j]), <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                temp_distance = pow(temp_distance, <span class="number">0.5</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                distance_graph[i][j] = float(int(temp_distance + <span class="number">0.5</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 更新信息素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__update_pheromone_gragh</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 获取每只蚂蚁在其路径上留下的信息素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp_pheromone = [[<span class="number">0.0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(city_num)] <span class="keyword">for</span> raw <span class="keyword">in</span> range(city_num)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> ant <span class="keyword">in</span> self.ants:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                start, end = ant.path[i - <span class="number">1</span>], ant.path[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment"># 在路径上的每两个相邻城市间留下信息素，与路径总距离反比</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                temp_pheromone[start][end] += Q / ant.total_distance</span></pre></td></tr><tr><td class="code"><pre><span class="line">                temp_pheromone[end][start] = temp_pheromone[start][end]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 更新所有城市之间的信息素，旧信息素衰减加上新迭代信息素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pheromone_graph[i][j] = pheromone_graph[i][j] * RHO + temp_pheromone[i][j]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 开始搜索</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_path</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> self.iter &lt; epochs:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 遍历每一只蚂蚁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> ant <span class="keyword">in</span> self.ants:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment"># 搜索一条路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                ant.search_path()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment"># 与当前最优蚂蚁比较</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> ant.total_distance &lt; self.best_ant.total_distance:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment"># 更新最优解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    self.best_ant = copy.deepcopy(ant)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 更新信息素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.__update_pheromone_gragh()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># print(u"迭代次数：", self.iter, u"最佳路径总距离：", int(self.best_ant.total_distance))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.iter += <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> self.best_ant.path, self.best_ant.total_distance</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'Start......'</span>, end=<span class="string">' '</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 获取最优个体（最优路径）、最优路径长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    best_solution, best_length = TSP().search_path()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'Finish.'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    best_path = best_solution + [best_solution[<span class="number">0</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 输出最优路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'The best path: '</span> + str(best_path[<span class="number">0</span>]), end=<span class="string">''</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(best_path)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">' -&gt;'</span>, str(best_path[i]), end=<span class="string">''</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 输出总路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'The total distance: '</span>, str(best_length))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 画出最优路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    X, Y = [], []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> best_path:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        X.append(location_x[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Y.append(location_y[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fig, ax = plt.subplots()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ax.plot(X, Y, marker=<span class="string">'o'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        txt = best_path[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ax.annotate(txt, (X[i], Y[i]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/python3.6 TSP_ACO.py</span></pre></td></tr><tr><td class="code"><pre><span class="line">TSP By ACO......</span></pre></td></tr><tr><td class="code"><pre><span class="line">The number of cities:  20</span></pre></td></tr><tr><td class="code"><pre><span class="line">Start...... Finish.</span></pre></td></tr><tr><td class="code"><pre><span class="line">The best path: 6 -&gt; 17 -&gt; 3 -&gt; 0 -&gt; 2 -&gt; 12 -&gt; 18 -&gt; 1 -&gt; 9 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 7 -&gt; 4 -&gt; 11 -&gt; 15 -&gt; 14 -&gt; 19 -&gt; 8 -&gt; 13 -&gt; 6</span></pre></td></tr><tr><td class="code"><pre><span class="line">The total distance:  2470.0</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Process finished with <span class="built_in">exit</span> code 0</span></pre></td></tr></table></figure>

<p><img src="/assets/blogimg/TSP_ACO.png" alt=""></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>免疫算法解决旅行商问题</title>
    <url>/2019/04/23/%E5%85%8D%E7%96%AB%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/旅行推销员问题" target="_blank" rel="noopener">什么是旅行商问题（TSP）？</a><a href="https://baike.baidu.com/item/免疫算法/11066860" target="_blank" rel="noopener">什么是免疫算法？</a></p>
<a id="more"></a>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>全局搜索能力</li>
<li>多样性保持机制</li>
<li>鲁棒性强</li>
<li>并行分布式搜索机制</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>免疫算法是受生物免疫系统的启发而推出的一种新型的智能搜索算法，是一种确定性和随机性选择相结合并具有”勘探”与”开采”能力的启发式随机搜索算法。下表是免疫算法与生物免疫系统概念的对应关系：</p>
<table>
<thead>
<tr>
<th align="center">生物免疫系统</th>
<th align="center">免疫算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">抗原</td>
<td align="center">优化问题</td>
</tr>
<tr>
<td align="center">抗体</td>
<td align="center">优化问题的可行解</td>
</tr>
<tr>
<td align="center">亲和度</td>
<td align="center">可行解的质量</td>
</tr>
<tr>
<td align="center">细胞活化</td>
<td align="center">免疫选择</td>
</tr>
<tr>
<td align="center">细胞分化</td>
<td align="center">个体克隆</td>
</tr>
<tr>
<td align="center">亲和度成熟</td>
<td align="center">变异</td>
</tr>
<tr>
<td align="center">克隆抑制</td>
<td align="center">克隆抑制</td>
</tr>
<tr>
<td align="center">动态维持平衡</td>
<td align="center">种群刷新</td>
</tr>
</tbody></table>
<h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="/assets/blogimg/TSP_IA_g.png" alt=""></p>
<h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TSP_IA: 免疫算法解决旅行商问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 设置参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">city_num = <span class="number">20</span>  <span class="comment"># 城市数目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">population_size = <span class="number">100</span>  <span class="comment"># 免疫个体数目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">epochs = <span class="number">500</span>  <span class="comment"># 最大免疫代数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">clone_number = <span class="number">10</span>  <span class="comment"># 克隆数目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'TSP By IA......'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The number of cities: '</span>, str(city_num))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The number of immune individuals: '</span>, str(population_size))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The number of immune generations: '</span>, str(epochs))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化变异个体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_population</span><span class="params">(city_num, population_size)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    individuals = np.zeros((city_num, population_size))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(population_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        individuals[:, i] = np.random.permutation(range(<span class="number">0</span>, city_num))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> individuals.astype(int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算城市两两间的距离矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_distance</span><span class="params">(city_size, cities_location)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dismat = np.zeros((city_size, city_size))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(city_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, city_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dismat[i][j] = dismat[j][i] = np.linalg.norm(cities_location[i] - cities_location[j])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> dismat</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算一个解的总距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_distance</span><span class="params">(path, distance)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    one_distance = distance[path[city_num - <span class="number">1</span>]][path[<span class="number">0</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(city_num - <span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        one_distance += distance[path[j]][path[j + <span class="number">1</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> one_distance</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化城市坐标：横纵坐标的取值范围都是0～10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cities_location = np.random.uniform(<span class="number">0</span>, <span class="number">10</span>, (city_num, <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算城市间的距离矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">distance = compute_distance(city_num, cities_location)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化免疫个体种群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">population = init_population(city_num, population_size)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算每个免疫个体的路径总长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">individual_lengths = np.zeros((population_size, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(population_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    individual_lengths[i] = get_all_distance(population[:, i], distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 根据路径总长度升序排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sorted_indexs = np.argsort(individual_lengths, axis=<span class="number">0</span>)  <span class="comment"># 升序排序索引</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sorted_population = np.zeros((city_num, population_size))  <span class="comment"># 升序排序的免疫种群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sorted_individual_lengths = np.zeros((population_size, <span class="number">1</span>))  <span class="comment"># 升序排序的免疫个体路径长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(population_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sorted_population[:, i] = population[:, sorted_indexs[i][<span class="number">0</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sorted_individual_lengths[i, <span class="number">0</span>] = individual_lengths[sorted_indexs[i][<span class="number">0</span>], <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 记录每一代的最短路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">record_min_length = np.zeros((epochs, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 开始迭代</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'Start......'</span>, end=<span class="string">' '</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> gen <span class="keyword">in</span> range(epochs):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 免疫种群（总种群的一半）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    half_of_all = np.zeros((city_num, int(population_size / <span class="number">2</span>)), dtype=int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    half_of_all_length = np.zeros((int(population_size / <span class="number">2</span>), <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(population_size / <span class="number">2</span>)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 选择操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        tile_i_th = np.tile(sorted_population[:, i], (clone_number, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clone_individuals = np.transpose(tile_i_th)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(clone_number):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p1, p2 = np.random.randint(<span class="number">0</span>, city_num, size=<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            clone_individuals[p1, j], clone_individuals[p2, j] = clone_individuals[p2, j], clone_individuals[p1, j]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clone_individuals[:, <span class="number">0</span>] = sorted_population[:, i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 克隆抑制</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        clone_individuals = clone_individuals.astype(int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        clone_individuals_lengths = np.zeros((clone_number, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(clone_number):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            clone_individuals_lengths[j, <span class="number">0</span>] = get_all_distance(clone_individuals[:, j], distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sorted_indexs = np.argsort(clone_individuals_lengths, axis=<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sorted_clone_individuals = np.zeros((city_num, clone_number))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sorted_clone_individuals_lengths = np.zeros((clone_number, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(clone_number):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sorted_clone_individuals[:, k] = clone_individuals[:, sorted_indexs[k][<span class="number">0</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sorted_clone_individuals_lengths[k, <span class="number">0</span>] = clone_individuals_lengths[sorted_indexs[k][<span class="number">0</span>], <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        half_of_all[:, i] = sorted_clone_individuals[:, <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        half_of_all_length[i, <span class="number">0</span>] = sorted_clone_individuals_lengths[<span class="number">0</span>, <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 种群刷新</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 初始化新种群（另一半）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    new_half_of_all = np.zeros((city_num, int(population_size / <span class="number">2</span>)), dtype=int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    new_half_of_all_length = np.zeros((int(population_size / <span class="number">2</span>), <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(population_size / <span class="number">2</span>)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        init_one = init_population(city_num, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        init_one.shape = city_num</span></pre></td></tr><tr><td class="code"><pre><span class="line">        new_half_of_all[:, i] = init_one</span></pre></td></tr><tr><td class="code"><pre><span class="line">        new_half_of_all_length[i, <span class="number">0</span>] = get_all_distance(new_half_of_all[:, i], distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 免疫种群和新种群合并</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    updated_population = np.append(half_of_all, new_half_of_all, axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    updated_population_length = np.append(half_of_all_length, new_half_of_all_length, axis=<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 根据总路径长度升序排序免疫种群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sorted_indexs = np.argsort(updated_population_length, axis=<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sorted_population = np.zeros((city_num, population_size))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sorted_individual_lengths = np.zeros((population_size, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(population_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sorted_population[:, i] = updated_population[:, sorted_indexs[i][<span class="number">0</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sorted_individual_lengths[i, <span class="number">0</span>] = updated_population_length[sorted_indexs[i][<span class="number">0</span>], <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 记录最小路径长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    record_min_length[gen, <span class="number">0</span>] = sorted_individual_lengths[<span class="number">0</span>, <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'Finish.'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 获取最优个体（最优路径）、最优路径长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">best_solution = list(map(int, sorted_population[:, <span class="number">0</span>].astype(int)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">best_path = best_solution + [best_solution[<span class="number">0</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">best_length = record_min_length[<span class="number">-1</span>, <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 输出最优路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The best path: '</span> + str(best_path[<span class="number">0</span>]), end=<span class="string">''</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(best_path)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">' -&gt;'</span>, str(best_path[i]), end=<span class="string">''</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 输出总路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The total distance: '</span>, str(best_length))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 画出最优路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">X, Y = [], []</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> best_path:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X.append(cities_location[i, <span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Y.append(cities_location[i, <span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span></pre></td></tr><tr><td class="code"><pre><span class="line">ax.plot(X, Y, marker=<span class="string">'o'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    txt = best_path[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ax.annotate(txt, (X[i], Y[i]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/python3.6 TSP_IA.py</span></pre></td></tr><tr><td class="code"><pre><span class="line">TSP By IA......</span></pre></td></tr><tr><td class="code"><pre><span class="line">The number of cities:  20</span></pre></td></tr><tr><td class="code"><pre><span class="line">The number of immune individuals:  100</span></pre></td></tr><tr><td class="code"><pre><span class="line">The number of immune generations:  500</span></pre></td></tr><tr><td class="code"><pre><span class="line">Start...... Finish.</span></pre></td></tr><tr><td class="code"><pre><span class="line">The best path: 9 -&gt; 13 -&gt; 1 -&gt; 18 -&gt; 2 -&gt; 15 -&gt; 8 -&gt; 5 -&gt; 12 -&gt; 0 -&gt; 11 -&gt; 7 -&gt; 19 -&gt; 6 -&gt; 10 -&gt; 16 -&gt; 3 -&gt; 4 -&gt; 17 -&gt; 14 -&gt; 9</span></pre></td></tr><tr><td class="code"><pre><span class="line">The total distance:  33.18839279827168</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Process finished with <span class="built_in">exit</span> code 0</span></pre></td></tr></table></figure>

<p><img src="/assets/blogimg/TSP_IA.png" alt=""></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法解决旅行商问题</title>
    <url>/2019/04/22/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://zh.wikipedia.org/wiki/旅行推销员问题" target="_blank" rel="noopener">什么是旅行商问题（TSP）？</a><a href="https://zh.wikipedia.org/wiki/遗传算法" target="_blank" rel="noopener">什么是遗传算法？</a></p>
<a id="more"></a>

<h3 id="实现过程中的注意点"><a href="#实现过程中的注意点" class="headerlink" title="实现过程中的注意点"></a>实现过程中的注意点</h3><ul>
<li><p>适应度计算</p>
<p>在遗传算法中，个体好坏用适应度来衡量，适应度越大说明该个体生存能力越强，也越接近最优解。而TSP问题需要总路径最小，故我们用总路径的倒数来表示个体的适应度。</p>
</li>
<li><p>获取更好的初始化种群</p>
<p>在初始化种群的过程中，对于随机生成的个体，我们随机交换其中的两个城市，如果交换后个体适应度有所提高（该解决方案下TSP路径变短），则更新该个体（发生交换）。</p>
</li>
<li><p>自然选择</p>
<p>自然选择是为了选择一些生存能力较强的个体作为交叉变异的父代，完成种群的繁衍工作。在这个过程中，我们先选取适应度最高的一部分个体作为父代。同时，为避免遗漏一些适应度较低但生存能力较强的个体，我们在剩余个体中，根据其存活率随机选取，并加入到已选择的父代中。</p>
</li>
<li><p>交叉操作</p>
<p>对于一般的编码，交叉操作很简单，按照正常思路做就可以，但是对于TSP问题，我们的个体是城市编号的序列，所以一个个体内部不能有重复编码，而一般的交叉、变异操作很容易导致编码重复。因此我们需要做一定调整：</p>
<ul>
<li>根据交叉点，获取两个父代交叉部分的编码</li>
<li>获取两个父代剩余部分编码</li>
<li>交叉部分编码完成交换</li>
<li>对剩余部分编码去重</li>
<li>从交叉部分编码的右边开始以此循环填充剩余部分编码</li>
</ul>
</li>
<li><p>变异操作</p>
<ul>
<li>依次选取三个点u、v、w，将[v, w]部分编码与[u, v]部分编码交换。</li>
</ul>
</li>
</ul>
<h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="/assets/blogimg/TSP_GA_g.png" alt=""></p>
<h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TSP_GA: 遗传算法解决旅行商问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 设置参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">city_num = <span class="number">20</span>  <span class="comment"># 城市个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">epochs = <span class="number">3000</span>  <span class="comment"># 迭代次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">population_size = <span class="number">300</span>  <span class="comment"># 种群大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">improve_cnt = <span class="number">1000</span>  <span class="comment"># 改良次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mutation_probability = <span class="number">0.1</span>  <span class="comment"># 变异概率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">retain_rate = <span class="number">0.3</span>  <span class="comment"># 高适应度个体的保留率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">survival_rate = <span class="number">0.5</span>  <span class="comment"># 低适应度个体的存活率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'TSP By GA......'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The number of cities: '</span>, str(city_num))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The size of population: '</span>, str(population_size))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The number of generations: '</span>, str(epochs))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 城市类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.x = x</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.y = y</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化城市</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_cities</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cities, x_cities, y_cities = [], [], []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x, y = random.uniform(<span class="number">0</span>, <span class="number">10</span>), random.uniform(<span class="number">0</span>, <span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cities.append(City(x, y))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x_cities.append(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y_cities.append(y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> cities</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_distance</span><span class="params">(cities)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    distance = np.zeros((len(cities), len(cities)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cities)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(cities)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> i != j:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                distance[i][j] = ((cities[i].x-cities[j].x)**<span class="number">2</span> + (cities[i].y-cities[j].y)**<span class="number">2</span>)**<span class="number">0.5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> distance</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化种群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_population</span><span class="params">(distance)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    population = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(population_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tmp = list(range(city_num))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        np.random.shuffle(tmp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 改良圈算法求的更好的初始化种群：随机交换两个城市序号，如果总距离减少则更新</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        one_distance = get_all_distance(tmp, distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt = improve_cnt  <span class="comment"># 改良次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(cnt):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            u = random.randint(<span class="number">0</span>, len(tmp) - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v = random.randint(<span class="number">0</span>, len(tmp) - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> u != v:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                new_tmp = tmp.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                new_tmp[u], new_tmp[v] = new_tmp[v], new_tmp[u]</span></pre></td></tr><tr><td class="code"><pre><span class="line">                new_distance = get_all_distance(new_tmp, distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> new_distance &lt; one_distance:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    one_distance = new_distance</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    tmp = new_tmp.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        population.append(tmp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> population</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算一个解的总距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_distance</span><span class="params">(path, distance)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    one_distance = distance[path[city_num - <span class="number">1</span>]][path[<span class="number">0</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(city_num - <span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        one_distance += distance[path[j]][path[j + <span class="number">1</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> one_distance</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算适应度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_fitness</span><span class="params">(population, distance)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    fitness = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> population:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        f = <span class="number">100</span> / get_all_distance(i, distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fitness.append(f)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> fitness</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 自然选择</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection</span><span class="params">(population, fitness)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    graded = [[fitness[x], population[x]] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(population))]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    graded = [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> sorted(graded, reverse=<span class="literal">True</span>)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    retain_length = int(retain_rate * len(graded))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    parents = graded[:retain_length]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> graded[retain_length:]:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> random.random() &lt; survival_rate:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            parents.append(i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> parents</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 交叉操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crossover</span><span class="params">(parents)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    children = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> len(children) &lt; population_size - len(parents):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mail_i = random.randint(<span class="number">0</span>, len(parents) - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        femail_i = random.randint(<span class="number">0</span>, len(parents) - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> mail_i != femail_i:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 交叉父代</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            mail = parents[mail_i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            femail = parents[femail_i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 交叉点位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            left = random.randint(<span class="number">0</span>, len(mail) - <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            right = random.randint(left + <span class="number">1</span>, len(mail) - <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 两染色体的交叉片段</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            gene1 = mail[left:right]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            gene2 = femail[left:right]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 两染色体未交叉片段</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            child1_c = mail[right:] + mail[:right]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child2_c = femail[right:] + femail[:right]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child1 = child1_c.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child2 = child2_c.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 去除重复</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> o <span class="keyword">in</span> gene2:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child1_c.remove(o)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> o <span class="keyword">in</span> gene1:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                child2_c.remove(o)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 完成交叉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            child1[left:right] = gene2</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child2[left:right] = gene1</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child1[right:] = child1_c[<span class="number">0</span>:len(child1) - right]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child1[:left] = child1_c[len(child1) - right:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child2[right:] = child2_c[<span class="number">0</span>:len(child1) - right]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            child2[:left] = child2_c[len(child1) - right:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 更新种群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            children.append(child1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children.append(child2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> children</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 变异操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutation</span><span class="params">(children)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(children)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> random.random() &lt;= mutation_probability:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            u = random.randint(<span class="number">1</span>, len(children[i]) - <span class="number">4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v = random.randint(u + <span class="number">1</span>, len(children[i]) - <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            w = random.randint(v + <span class="number">1</span>, len(children[i]) - <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children[i] = children[i][<span class="number">0</span>:u] + children[i][v:w] + children[i][u:v] + children[i][w:]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化：初始化城市、计算距离矩阵、初始化种群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cities = init_cities()</span></pre></td></tr><tr><td class="code"><pre><span class="line">distance = compute_distance(cities)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 1.初始化种群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">population = init_population(distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 遗传算法开始迭代</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">generation = <span class="number">1</span>  <span class="comment"># 当前代</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'Start......'</span>, end=<span class="string">' '</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> generation != epochs:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    generation += <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 2.计算适应度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    fitness = get_fitness(population, distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 3.自然选择</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    parents = selection(population, fitness)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 4.交叉操作:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    children = crossover(parents)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 5.变异操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mutation(children)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 6.更新种群</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    population = parents + children</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'Finish.'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 获取最优解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">best_one = np.argmax(fitness)</span></pre></td></tr><tr><td class="code"><pre><span class="line">best_solution = population[best_one]</span></pre></td></tr><tr><td class="code"><pre><span class="line">best_distance = get_all_distance(best_solution, distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 获取最优路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">best_path = best_solution + [best_solution[<span class="number">0</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 输出最优路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The best path: '</span> + str(best_path[<span class="number">0</span>]), end=<span class="string">''</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(best_path)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">' -&gt;'</span>, str(best_path[i]), end=<span class="string">''</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 输出总路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'The total distance: '</span>, str(best_distance))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 画出最优路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">X, Y = [], []</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> best_path:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X.append(cities[i].x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Y.append(cities[i].y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span></pre></td></tr><tr><td class="code"><pre><span class="line">ax.plot(X, Y, marker=<span class="string">'o'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(city_num):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    txt = best_path[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ax.annotate(txt, (X[i], Y[i]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/python3.6 TSP_GA.py</span></pre></td></tr><tr><td class="code"><pre><span class="line">TSP By GA......</span></pre></td></tr><tr><td class="code"><pre><span class="line">The number of cities:  20</span></pre></td></tr><tr><td class="code"><pre><span class="line">The size of population:  300</span></pre></td></tr><tr><td class="code"><pre><span class="line">The number of generations:  3000</span></pre></td></tr><tr><td class="code"><pre><span class="line">Start...... Finish.</span></pre></td></tr><tr><td class="code"><pre><span class="line">The best path: 19 -&gt; 5 -&gt; 15 -&gt; 1 -&gt; 6 -&gt; 13 -&gt; 8 -&gt; 12 -&gt; 0 -&gt; 17 -&gt; 2 -&gt; 10 -&gt; 9 -&gt; 3 -&gt; 11 -&gt; 4 -&gt; 16 -&gt; 14 -&gt; 18 -&gt; 7 -&gt; 19</span></pre></td></tr><tr><td class="code"><pre><span class="line">The total distance:  35.2732056886219</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Process finished with <span class="built_in">exit</span> code 0</span></pre></td></tr></table></figure>

<p><img src="/assets/blogimg/TSP_GA.png" alt=""></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯分类器</title>
    <url>/2019/04/03/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    <content><![CDATA[<p>朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。对于输入数据集，首先基于特征条件独立假设学习输入/输出的联合概率分布，然后基于此模型对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。</p>
<a id="more"></a>

<p>进一步学习：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_32690999/article/details/78737393" target="_blank" rel="noopener">朴素贝叶斯分类器（Naive Bayesian Classifier）</a></li>
<li><a href="https://www.zhihu.com/question/21134457" target="_blank" rel="noopener">你对贝叶斯统计都有怎样的理解？</a></li>
</ul>
<h3 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h3><ul>
<li>四种实现方式：自己实现、高斯贝叶斯模型、伯努利模型、多项式模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    iris = load_iris()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    df[<span class="string">'label'</span>] = iris.target</span></pre></td></tr><tr><td class="code"><pre><span class="line">    df.columns = [<span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data = np.array(df.iloc[:<span class="number">100</span>, :])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> data[:, :<span class="number">-1</span>], data[:, <span class="number">-1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 朴素贝叶斯分类器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaiveBayes</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.model = <span class="literal">None</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 数学期望</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mean</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> sum(X) / float(len(X))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 标准差</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stdev</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        avg = self.mean(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> math.sqrt(sum([pow(x-avg, <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> X]) / float(len(X)))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 高斯概率密度函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gaussian_probability</span><span class="params">(self, x, mean, stdev)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        exponent = math.exp(-(math.pow(x-mean, <span class="number">2</span>)/(<span class="number">2</span>*math.pow(stdev, <span class="number">2</span>))))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> / (math.sqrt(<span class="number">2</span>*math.pi) * stdev)) * exponent</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 处理X_train</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summarize</span><span class="params">(self, train_data)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        summaries = [(self.mean(i), self.stdev(i)) <span class="keyword">for</span> i <span class="keyword">in</span> zip(*train_data)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> summaries</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 分类别求出数学期望和标准差</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        labels = list(set(y))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        data = &#123;label: [] <span class="keyword">for</span> label <span class="keyword">in</span> labels&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> f, label <span class="keyword">in</span> zip(X, y):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            data[label].append(f)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.model = &#123;label: self.summarize(value) <span class="keyword">for</span> label, value <span class="keyword">in</span> data.items()&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">'GaussianNB train done!'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 计算概率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_probabilities</span><span class="params">(self, input_data)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># summaries:&#123;0.0: [(5.0, 0.37),(3.42, 0.40)], 1.0: [(5.8, 0.449),(2.7, 0.27)]&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># input_data:[1.1, 2.2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        probabilities = &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> label, value <span class="keyword">in</span> self.model.items():</span></pre></td></tr><tr><td class="code"><pre><span class="line">            probabilities[label] = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(value)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mean, stdev = value[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">                probabilities[label] *= self.gaussian_probability(input_data[i], mean, stdev)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> probabilities</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 预测类别</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X_test)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># &#123;0.0: 2.9680340789325763e-27, 1.0: 3.5749783019849535e-26&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        label = sorted(self.calculate_probabilities(X_test).items(), key=<span class="keyword">lambda</span> x: x[<span class="number">-1</span>])[<span class="number">-1</span>][<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> label</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 评价模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, X_test, y_test)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        right = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> zip(X_test, y_test):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            label = self.predict(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> label == y:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                right += <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> right / float(len(X_test))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 加载数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    X, y = load_data()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 自己实现NaiveBayes分类器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'My NaiveBayes'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    model = NaiveBayes()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    model.fit(X_train, y_train)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    one_example = [<span class="number">4.4</span>, <span class="number">3.2</span>, <span class="number">1.3</span>, <span class="number">0.2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'The label of [4.4, 3.2, 1.3, 0.2] is: '</span> + str(model.predict(one_example)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'Accuracy in test data set: '</span> + str(model.score(X_test, y_test)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># sklearn库中的NaiveBayes分类器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB  <span class="comment"># 高斯贝叶斯模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"Sklearn's GaussianNB"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clf = GaussianNB()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clf.fit(X_train, y_train)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'The label of [4.4, 3.2, 1.3, 0.2] is: '</span> + str(clf.predict([[<span class="number">4.4</span>, <span class="number">3.2</span>, <span class="number">1.3</span>, <span class="number">0.2</span>]])))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'Accuracy in test data set: '</span> + str(clf.score(X_test, y_test)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> BernoulliNB  <span class="comment"># 伯努利模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"Sklearn's BernoulliNB"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clf = BernoulliNB()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clf.fit(X_train, y_train)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'The label of [4.4, 3.2, 1.3, 0.2] is: '</span> + str(clf.predict([[<span class="number">4.4</span>, <span class="number">3.2</span>, <span class="number">1.3</span>, <span class="number">0.2</span>]])))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'Accuracy in test data set: '</span> + str(clf.score(X_test, y_test)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB  <span class="comment"># 多项式模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">"Sklearn's MultinomialNB"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clf = MultinomialNB()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clf.fit(X_train, y_train)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'The label of [4.4, 3.2, 1.3, 0.2] is: '</span> + str(clf.predict([[<span class="number">4.4</span>, <span class="number">3.2</span>, <span class="number">1.3</span>, <span class="number">0.2</span>]])))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'Accuracy in test data set: '</span> + str(clf.score(X_test, y_test)))</span></pre></td></tr></table></figure>

<ul>
<li>实验结果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">My NaiveBayes</span></pre></td></tr><tr><td class="code"><pre><span class="line">The label of [4.4, 3.2, 1.3, 0.2] is: 0.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Accuracy <span class="keyword">in</span> <span class="built_in">test</span> data <span class="built_in">set</span>: 1.0</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">GaussianNB <span class="keyword">in</span> sklearn</span></pre></td></tr><tr><td class="code"><pre><span class="line">The label of [4.4, 3.2, 1.3, 0.2] is: [0.]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Accuracy <span class="keyword">in</span> <span class="built_in">test</span> data <span class="built_in">set</span>: 1.0</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">BernoulliNB <span class="keyword">in</span> sklearn</span></pre></td></tr><tr><td class="code"><pre><span class="line">The label of [4.4, 3.2, 1.3, 0.2] is: [0.]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Accuracy <span class="keyword">in</span> <span class="built_in">test</span> data <span class="built_in">set</span>: 0.4666666666666667</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">MultinomialNB <span class="keyword">in</span> sklearn</span></pre></td></tr><tr><td class="code"><pre><span class="line">The label of [4.4, 3.2, 1.3, 0.2] is: [0.]</span></pre></td></tr><tr><td class="code"><pre><span class="line">Accuracy <span class="keyword">in</span> <span class="built_in">test</span> data <span class="built_in">set</span>: 1.0</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络手写数字识别</title>
    <url>/2019/04/01/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>卷积神经网络手写数字识别（基于TensorFlow），数据：MNIST库（手写体数字库），包含55000张训练图片，每张图片分辨率是28×28，故训练网络输入应该是28×28=784个像素数据。</p>
<a id="more"></a>

<p><img src="/assets/blogimg/MNIST.png" alt=""></p>
<ul>
<li><p>训练、保存、测试模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 MNIST 数据集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mnist = input_data.read_data_sets(<span class="string">'./MNIST_data/'</span>, one_hot=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.001</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_steps = <span class="number">5000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">batch_size = <span class="number">128</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">display_step = <span class="number">10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 神经网络网络参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_input = <span class="number">784</span>  <span class="comment"># MNIST 输入数据规格(img shape: 28*28)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_classes = <span class="number">10</span>  <span class="comment"># MNIST 类数(0-9 digits)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">dropout = <span class="number">0.75</span>  <span class="comment"># Dropout, 保留神经元的概率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># TensorFlow输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">X = tf.placeholder(tf.float32, [<span class="literal">None</span>, num_input])</span></pre></td></tr><tr><td class="code"><pre><span class="line">Y = tf.placeholder(tf.float32, [<span class="literal">None</span>, num_classes])</span></pre></td></tr><tr><td class="code"><pre><span class="line">keep_prob = tf.placeholder(tf.float32)  <span class="comment"># dropout (保留概率)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 卷积</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(x, W, b, strides=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = tf.nn.conv2d(x, W, strides=[<span class="number">1</span>, strides, strides, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = tf.nn.bias_add(x, b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> tf.nn.relu(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 池化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxpool2d</span><span class="params">(x, k=<span class="number">2</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(x, ksize=[<span class="number">1</span>, k, k, <span class="number">1</span>], strides=[<span class="number">1</span>, k, k, <span class="number">1</span>], padding=<span class="string">'SAME'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 创建卷积神经网络模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_net</span><span class="params">(x, weights, biases, dropout)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># MNIST data input is a 1-D vector of 784 features (28*28 pixels)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Reshape to match picture format [Height x Width x Channel]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Tensor input become 4-D: [Batch Size, Height, Width, Channel]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = tf.reshape(x, shape=[<span class="number">-1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 第一层卷积和池化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    conv1 = conv2d(x, weights[<span class="string">'wc1'</span>], biases[<span class="string">'bc1'</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    conv1 = maxpool2d(conv1, k=<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 第二层卷积和池化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    conv2 = conv2d(conv1, weights[<span class="string">'wc2'</span>], biases[<span class="string">'bc2'</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    conv2 = maxpool2d(conv2, k=<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 全连接层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Reshape conv2 output to fit fully connected layer input</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    fc1 = tf.reshape(conv2, [<span class="number">-1</span>, weights[<span class="string">'wd1'</span>].get_shape().as_list()[<span class="number">0</span>]])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fc1 = tf.add(tf.matmul(fc1, weights[<span class="string">'wd1'</span>]), biases[<span class="string">'bd1'</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fc1 = tf.nn.relu(fc1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fc1 = tf.nn.dropout(fc1, rate=<span class="number">1</span>-dropout)  <span class="comment"># Apply Dropout</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 输出层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = tf.add(tf.matmul(fc1, weights[<span class="string">'out'</span>]), biases[<span class="string">'out'</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 每层的 weight 和 bias</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">weights = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 5x5 conv, 1 input, 32 outputs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'wc1'</span>: tf.Variable(tf.random_normal([<span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">32</span>])),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 5x5 conv, 32 inputs, 64 outputs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'wc2'</span>: tf.Variable(tf.random_normal([<span class="number">5</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">64</span>])),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># fully connected, 7*7*64 inputs, 1024 outputs</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'wd1'</span>: tf.Variable(tf.random_normal([<span class="number">7</span>*<span class="number">7</span>*<span class="number">64</span>, <span class="number">1024</span>])),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 1024 inputs, 10 outputs (class prediction)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'out'</span>: tf.Variable(tf.random_normal([<span class="number">1024</span>, num_classes]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">biases = &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'bc1'</span>: tf.Variable(tf.random_normal([<span class="number">32</span>])),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'bc2'</span>: tf.Variable(tf.random_normal([<span class="number">64</span>])),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'bd1'</span>: tf.Variable(tf.random_normal([<span class="number">1024</span>])),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'out'</span>: tf.Variable(tf.random_normal([num_classes]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 建立模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">logits = conv_net(X, weights, biases, keep_prob)</span></pre></td></tr><tr><td class="code"><pre><span class="line">prediction = tf.nn.softmax(logits)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 损失函数与优化器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">loss_op = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=Y))</span></pre></td></tr><tr><td class="code"><pre><span class="line">optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate)</span></pre></td></tr><tr><td class="code"><pre><span class="line">train_op = optimizer.minimize(loss_op)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 评估模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">correct_pred = tf.equal(tf.argmax(prediction, <span class="number">1</span>), tf.argmax(Y, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_pred, tf.float32))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">init = tf.global_variables_initializer()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 定义saver: 保存模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">saver = tf.train.Saver()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sess.run(init)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">1</span>, num_steps+<span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            batch_x, batch_y = mnist.train.next_batch(batch_size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 反向传播优化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            sess.run(train_op, feed_dict=&#123;X: batch_x, Y: batch_y, keep_prob: dropout&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> step % display_step == <span class="number">0</span> <span class="keyword">or</span> step == <span class="number">1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment"># Calculate batch loss and accuracy</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                loss, acc = sess.run([loss_op, accuracy], feed_dict=&#123;X: batch_x, Y: batch_y, keep_prob: <span class="number">1.0</span>&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                print(<span class="string">"Step "</span> + str(step) + <span class="string">", Minibatch Loss= "</span> + <span class="string">"&#123;:.4f&#125;"</span>.format(loss) + <span class="string">", Training Accuracy= "</span> + <span class="string">"&#123;:.3f&#125;"</span>.format(acc))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        saver.save(sess, <span class="string">'CNN_handwritten_digits_model'</span>)  <span class="comment"># 储存模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"Optimization Finished!"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 计算测试精度(256 MNIST test images)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"Testing Accuracy:"</span>, sess.run(accuracy, feed_dict=&#123;X: mnist.test.images[:<span class="number">256</span>], Y: mnist.test.labels[:<span class="number">256</span>], keep_prob: <span class="number">1.0</span>&#125;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 图片预处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_prepare</span><span class="params">(picture)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    image = Image.open(picture)  <span class="comment"># 读取图片(28*28)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.imshow(image)  <span class="comment"># 显示需要识别的图片</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image = image.convert(<span class="string">'L'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image = image.resize((<span class="number">28</span>, <span class="number">28</span>), Image.ANTIALIAS)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image_data = list(image.getdata())</span></pre></td></tr><tr><td class="code"><pre><span class="line">    image_data = [<span class="number">0</span> <span class="keyword">if</span> x &lt; <span class="number">50</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> image_data]  <span class="comment"># 如果黑底白字</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># image_data = [1 if x &lt; 50 else 0 for x in image_data]  # 如果白底黑字</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># cnt = 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># for i in image_data:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#     print(i, end=' ')</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#     cnt += 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#     if cnt % 28 == 0:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#         print(end='\n')</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> image_data</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 待识别数字图片</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">image = image_prepare(<span class="string">'./digits/62.png'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># train_model()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 测试模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    saver = tf.train.import_meta_graph(<span class="string">'CNN_handwritten_digits_model.meta'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    saver.restore(sess, tf.train.latest_checkpoint(<span class="string">'./'</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    prediction = tf.argmax(prediction, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    predint = prediction.eval(feed_dict=&#123;X: [image], keep_prob: <span class="number">1.0</span>&#125;, session=sess)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'识别结果:'</span>, end=<span class="string">' '</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(predint[<span class="number">0</span>])</span></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建深度神经网络识别猫</title>
    <url>/2019/03/20/%E6%90%AD%E5%BB%BA%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E7%8C%AB/</url>
    <content><![CDATA[<p>搭建深度神经网络识别猫（Python手写）。</p>
<a id="more"></a>

<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> h5py</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_dataset = h5py.File(<span class="string">'datasets/train_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_set_x_orig = np.array(train_dataset[<span class="string">"train_set_x"</span>][:]) <span class="comment"># your train set features</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_set_y_orig = np.array(train_dataset[<span class="string">"train_set_y"</span>][:]) <span class="comment"># your train set labels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    test_dataset = h5py.File(<span class="string">'datasets/test_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    test_set_x_orig = np.array(test_dataset[<span class="string">"test_set_x"</span>][:]) <span class="comment"># your test set features</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    test_set_y_orig = np.array(test_dataset[<span class="string">"test_set_y"</span>][:]) <span class="comment"># your test set labels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    classes = np.array(test_dataset[<span class="string">"list_classes"</span>][:]) <span class="comment"># the list of classes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_set_y_orig = train_set_y_orig.reshape((<span class="number">1</span>, train_set_y_orig.shape[<span class="number">0</span>]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    test_set_y_orig = test_set_y_orig.reshape((<span class="number">1</span>, test_set_y_orig.shape[<span class="number">0</span>]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># S激活函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> / (<span class="number">1.</span>+np.exp(-z))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># RELU激活函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(Z)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    A = np.maximum(<span class="number">0</span>,Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Leaky RELU激活函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leaky_relu</span><span class="params">(Z)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    A = np.maximum(<span class="number">0</span>,Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    A[Z &lt; <span class="number">0</span>] = <span class="number">0.01</span> * Z</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 深度神经网络模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepNeuralNetwork</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, layers_dim, activations)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        np.random.seed(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.layers_dim = layers_dim</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__num_layers = len(layers_dim)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.activations = activations</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.input_size = layers_dim[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.parameters = self.__parameters_initializer(layers_dim)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.output_size = layers_dim[<span class="number">-1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 参数初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__parameters_initializer</span><span class="params">(self, layers_dim)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        L = len(layers_dim)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        parameters = &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, L):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            parameters[<span class="string">'W'</span>+str(l)] = np.random.randn(layers_dim[l], layers_dim[l<span class="number">-1</span>]) / np.sqrt(layers_dim[l<span class="number">-1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            parameters[<span class="string">'b'</span>+str(l)] = np.zeros((layers_dim[l], <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> parameters</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 前向传播中的一层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__one_layer_forward</span><span class="params">(self, A_prev, W, b, activation)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Z = np.dot(W, A_prev) + b</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> activation == <span class="string">'sigmoid'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A = sigmoid(Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> activation == <span class="string">'relu'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A = relu(Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> activation == <span class="string">'leaky_relu'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A = leaky_relu(Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> activation == <span class="string">'tanh'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A = np.tanh(Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cache = &#123;<span class="string">'Z'</span>: Z, <span class="string">'A'</span>: A&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> A, cache</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 前向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__forward_propagation</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        caches = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A_prev = X</span></pre></td></tr><tr><td class="code"><pre><span class="line">        caches.append(&#123;<span class="string">'A'</span>: A_prev&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, len(self.layers_dim)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            W, b = self.parameters[<span class="string">'W'</span>+str(l)], self.parameters[<span class="string">'b'</span>+str(l)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A_prev, cache = self.__one_layer_forward(A_prev, W, b, self.activations[l<span class="number">-1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            caches.append(cache)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AL = caches[<span class="number">-1</span>][<span class="string">'A'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> AL, caches</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 计算损失</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__compute_cost</span><span class="params">(self, AL, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        m = Y.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cost = -np.sum(Y*np.log(AL) + (<span class="number">1</span>-Y)*np.log(<span class="number">1</span>-AL)) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cost</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 损失函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cost_function</span><span class="params">(self, X, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span> (self.input_size == X.shape[<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AL, _ = self.__forward_propagation(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> self.__compute_cost(AL, Y)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># S激活函数反向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sigmoid_backward</span><span class="params">(self, dA, Z)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        s = sigmoid(Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dZ = dA * s*(<span class="number">1</span>-s)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dZ</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># RELU激活函数反向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">relu_backward</span><span class="params">(self, dA, Z)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        dZ = np.array(dA, copy=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dZ[Z &lt;= <span class="number">0</span>] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dZ</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Leaky RULE激活函数反向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leaky_relu_backward</span><span class="params">(self, dA, Z)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        dZ = np.array(dA, copy=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dZ[Z &lt;= <span class="number">0</span>] = <span class="number">0.01</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dZ</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># tanh激活函数反向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tanh_backward</span><span class="params">(self, dA, Z)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        s = np.tanh(Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dZ = <span class="number">1</span> - s*s</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dZ</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 线性激活函数反向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__linear_backward</span><span class="params">(self, dZ, A_prev, W)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        m = A_prev.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dW = np.dot(dZ, A_prev.T) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        db = np.sum(dZ, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dA_prev = np.dot(W.T, dZ)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dA_prev, dW, db</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 激活函数反向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__activation_backward</span><span class="params">(self, dA, Z, activation)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">assert</span> (dA.shape == Z.shape)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> activation == <span class="string">'sigmoid'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dZ = self.sigmoid_backward(dA, Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> activation == <span class="string">'relu'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dZ = self.relu_backward(dA, Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> activation == <span class="string">'leaky_relu'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dZ = self.leaky_relu_backward(dA, Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> activation == <span class="string">'tanh'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dZ = self.tanh_backward(dA, Z)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dZ</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 反向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__backward_propagation</span><span class="params">(self, caches, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        m = Y.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        L = self.__num_layers</span></pre></td></tr><tr><td class="code"><pre><span class="line">        grads = &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        AL, A_prev = caches[L<span class="number">-1</span>][<span class="string">'A'</span>], caches[L<span class="number">-2</span>][<span class="string">'A'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        grads[<span class="string">'dZ'</span>+str(L<span class="number">-1</span>)] = AL - Y</span></pre></td></tr><tr><td class="code"><pre><span class="line">        grads[<span class="string">'dA'</span>+str(L<span class="number">-2</span>)], grads[<span class="string">'dW'</span>+str(L<span class="number">-1</span>)], grads[<span class="string">'db'</span>+str(L<span class="number">-1</span>)] = self.__linear_backward(grads[<span class="string">'dZ'</span>+str(L<span class="number">-1</span>)], A_prev, self.parameters[<span class="string">'W'</span>+str(L<span class="number">-1</span>)])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> reversed(range(<span class="number">1</span>, L<span class="number">-1</span>)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            grads[<span class="string">'dZ'</span>+str(l)] = self.__activation_backward(grads[<span class="string">'dA'</span>+str(l)], caches[l][<span class="string">'Z'</span>], self.activations[l<span class="number">-1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A_prev = caches[l<span class="number">-1</span>][<span class="string">'A'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            grads[<span class="string">'dA'</span>+str(l<span class="number">-1</span>)], grads[<span class="string">'dW'</span>+str(l)], grads[<span class="string">'db'</span>+str(l)] = self.__linear_backward(grads[<span class="string">'dZ'</span>+str(l)], A_prev, self.parameters[<span class="string">'W'</span>+str(l)])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> grads</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 更新参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__update_parameters</span><span class="params">(self, grads, learning_rate)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, self.__num_layers):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.parameters[<span class="string">'W'</span>+str(l)] -= learning_rate * grads[<span class="string">'dW'</span>+str(l)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.parameters[<span class="string">'b'</span>+str(l)] -= learning_rate * grads[<span class="string">'db'</span>+str(l)]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 拟合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, Y, num_iterations, learning_rate, print_cost=False, print_num=<span class="number">100</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AL, caches = self.__forward_propagation(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cost = self.__compute_cost(AL, Y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            grads = self.__backward_propagation(caches, Y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.__update_parameters(grads, learning_rate)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> i % print_num == <span class="number">0</span> <span class="keyword">and</span> print_cost:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">print</span> (<span class="string">"Cost after iteration %i: %f"</span> %(i, cost))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> self</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 预测概率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict_prob</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        A, _ = self.__forward_propagation(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 预测分类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X, threshold=<span class="number">0.5</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred_prob = self.predict_prob(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        threshold_func = np.vectorize(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; threshold <span class="keyword">else</span> <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Y_prediction = threshold_func(pred_prob)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Y_prediction</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 精度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accuracy_score</span><span class="params">(self, X, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred = self.predict(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> len(Y[pred == Y]) / Y.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">train_x_orig, train_y, test_x_orig, test_y, classes = load_data()</span></pre></td></tr><tr><td class="code"><pre><span class="line">m_train = train_x_orig.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">num_px = train_x_orig.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">m_test = test_x_orig.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"Number of training examples: "</span> + str(m_train))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"Number of testing examples: "</span> + str(m_test))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"Each image is of size: ("</span> + str(num_px) + <span class="string">", "</span> + str(num_px) + <span class="string">", 3)"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"train_x_orig shape: "</span> + str(train_x_orig.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"train_y shape: "</span> + str(train_y.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"test_x_orig shape: "</span> + str(test_x_orig.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"test_y shape: "</span> + str(test_y.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 调整训练集与测试集数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_x_flatten = train_x_orig.reshape(train_x_orig.shape[<span class="number">0</span>], <span class="number">-1</span>).T</span></pre></td></tr><tr><td class="code"><pre><span class="line">test_x_flatten = test_x_orig.reshape(test_x_orig.shape[<span class="number">0</span>], <span class="number">-1</span>).T</span></pre></td></tr><tr><td class="code"><pre><span class="line">train_x = train_x_flatten/<span class="number">255.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">test_x = test_x_flatten/<span class="number">255.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"train_x's shape: "</span> + str(train_x.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"test_x's shape: "</span> + str(test_x.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 设置参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">layers_dims = (<span class="number">12288</span>, <span class="number">20</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">activations = [<span class="string">'relu'</span>, <span class="string">'relu'</span>, <span class="string">'relu'</span>,<span class="string">'sigmoid'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">num_iter = <span class="number">2500</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.0075</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 开始训练</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">clf = DeepNeuralNetwork(layers_dims, activations).fit(train_x, train_y, num_iter, learning_rate, <span class="literal">True</span>, <span class="number">100</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'train accuracy: &#123;:.2f&#125;%'</span>.format(clf.accuracy_score(train_x, train_y)*<span class="number">100</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'test accuracy: &#123;:.2f&#125;%'</span>.format(clf.accuracy_score(test_x, test_y)*<span class="number">100</span>))</span></pre></td></tr></table></figure>

<h3 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cost after iteration 0: 0.771749</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 100: 0.672053</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 200: 0.648263</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 300: 0.611507</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 400: 0.567047</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 500: 0.540138</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 600: 0.527930</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 700: 0.465477</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 800: 0.369126</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 900: 0.391747</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1000: 0.315187</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1100: 0.272700</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1200: 0.237419</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1300: 0.199601</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1400: 0.189263</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1500: 0.161189</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1600: 0.148214</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1700: 0.137775</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1800: 0.129740</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1900: 0.121225</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 2000: 0.113821</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 2100: 0.107839</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 2200: 0.102855</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 2300: 0.100897</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 2400: 0.092878</span></pre></td></tr><tr><td class="code"><pre><span class="line">train accuracy: 98.56%</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">test</span> accuracy: 80.00%</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建简单的神经网络</title>
    <url>/2019/03/20/%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>搭建简单的神经网络（Python手写）。</p>
<a id="more"></a>

<h3 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_planar_dataset</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    np.random.seed(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m = <span class="number">400</span>  <span class="comment"># number of examples</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    N = int(m/<span class="number">2</span>)  <span class="comment"># number of points per class</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    D = <span class="number">2</span>  <span class="comment"># dimensionality</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    X = np.zeros((m,D))  <span class="comment"># data matrix where each row is a single example</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Y = np.zeros((m,<span class="number">1</span>), dtype=<span class="string">'uint8'</span>)  <span class="comment"># labels vector (0 for red, 1 for blue)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = <span class="number">4</span>  <span class="comment"># maximum ray of the flower</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ix = range(N*j, N*(j+<span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        t = np.linspace(j*<span class="number">3.12</span>, (j+<span class="number">1</span>)*<span class="number">3.12</span>, N) + np.random.randn(N)*<span class="number">0.2</span> <span class="comment"># theta</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        r = a*np.sin(<span class="number">4</span>*t) + np.random.randn(N)*<span class="number">0.2</span>  <span class="comment"># radius</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        X[ix] = np.c_[r*np.sin(t), r*np.cos(t)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Y[ix] = j</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X = X.T</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Y = Y.T</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> X, Y</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># S函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> / (<span class="number">1.</span>+np.exp(-z))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 简单神经网络模型（一个隐含层）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleNeuralNetwork</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_layer_size)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.paramters = self.__parameter_initailizer(input_size, hidden_layer_size)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 参数初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__parameter_initailizer</span><span class="params">(self, n_x, n_h)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        W1, b1 = np.random.randn(n_h, n_x)*<span class="number">0.01</span>, np.zeros((n_h, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        W2, b2 = np.random.randn(<span class="number">1</span>, n_h)*<span class="number">0.01</span>, np.zeros((<span class="number">1</span>, <span class="number">1</span>))    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'W1'</span>: W1,<span class="string">'b1'</span>: b1,<span class="string">'W2'</span>: W2,<span class="string">'b2'</span>: b2&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 前向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__forward_propagation</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        W1, b1 = self.paramters[<span class="string">'W1'</span>], self.paramters[<span class="string">'b1'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        W2, b2 = self.paramters[<span class="string">'W2'</span>], self.paramters[<span class="string">'b2'</span>] </span></pre></td></tr><tr><td class="code"><pre><span class="line">        Z1 = np.dot(W1, X) + b1</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A1 = np.tanh(Z1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Z2 = np.dot(W2, A1) + b2</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A2 = sigmoid(Z2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cache = &#123;<span class="string">'X'</span>: X, <span class="string">'Z1'</span>: Z1,<span class="string">'A1'</span>: A1,<span class="string">'Z2'</span>: Z2,<span class="string">'A2'</span>: A2&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> A2, cache</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 计算损失</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__compute_cost</span><span class="params">(self, A2, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        m = A2.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cost = -np.sum(Y*np.log(A2) + (<span class="number">1</span>-Y)*np.log(<span class="number">1</span>-A2)) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cost</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 代价函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cost_function</span><span class="params">(self, X, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        A2, cache = self.__forward_propagation(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cost = self.__compute_cost(A2, Y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cost</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 反向传播计算梯度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__backward_propagation</span><span class="params">(self, cache, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        A1, A2 = cache[<span class="string">'A1'</span>], cache[<span class="string">'A2'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        W2 = self.paramters[<span class="string">'W2'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        X = cache[<span class="string">'X'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m = X.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dZ2 = A2 - Y</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dW2 = np.dot(dZ2, A1.T) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        db2 = np.sum(dZ2, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dZ1 = np.dot(W2.T, dZ2) * (<span class="number">1</span> - np.power(A1, <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dW1 = np.dot(dZ1, X.T) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        db1 = np.sum(dZ1, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        grads = &#123;<span class="string">'dW1'</span>: dW1,<span class="string">'db1'</span>: db1,<span class="string">'dW2'</span>: dW2,<span class="string">'db2'</span>: db2&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> grads</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 更新参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__update_parameters</span><span class="params">(self, grads, learning_rate)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.paramters[<span class="string">'W1'</span>] -= learning_rate * grads[<span class="string">'dW1'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.paramters[<span class="string">'b1'</span>] -= learning_rate * grads[<span class="string">'db1'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.paramters[<span class="string">'W2'</span>] -= learning_rate * grads[<span class="string">'dW2'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.paramters[<span class="string">'b2'</span>] -= learning_rate * grads[<span class="string">'db2'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 拟合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, Y, num_iterations, learning_rate, print_cost=False, print_num=<span class="number">100</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A2, cache = self.__forward_propagation(X)  <span class="comment"># 前行传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cost = self.cost_function(X, Y)  <span class="comment"># 计算代价</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            grads = self.__backward_propagation(cache, Y)  <span class="comment"># 后向传播计算梯度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.__update_parameters(grads, learning_rate)  <span class="comment"># 更新参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> i % print_num == <span class="number">0</span> <span class="keyword">and</span> print_cost:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">print</span> (<span class="string">"Cost after iteration %i: %f"</span> %(i, cost))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> self</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 预测结果的概率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict_prob</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        A2, _ = self.__forward_propagation(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> A2</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 预测结果（0 or 1）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X, threshold=<span class="number">0.5</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred_prob = self.predict_prob(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        threshold_func = np.vectorize(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; threshold <span class="keyword">else</span> <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Y_prediction = threshold_func(pred_prob)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Y_prediction</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 精度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accuracy_score</span><span class="params">(self, X, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred = self.predict(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> len(Y[pred == Y]) / Y.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">X, Y = load_planar_dataset()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 设置参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">num_iter = <span class="number">10001</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">1.2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">input_size = X.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">hidden_layer_size = <span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练神经网络模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">clf = SimpleNeuralNetwork(input_size=input_size, hidden_layer_size=hidden_layer_size).fit(X, Y, num_iter, learning_rate, <span class="literal">True</span>, <span class="number">1000</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">train_acc = clf.accuracy_score(X, Y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'training accuracy: &#123;&#125;%'</span>.format(train_acc*<span class="number">100</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 不同隐含层神经元个数下的实验结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> hidden_layer_size <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">50</span>]:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clf = SimpleNeuralNetwork(input_size=input_size, hidden_layer_size=hidden_layer_size).fit(X, Y, num_iter, learning_rate, <span class="literal">False</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'&#123;&#125; hidden units, cost: &#123;&#125;, accuracy: &#123;&#125;%'</span>.format(hidden_layer_size, clf.cost_function(X, Y), clf.accuracy_score(X, Y)))</span></pre></td></tr></table></figure>

<h3 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cost after iteration 0: 0.693162</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1000: 0.258625</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 2000: 0.239334</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 3000: 0.230802</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 4000: 0.225528</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 5000: 0.221845</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 6000: 0.219094</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 7000: 0.220620</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 8000: 0.219398</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 9000: 0.218482</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 10000: 0.217738</span></pre></td></tr><tr><td class="code"><pre><span class="line">training accuracy: 90.5%</span></pre></td></tr><tr><td class="code"><pre><span class="line">1 hidden units, cost: 0.6315586841940574, accuracy: 0.675%</span></pre></td></tr><tr><td class="code"><pre><span class="line">2 hidden units, cost: 0.5727605029758619, accuracy: 0.6725%</span></pre></td></tr><tr><td class="code"><pre><span class="line">3 hidden units, cost: 0.2521706044982674, accuracy: 0.91%</span></pre></td></tr><tr><td class="code"><pre><span class="line">4 hidden units, cost: 0.24709879496077952, accuracy: 0.9125%</span></pre></td></tr><tr><td class="code"><pre><span class="line">5 hidden units, cost: 0.2471140523262158, accuracy: 0.9125%</span></pre></td></tr><tr><td class="code"><pre><span class="line">20 hidden units, cost: 0.1580494894558535, accuracy: 0.9125%</span></pre></td></tr><tr><td class="code"><pre><span class="line">50 hidden units, cost: 0.16379020903733227, accuracy: 0.91%</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>词云</title>
    <url>/2019/03/19/%E8%AF%8D%E4%BA%91/</url>
    <content><![CDATA[<p>词云是一种数据呈现方式，本文用<strong>Python</strong>的<code>wordcloud</code>包实现。</p>
<a id="more"></a>

<ul>
<li><code>WordCloud()</code> 的可选参数：<ul>
<li>font_path:指定字体(otf和ttf)</li>
<li>width:词云宽度(默认400)</li>
<li>height:词云高度(默认200)</li>
<li>mask:蒙版(定制词云的形状)</li>
<li>min_font_size:最小字号(默认为4)</li>
<li>max_font_size:最大字号(默认为词云高度)</li>
<li>max_words:词的最大数量(默认200)</li>
<li>stopwords:将被忽略的停用词(若不指定则使用默认停用词词库)</li>
<li>background_color:背景颜色(默认为 black)</li>
<li>mode:默认为RGB模式(如果为RGBA模式且background_color设为None,则背景将透明)</li>
</ul>
</li>
<li>学习参考<ul>
<li><a href="http://amueller.github.io/word_cloud/index.html" target="_blank" rel="noopener">WordCloud 官方首页</a></li>
<li><a href="http://amueller.github.io/word_cloud/auto_examples/index.html" target="_blank" rel="noopener">WordCloud 官方示例</a></li>
<li><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba 中文分词</a></li>
</ul>
</li>
</ul>
<h3 id="英文词云"><a href="#英文词云" class="headerlink" title="英文词云"></a>英文词云</h3><ul>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">text = open(<span class="string">'EnglishText.txt'</span>).read()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 生成对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wc = WordCloud(font_path=<span class="string">'Hiragino.ttf'</span>, width=<span class="number">800</span>, height=<span class="number">600</span>, mode=<span class="string">'RGBA'</span>, background_color=<span class="literal">None</span>).generate(text)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示词云</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.imshow(wc, interpolation=<span class="string">'bilinear'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.axis(<span class="string">'off'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 保存到文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wc.to_file(<span class="string">'wordcloud.png'</span>)</span></pre></td></tr></table></figure>
</li>
<li><p>结果<br><img src="/assets/blogimg/wordcloud_1.png" alt=""></p>
</li>
</ul>
<h3 id="中文词云"><a href="#中文词云" class="headerlink" title="中文词云"></a>中文词云</h3><ul>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">text = open(<span class="string">'xyj.txt'</span>).read()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 中文分词</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">text = <span class="string">' '</span>.join(jieba.cut(text))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 生成对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wc = WordCloud(font_path=<span class="string">'Hiragino.ttf'</span>, width=<span class="number">800</span>, height=<span class="number">400</span>, mode=<span class="string">'RGBA'</span>, background_color=<span class="literal">None</span>).generate(text)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示词云</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.imshow(wc, interpolation=<span class="string">'bilinear'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.axis(<span class="string">'off'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 保存到文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wc.to_file(<span class="string">'wordcloud.png'</span>)</span></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p><img src="/assets/blogimg/wordcloud_2.png" alt=""></p>
</li>
</ul>
<h3 id="词云形状"><a href="#词云形状" class="headerlink" title="词云形状"></a>词云形状</h3><ul>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">text = open(<span class="string">'xyj.txt'</span>).read()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 中文分词</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">text = <span class="string">' '</span>.join(jieba.cut(text))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 生成对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mask = np.array(Image.open(<span class="string">'mask.png'</span>))  <span class="comment"># 设置词云形状</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wc = WordCloud(mask=mask, font_path=<span class="string">'Hiragino.ttf'</span>, width=<span class="number">800</span>, height=<span class="number">400</span>, mode=<span class="string">'RGBA'</span>, background_color=<span class="literal">None</span>).generate(text)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示词云</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.imshow(wc, interpolation=<span class="string">'bilinear'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.axis(<span class="string">'off'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 保存到文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wc.to_file(<span class="string">'wordcloud.png'</span>)</span></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<p><img src="/assets/blogimg/wordcloud_3.png" alt=""></p>
</li>
</ul>
<h3 id="词云颜色"><a href="#词云颜色" class="headerlink" title="词云颜色"></a>词云颜色</h3><ul>
<li><p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud, ImageColorGenerator</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">text = open(<span class="string">'xyj.txt'</span>).read()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 中文分词</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">text = <span class="string">' '</span>.join(jieba.cut(text))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 生成对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mask = np.array(Image.open(<span class="string">'mask.png'</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">wc = WordCloud(mask=mask, font_path=<span class="string">'Hiragino.ttf'</span>, width=<span class="number">800</span>, height=<span class="number">400</span>, mode=<span class="string">'RGBA'</span>, background_color=<span class="literal">None</span>).generate(text)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 从图片中抽取颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">image_colors = ImageColorGenerator(mask)</span></pre></td></tr><tr><td class="code"><pre><span class="line">wc.recolor(color_func=image_colors)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示词云</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.imshow(wc, interpolation=<span class="string">'bilinear'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.axis(<span class="string">'off'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 保存到文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">wc.to_file(<span class="string">'wordcloud.png'</span>)</span></pre></td></tr></table></figure>
</li>
<li><p>结果<br><img src="/assets/blogimg/wordcloud_4.png" alt=""></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归识别猫</title>
    <url>/2019/03/06/Logistic-Regression%E8%AF%86%E5%88%AB%E7%8C%AB/</url>
    <content><![CDATA[<p>逻辑回归是一个应用于监督学习、用于解决二分类（0 or 1）问题的机器学习算法，用于估计某种事物的可能性，其目的是最小化预测值与真实值的误差。</p>
<a id="more"></a>

<p>逻辑回归算法评估概率：𝐺𝑖𝑣𝑒𝑛 𝑥, 𝑦̂=𝑃(𝑦=1|𝑥), where 0≤𝑦̂≤1。</p>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li><p>输入的特征向量：𝑥 ∈ R𝑛𝑥，𝑛𝑥是特征数量</p>
</li>
<li><p>标签：𝑦 ∈ 0,1 </p>
</li>
<li><p>权值：𝑤 ∈ R𝑛𝑥, 𝑛𝑥是特征数量</p>
</li>
<li><p>阈值：𝑏 ∈ R </p>
</li>
<li><p>输出：𝑦̂ = 𝜎(𝑤𝑇𝑥 + 𝑏) </p>
</li>
<li><p>Sigmoid函数：s = 𝜎(𝑤𝑇𝑥 + 𝑏) = 𝜎(𝑧)= 1/(1+e^(-z))</p>
</li>
<li><p>Sigmoid函数图像：</p>
<p><img src="/assets/blogimg/sigmoid.png" alt=""></p>
</li>
</ul>
<h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><ul>
<li><p>损失函数：𝐿(𝑦̂(𝑖), 𝑦(𝑖)) = −( 𝑦(𝑖) log(𝑦̂(𝑖)) + (1 − 𝑦(𝑖))log(1 − 𝑦̂(𝑖))</p>
</li>
<li><p>代价函数：</p>
<p><img src="/assets/blogimg/costfunction.png" alt=""></p>
</li>
</ul>
<h3 id="识别猫案例"><a href="#识别猫案例" class="headerlink" title="识别猫案例"></a>识别猫案例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> h5py</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_dataset</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_dataset = h5py.File(<span class="string">'datasets/train_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_set_x_orig = np.array(train_dataset[<span class="string">"train_set_x"</span>][:])  <span class="comment"># train set features</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_set_y_orig = np.array(train_dataset[<span class="string">"train_set_y"</span>][:])  <span class="comment"># train set labels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    test_dataset = h5py.File(<span class="string">'datasets/test_catvnoncat.h5'</span>, <span class="string">"r"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    test_set_x_orig = np.array(test_dataset[<span class="string">"test_set_x"</span>][:])  <span class="comment"># test set features</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    test_set_y_orig = np.array(test_dataset[<span class="string">"test_set_y"</span>][:])  <span class="comment"># test set labels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    classes = np.array(test_dataset[<span class="string">"list_classes"</span>][:])  <span class="comment"># the list of classes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_set_y_orig = train_set_y_orig.reshape((<span class="number">1</span>, train_set_y_orig.shape[<span class="number">0</span>]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    test_set_y_orig = test_set_y_orig.reshape((<span class="number">1</span>, test_set_y_orig.shape[<span class="number">0</span>]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> train_set_x_orig, train_set_y_orig, test_set_x_orig, test_set_y_orig, classes</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># S函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> / (<span class="number">1.</span>+np.exp(-z))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 逻辑回归模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogisticRegression</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 参数初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__parameters_initializer</span><span class="params">(self, input_size)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        w = np.zeros((input_size, <span class="number">1</span>), dtype=float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        b = <span class="number">0.0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> w, b</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 前向传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__forward_propagation</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        A = sigmoid(np.dot(self.w.T, X) + self.b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 计算损失</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__compute_cost</span><span class="params">(self, A, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        m = A.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cost = -np.sum(Y*np.log(A) + (<span class="number">1</span>-Y)*(np.log(<span class="number">1</span>-A))) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cost</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 代价函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cost_function</span><span class="params">(self, X, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        A = self.__forward_propagation(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cost = self.__compute_cost(A, Y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cost</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 反向传播计算梯度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__backward_propagation</span><span class="params">(self, A, X, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        m = X.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dw = np.dot(X, (A-Y).T) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        db = np.sum(A-Y) / m</span></pre></td></tr><tr><td class="code"><pre><span class="line">        grads = &#123;<span class="string">"dw"</span>: dw, <span class="string">"db"</span>: db&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> grads</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 更新参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__update_parameters</span><span class="params">(self, grads, learning_rate)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.w -= learning_rate * grads[<span class="string">'dw'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.b -= learning_rate * grads[<span class="string">'db'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 拟合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, Y, num_iterations, learning_rate, print_cost=False, print_num=<span class="number">100</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.w, self.b = self.__parameters_initializer(X.shape[<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_iterations):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A = self.__forward_propagation(X)  <span class="comment"># 前行传播</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cost = self.__compute_cost(A, Y)  <span class="comment"># 计算代价</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            grads = self.__backward_propagation(A, X, Y)  <span class="comment"># 后向传播计算梯度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.__update_parameters(grads, learning_rate)  <span class="comment"># 更新参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> i % print_num == <span class="number">0</span> <span class="keyword">and</span> print_cost:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                print(<span class="string">"Cost after iteration &#123;&#125;: &#123;:.6f&#125;"</span>.format(i, cost))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> self</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 预测结果的概率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict_prob</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        A = self.__forward_propagation(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> A</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 预测结果（0 or 1）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X, threshold=<span class="number">0.5</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred_prob = self.predict_prob(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        threshold_func = np.vectorize(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; threshold <span class="keyword">else</span> <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Y_prediction = threshold_func(pred_prob)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Y_prediction</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 精度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accuracy_score</span><span class="params">(self, X, Y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pred = self.predict(X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> len(Y[pred == Y]) / Y.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据 (cat/non-cat)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset()</span></pre></td></tr><tr><td class="code"><pre><span class="line">m_train = train_set_x_orig.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">m_test = test_set_x_orig.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">num_px = train_set_x_orig.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"Number of training examples: m_train = "</span> + str(m_train))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"Number of testing examples: m_test = "</span> + str(m_test))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"Height/Width of each image: num_px = "</span> + str(num_px))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"Each image is of size: ("</span> + str(num_px) + <span class="string">", "</span> + str(num_px) + <span class="string">", 3)"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"train_set_x shape: "</span> + str(train_set_x_orig.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"train_set_y shape: "</span> + str(train_set_y.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"test_set_x shape: "</span> + str(test_set_x_orig.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"test_set_y shape: "</span> + str(test_set_y.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 调整训练集与测试集数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_set_x_flatten = train_set_x_orig.reshape(train_set_x_orig.shape[<span class="number">0</span>], <span class="number">-1</span>).T</span></pre></td></tr><tr><td class="code"><pre><span class="line">test_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[<span class="number">0</span>], <span class="number">-1</span>).T</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"train_set_x_flatten shape: "</span> + str(train_set_x_flatten.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"train_set_y shape: "</span> + str(train_set_y.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"test_set_x_flatten shape: "</span> + str(test_set_x_flatten.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"test_set_y shape: "</span> + str(test_set_y.shape))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"sanity check after reshaping: "</span> + str(train_set_x_flatten[<span class="number">0</span>:<span class="number">5</span>,<span class="number">0</span>]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">X_train = train_set_x_flatten/<span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">y_train = train_set_y</span></pre></td></tr><tr><td class="code"><pre><span class="line">X_test = test_set_x_flatten/<span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">y_test = test_set_y</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 开始训练</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">num_iter = <span class="number">2001</span>  <span class="comment"># 迭代次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.005</span>  <span class="comment"># 学习率</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">clf = LogisticRegression().fit(X_train, y_train, num_iter, learning_rate, <span class="literal">True</span>, <span class="number">500</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">train_acc = clf.accuracy_score(X_train, y_train)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'training acc: &#123;&#125;'</span>.format(train_acc))</span></pre></td></tr><tr><td class="code"><pre><span class="line">test_acc = clf.accuracy_score(X_test, y_test)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'testing acc: &#123;&#125;'</span>.format(test_acc))</span></pre></td></tr></table></figure>

<ul>
<li>输出结果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cost after iteration 0: 0.693147</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 500: 0.303273</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1000: 0.214820</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 1500: 0.166521</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cost after iteration 2000: 0.135608</span></pre></td></tr><tr><td class="code"><pre><span class="line">training acc: 0.9904306220095693</span></pre></td></tr><tr><td class="code"><pre><span class="line">testing acc: 0.7</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow-4 分类学习</title>
    <url>/2019/03/03/TensorFlow-4/</url>
    <content><![CDATA[<p>用TensorFlow实现手写数字分类。</p>
<a id="more"></a>

<h2 id="Classification-分类学习"><a href="#Classification-分类学习" class="headerlink" title="Classification 分类学习"></a>Classification 分类学习</h2><ul>
<li><p>数据：MNIST库（手写体数字库），包含55000张训练图片，每张图片分辨率是28×28，故训练网络输入应该是28×28=784个像素数据。</p>
<p><img src="/assets/blogimg/MNIST.png" alt=""></p>
</li>
<li><p>网络结构：输入数据784个特征，输出数据10个特征，激励采用softmax函数</p>
<p><img src="/assets/blogimg/MNIST_structure.png" alt=""></p>
</li>
<li><p>损失函数（最优化目标函数）：选用交叉熵函数，其用来衡量预测值和真实值的相似程度（若完全相同，它们的交叉熵等于零）。</p>
</li>
<li><p>最优化算法：梯度下降法</p>
</li>
</ul>
<h3 id="手写数字分类"><a href="#手写数字分类" class="headerlink" title="手写数字分类"></a>手写数字分类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TensorFlow: 分类学习</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个神经层函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(inputs, in_size, out_size, activation_function=None,)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Weights = tf.Variable(tf.random_normal([in_size, out_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    biases = tf.Variable(tf.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>,)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Wx_plus_b = tf.matmul(inputs, Weights) + biases</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="literal">None</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = Wx_plus_b</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = activation_function(Wx_plus_b,)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> outputs</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算精确度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_accuracy</span><span class="params">(v_xs, v_ys)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">global</span> prediction</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_pre = sess.run(prediction, feed_dict=&#123;xs: v_xs&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    correct_prediction = tf.equal(tf.argmax(y_pre, <span class="number">1</span>), tf.argmax(v_ys, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    result = sess.run(accuracy, feed_dict=&#123;xs: v_xs, ys: v_ys&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> result</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 导入手写体数字库MNIST</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mnist = input_data.read_data_sets(<span class="string">'./MNIST_data'</span>, one_hot=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 定义传入值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">xs = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">784</span>])  <span class="comment"># 28x28</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ys = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>])  <span class="comment"># 输出为数字0到9共10类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 添加层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">prediction = add_layer(xs, <span class="number">784</span>, <span class="number">10</span>,  activation_function=tf.nn.softmax)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 损失函数（最优化目标函数）：交叉熵函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cross_entropy = tf.reduce_mean(-tf.reduce_sum(ys * tf.log(prediction), reduction_indices=[<span class="number">1</span>]))  <span class="comment"># loss</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 梯度下降法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>).minimize(cross_entropy)</span></pre></td></tr><tr><td class="code"><pre><span class="line">sess = tf.Session()</span></pre></td></tr><tr><td class="code"><pre><span class="line">init = tf.global_variables_initializer()</span></pre></td></tr><tr><td class="code"><pre><span class="line">sess.run(init)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 开始训练</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 为提高训练速度，每次只取100张图片训练</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    batch_xs, batch_ys = mnist.train.next_batch(<span class="number">100</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sess.run(train_step, feed_dict=&#123;xs: batch_xs, ys: batch_ys&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 输出预测精确度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(compute_accuracy(mnist.test.images, mnist.test.labels))</span></pre></td></tr></table></figure>

<h3 id="分类结果"><a href="#分类结果" class="headerlink" title="分类结果"></a>分类结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0.0901</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.6524</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.7598</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.7997</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8143</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.833</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8446</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8528</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8544</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8559</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8624</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8636</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8656</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8691</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8693</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8664</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8727</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8768</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8797</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.8787</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow-3 神经网络可视化</title>
    <url>/2019/03/01/TensorFlow-3/</url>
    <content><![CDATA[<p>Tensorboard 神经网络结构可视化。Google Chrome 与 Tensorboard 兼容。</p>
<a id="more"></a>

<h3 id="可视化效果"><a href="#可视化效果" class="headerlink" title="可视化效果"></a>可视化效果</h3><p><img src="/assets/blogimg/tf-graph1.png" alt=""></p>
<h3 id="可视化步骤"><a href="#可视化步骤" class="headerlink" title="可视化步骤"></a>可视化步骤</h3><ul>
<li><p>用name参数为<code>x_in</code>指定名称为<code>x_in</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_in = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], name=<span class="string">'x_input'</span>)</span></pre></td></tr></table></figure>
</li>
<li><p>使用<code>with tf.name_scope(&#39;inputs&#39;)</code>可以将<code>x_in</code>和<code>y_in</code>包含进来，形成一个大的图层，图层的名字就是<code>with tf.name_scope()</code>方法里的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'inputs'</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x_in = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], name=<span class="string">'x_input'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_in = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], name=<span class="string">'y_input'</span>)</span></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>tf.summary.FileWriter()</code> 将绘出的图保存在目录<code>logs/</code>中， 该方法的第二个参数为<code>sess.graph</code> ， 因此要把本句放在获取<code>session</code>的后面。 <code>graph</code>是将前面定义的框架信息收集起来放在指定目录下面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sess = tf.Session()  <span class="comment"># 创建会话</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">writer = tf.summary.FileWriter(<span class="string">'logs/'</span>, sess.graph)  <span class="comment"># 用tf.summary.FileWriter()绘图并保存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sess.run(init)</span></pre></td></tr></table></figure>
</li>
<li><p>运行改python程序</p>
</li>
<li><p>在Terminal中切换到项目目录下，执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir logs</span></pre></td></tr></table></figure>
</li>
<li><p>在Google Chrome中打开Terminal中的网址即可查看。</p>
</li>
</ul>
<h2 id="Tensorboard-神经网络训练过程可视化"><a href="#Tensorboard-神经网络训练过程可视化" class="headerlink" title="Tensorboard 神经网络训练过程可视化"></a>Tensorboard 神经网络训练过程可视化</h2><ul>
<li><p>TensorFlow中提供了<code>tf.histogram_summary()</code>方法绘制图片，第一个参数是图表名称，第二个参数是图表要记录的变量。</p>
</li>
<li><p>loss在TesnorBorad的event下面，且我们使用<code>tf.summary.scalar()</code>得到<code>Loss</code> 变化图。</p>
</li>
<li><p><code>tf.merge_all_summaries()</code> 方法会对我们所有的 <code>summaries</code>合并到一起。</p>
</li>
<li><p>用<code>writer.add_summary()</code>记录训练的数据，merged 也需要run才能生效。</p>
</li>
<li><p>运行改python程序</p>
</li>
<li><p>在Terminal中切换到项目目录下，执行下面命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir logs</span></pre></td></tr></table></figure>
</li>
<li><p>在Google Chrome中打开Terminal中的网址即可查看。</p>
</li>
</ul>
<h2 id="完整可视化程序代码"><a href="#完整可视化程序代码" class="headerlink" title="完整可视化程序代码"></a>完整可视化程序代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TensorFlow: 神经网络可视化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个神经层函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(inputs, in_size, out_size, n_layer, activation_function=None)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    layer_name = <span class="string">'layer%s'</span> % n_layer</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">with</span> tf.name_scope(layer_name):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'weights'</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Weights = tf.Variable(tf.random_normal([in_size, out_size]), name=<span class="string">'W'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tf.summary.histogram(layer_name + <span class="string">'/weights'</span>, Weights)  <span class="comment"># 绘制图片</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'biases'</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            biases = tf.Variable(tf.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>, name=<span class="string">'b'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tf.summary.histogram(layer_name + <span class="string">'/biases'</span>, biases)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">with</span> tf.name_scope(<span class="string">'Wx_plus_b'</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Wx_plus_b = tf.matmul(inputs, Weights) + biases</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 激励函数为空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            outputs = Wx_plus_b</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            outputs = activation_function(Wx_plus_b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tf.summary.histogram(layer_name + <span class="string">'/outputs'</span>, outputs)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> outputs</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x_data = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">300</span>, dtype=np.float32)[:, np.newaxis]</span></pre></td></tr><tr><td class="code"><pre><span class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, x_data.shape).astype(np.float32)  <span class="comment"># 噪声</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">y_data = np.square(x_data) - <span class="number">0.5</span> + noise  <span class="comment"># 有噪声的一元二次函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'inputs'</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x_in = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], name=<span class="string">'x_input'</span>)  <span class="comment"># 用占位符定义神经网络的输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_in = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>], name=<span class="string">'y_input'</span>)  <span class="comment"># 用占位符定义神经网络的输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 搭建网络</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 隐藏层l1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">l1 = add_layer(x_in, <span class="number">1</span>, <span class="number">10</span>, n_layer=<span class="number">1</span>, activation_function=tf.nn.relu)  <span class="comment"># 用add_layer()定义隐藏层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 隐藏层l2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">prediction = add_layer(l1, <span class="number">10</span>, <span class="number">1</span>, n_layer=<span class="number">2</span>, activation_function=<span class="literal">None</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'loss'</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    loss = tf.reduce_mean(tf.reduce_sum(tf.square(y_in - prediction), reduction_indices=[<span class="number">1</span>]))  <span class="comment"># 计算误差</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tf.summary.scalar(<span class="string">'loss'</span>, loss)  <span class="comment"># 绘制图片</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">'train'</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_step = tf.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)  <span class="comment"># 训练以提升准确率，0.1为学习效率（通常小于1）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">init = tf.global_variables_initializer()  <span class="comment"># 初始化变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sess = tf.Session()  <span class="comment"># 创建会话</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">merged = tf.summary.merge_all()  <span class="comment"># 合并所有训练图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">writer = tf.summary.FileWriter(<span class="string">'logs/'</span>, sess.graph)  <span class="comment"># 用tf.summary.FileWriter()绘图并保存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sess.run(init)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 开始训练</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):  <span class="comment"># 让机器学习1000次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># train_step是学习的内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sess.run(train_step, feed_dict=&#123;x_in: x_data, y_in: y_data&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:  <span class="comment"># 每50步输出学习误差</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        rs = sess.run(merged, feed_dict=&#123;x_in: x_data, y_in: y_data&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        writer.add_summary(rs, i)  <span class="comment"># 记录</span></span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow-2 搭建第一个神经网络</title>
    <url>/2019/03/01/TensorFlow-2/</url>
    <content><![CDATA[<p>用TensorFlow搭建第一个神经网络。</p>
<a id="more"></a>

<h2 id="第一个神经网络"><a href="#第一个神经网络" class="headerlink" title="第一个神经网络"></a>第一个神经网络</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TensorFlow: 第一个神经网络</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">输入层（1个神经元）-&gt; 隐藏层（10个神经元）-&gt; 输出层（1个神经元）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 构建一个神经层函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(inputs, in_size, out_size, activation_function=None)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Weights = tf.Variable(tf.random_normal([in_size, out_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    biases = tf.Variable(tf.zeros([<span class="number">1</span>, out_size]) + <span class="number">0.1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Wx_plus_b = tf.matmul(inputs, Weights) + biases</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 激励函数为空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = Wx_plus_b</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        outputs = activation_function(Wx_plus_b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> outputs</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 导入数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x_data = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">300</span>, dtype=np.float32)[:, np.newaxis]</span></pre></td></tr><tr><td class="code"><pre><span class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, x_data.shape).astype(np.float32)  <span class="comment"># 噪声</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">y_data = np.square(x_data) - <span class="number">0.5</span> + noise  <span class="comment"># 有噪声的一元二次函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">xs = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>])  <span class="comment"># 用占位符定义神经网络的输入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ys = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">1</span>])  <span class="comment"># 用占位符定义神经网络的输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 搭建网络</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">l1 = add_layer(xs, <span class="number">1</span>, <span class="number">10</span>, activation_function=tf.nn.relu)  <span class="comment"># 用add_layer()定义隐藏层</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">prediction = add_layer(l1, <span class="number">10</span>, <span class="number">1</span>, activation_function=<span class="literal">None</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - prediction), reduction_indices=[<span class="number">1</span>]))  <span class="comment"># 计算误差</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.1</span>).minimize(loss)  <span class="comment"># 训练以提升准确率，0.1为学习效率（通常小于1）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">init = tf.global_variables_initializer()  <span class="comment"># 初始化变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sess = tf.Session()  <span class="comment"># 创建会话</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sess.run(init)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 真实数据可视化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fig = plt.figure()</span></pre></td></tr><tr><td class="code"><pre><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">ax.scatter(x_data, y_data)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.ion()  <span class="comment"># 显示图后不暂停</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()  <span class="comment"># 显示图后暂停</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 开始训练</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):  <span class="comment"># 让机器学习1000次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># train_step是学习的内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sess.run(train_step, feed_dict=&#123;xs: x_data, ys: y_data&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:  <span class="comment"># 每50步输出学习误差</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(sess.run(loss, feed_dict=&#123;xs: x_data, ys: y_data&#125;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ax.lines.remove(lines[<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">except</span> Exception:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        prediction_value = sess.run(prediction, feed_dict=&#123;xs: x_data&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 预测数据可视化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        lines = ax.plot(x_data, prediction_value, <span class="string">'r-'</span>, lw=<span class="number">5</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        plt.pause(<span class="number">0.1</span>)</span></pre></td></tr></table></figure>

<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0.120945826</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.009924126</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.008414253</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.007410705</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.006749772</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.006223758</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0058117723</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0055014477</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0052584694</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0050658723</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.004908645</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.004763277</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0046276315</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.004497925</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0043876884</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0042877905</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0041945437</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0041121077</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0040460215</span></pre></td></tr><tr><td class="code"><pre><span class="line">0.0039961385</span></pre></td></tr></table></figure>

<p>可以看出误差在逐渐减小，说明学习有效。</p>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><table>
<thead>
<tr>
<th align="center">原始数据</th>
<th align="center">预测数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/assets/blogimg/tf6-1.png" alt=""></td>
<td align="center"><img src="/assets/blogimg/tf6-2.png" alt=""></td>
</tr>
</tbody></table>
<h2 id="加速神经网络训练（Speed-Up-Training）"><a href="#加速神经网络训练（Speed-Up-Training）" class="headerlink" title="加速神经网络训练（Speed Up Training）"></a>加速神经网络训练（Speed Up Training）</h2><ul>
<li>Stochastic Gradient Descent (SGD)</li>
<li>Momentum</li>
<li>AdaGrad</li>
<li>RMSProp</li>
<li>Adam</li>
</ul>
<h3 id="Stochastic-Gradient-Descent-SGD"><a href="#Stochastic-Gradient-Descent-SGD" class="headerlink" title="Stochastic Gradient Descent (SGD)"></a>Stochastic Gradient Descent (SGD)</h3><ul>
<li>SGD：将庞大的Data拆分成很多小的data，然后分批次进行神经网络训练。</li>
</ul>
<h3 id="Momentum-更新方法"><a href="#Momentum-更新方法" class="headerlink" title="Momentum 更新方法"></a>Momentum 更新方法</h3><ul>
<li>大多数途径：<code>W += -Learning rate * dx</code>，即对原始W累加一个负的学习率乘以校正值。</li>
<li>Momentum：<code>m = b1 * m - Learning rate * dx</code>、<code>W += m</code>，即沿着坡度下降，路径不再那么曲折。</li>
</ul>
<h3 id="AdaGrad-更新方法"><a href="#AdaGrad-更新方法" class="headerlink" title="AdaGrad 更新方法"></a>AdaGrad 更新方法</h3><ul>
<li>AdaGrad：<code>v += dx^2</code>、<code>W += -Learning rate * dx / sqrt(v)</code>，立足于学习率的更新方法。</li>
</ul>
<h3 id="RMSProp-更新方法"><a href="#RMSProp-更新方法" class="headerlink" title="RMSProp 更新方法"></a>RMSProp 更新方法</h3><ul>
<li>RMSProp：<code>v = b1 * v + (1 - b1) * dx^2</code>、<code>W += -Learning rate * dx / sqrt(v)</code>，即基本涵盖了 Momentum和AdaGrad的优势。</li>
</ul>
<h3 id="Adam-更新方法"><a href="#Adam-更新方法" class="headerlink" title="Adam 更新方法"></a>Adam 更新方法</h3><ul>
<li><code>m = b1 * m + (1 - b1) * dx</code>：Momentum</li>
<li><code>v = b2 * v + (1 - b2) * dx^2</code>：AdaGrad</li>
<li><code>W += -Learning rate *m / sqrt(v)</code></li>
<li>Momentum+AdaGrad，有最好的加速效果。</li>
</ul>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><ul>
<li>TensorFlow 中有很多不同种类的优化器，最基本最常用的是<code>GradientDescentOptimizer</code>。</li>
<li>TensorFlow所有优化器：<a href="https://www.tensorflow.org/api_docs/python/tf/train" target="_blank" rel="noopener">TensorFlow Optimizer</a></li>
</ul>
]]></content>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow-1 基础架构</title>
    <url>/2019/02/28/TensorFlow-1/</url>
    <content><![CDATA[<p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a>是Google开发的一款神经网络的Python外部的结构包，也是一个采用数据流图来进行数值计算的开源软件库。TensorFlow让我们可以先绘制计算结构图，也可以称是一系列可人机交互的计算操作，然后把编辑好的Python文件转换成更高效的C++文件，并在后端进行计算。</p>
<a id="more"></a>

<h2 id="为什么要使用TensorFlow"><a href="#为什么要使用TensorFlow" class="headerlink" title="为什么要使用TensorFlow?"></a>为什么要使用TensorFlow?</h2><p>TensorFlow被认定为神经网络中最好用的库之一，它擅长的任务就是训练深度神经网络。通过使用TensorFlow我们就可以快速的入门神经网络，大大降低了深度学习（也就是深度神经网络）的开发成本和开发难度。最重要的是，TensorFlow完全开源。</p>
<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TensorFlow: 线性回归</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 创建数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x_data = np.random.rand(<span class="number">100</span>).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">y_data = x_data*<span class="number">2.0</span> + <span class="number">0.5</span>  <span class="comment"># 真实函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 搭建模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Weights = tf.Variable(tf.random_uniform([<span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">biases = tf.Variable(tf.zeros([<span class="number">1</span>]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">y = Weights*x_data + biases  <span class="comment"># 拟合函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算误差</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">loss = tf.reduce_mean(tf.square(y-y_data))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 误差传递（梯度下降法）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">train = optimizer.minimize(loss)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">init = tf.global_variables_initializer()</span></pre></td></tr><tr><td class="code"><pre><span class="line">sess = tf.Session()  <span class="comment"># 创建会话</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sess.run(init)  <span class="comment"># 必须步骤</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 输出训练结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">'step'</span>, <span class="string">'Weights'</span>, <span class="string">'biases'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">201</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sess.run(train)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(step, sess.run(Weights), sess.run(biases))</span></pre></td></tr></table></figure>

<h3 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">step Weights biases</span></pre></td></tr><tr><td class="code"><pre><span class="line">0 [0.24800181] [1.9143714]</span></pre></td></tr><tr><td class="code"><pre><span class="line">20 [1.5050483] [0.7566634]</span></pre></td></tr><tr><td class="code"><pre><span class="line">40 [1.87493] [0.5648566]</span></pre></td></tr><tr><td class="code"><pre><span class="line">60 [1.968396] [0.51638865]</span></pre></td></tr><tr><td class="code"><pre><span class="line">80 [1.9920139] [0.5041413]</span></pre></td></tr><tr><td class="code"><pre><span class="line">100 [1.997982] [0.5010464]</span></pre></td></tr><tr><td class="code"><pre><span class="line">120 [1.9994901] [0.5002644]</span></pre></td></tr><tr><td class="code"><pre><span class="line">140 [1.9998711] [0.5000668]</span></pre></td></tr><tr><td class="code"><pre><span class="line">160 [1.9999673] [0.5000169]</span></pre></td></tr><tr><td class="code"><pre><span class="line">180 [1.9999917] [0.50000435]</span></pre></td></tr><tr><td class="code"><pre><span class="line">200 [1.9999979] [0.5000011]</span></pre></td></tr></table></figure>

<p>最终得到的拟合模型<code>y=x*1.9999979+0.5000011</code>与真实函数<code>y_data = x_data*2.0 + 0.5</code>非常接近。</p>
<h2 id="Session会话控制"><a href="#Session会话控制" class="headerlink" title="Session会话控制"></a>Session会话控制</h2><p><code>Session</code> 是 Tensorflow 为了控制和输出的执行语句，运行 <code>session.run()</code> 可以获得你需要的运算结果。下面是<code>Session</code>的两种打开方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TensorFlow: Session会话控制</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">matrix1 = tf.constant([[<span class="number">3</span>, <span class="number">3</span>]])</span></pre></td></tr><tr><td class="code"><pre><span class="line">matrix2 = tf.constant([[<span class="number">2</span>],</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      [<span class="number">2</span>]])</span></pre></td></tr><tr><td class="code"><pre><span class="line">product = tf.matmul(matrix1, matrix2)  <span class="comment"># matrix multiply</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># method 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sess = tf.Session()</span></pre></td></tr><tr><td class="code"><pre><span class="line">result1 = sess.run(product)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(result1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">sess.close()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># method 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    result2 = sess.run(product)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(result1)</span></pre></td></tr></table></figure>

<h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[[12]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">[[12]]</span></pre></td></tr></table></figure>

<h2 id="Variable变量"><a href="#Variable变量" class="headerlink" title="Variable变量"></a>Variable变量</h2><p>在 TensorFlow 中，定义了某字符串是变量，它才是变量。<code>state = tf.Variable()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TensorFlow: Variable 变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">state = tf.Variable(<span class="number">0</span>, name=<span class="string">'counter'</span>)  <span class="comment"># define variable</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(state.name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">one = tf.constant(<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">new_value = tf.add(state, one)</span></pre></td></tr><tr><td class="code"><pre><span class="line">update = tf.assign(state, new_value)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">init = tf.global_variables_initializer()  <span class="comment"># must have initialize if define variables</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sess.run(init)  <span class="comment"># 激活init这一步骤</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sess.run(update)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(sess.run(state))</span></pre></td></tr></table></figure>

<h3 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">counter:0</span></pre></td></tr><tr><td class="code"><pre><span class="line">1</span></pre></td></tr><tr><td class="code"><pre><span class="line">2</span></pre></td></tr><tr><td class="code"><pre><span class="line">3</span></pre></td></tr></table></figure>

<h2 id="Placeholder传入值"><a href="#Placeholder传入值" class="headerlink" title="Placeholder传入值"></a>Placeholder传入值</h2><p><code>placeholder</code>是 TensorFlow 中的占位符，暂时储存变量。如果想要从外部传入data，那就需要用到 <code>tf.placeholder()</code>，把需要传入的值放在<code>feed_dict={}</code> 并一一对应每一个 <code>input</code>，然后以这种形式传输数据 <code>sess.run(***, feed_dict={input: **})</code>。因此，<code>placeholder</code> 与 <code>feed_dict={}</code> 是绑定在一起出现的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">TensorFlow: Placeholder传入值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># define type of placeholder in TensorFlow(often type is float32)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">input1 = tf.placeholder(tf.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">input2 = tf.placeholder(tf.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># tf.multiply do multiply between input1 and input2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ouput = tf.multiply(input1, input2)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(sess.run(ouput, feed_dict=&#123;input1: [<span class="number">7.</span>], input2: [<span class="number">2.</span>]&#125;))</span></pre></td></tr></table></figure>

<h3 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[14.]</span></pre></td></tr></table></figure>

<h2 id="Activation-Function激励函数"><a href="#Activation-Function激励函数" class="headerlink" title="Activation Function激励函数"></a>Activation Function激励函数</h2><ul>
<li>激励函数是为了解决不能用线性方程（linear function）概括的问题，把整个神经网络简化成式子：<code>y = Wx</code>（W是需要求解的参数，y是预测值，x是输入值）即可解决。</li>
<li>激励函数必须是可微分的，因为在 backpropagation 误差反向传递的时候，只有这些可微分的激励函数才能把误差传递回去。</li>
<li>在卷积神经网络 Convolutional neural networks 的卷积层中，推荐的激励函数是 relu。在循环神经网络中 recurrent neural networks，推荐的是 tanh 或者是 relu 。</li>
<li>激励函数运行时激活神经网络中某一部分神经元，将激活信息向后传入下一层的神经系统。</li>
<li>激励函数的实质是非线性方程。 Tensorflow 里面处理较为复杂的问题时都会需要运用激励函数 <code>activation function</code>。</li>
</ul>
<h3 id="Activation-Functions-in-TensorFlow"><a href="#Activation-Functions-in-TensorFlow" class="headerlink" title="Activation Functions in TensorFlow"></a>Activation Functions in TensorFlow</h3><p>The activation ops provide different types of nonlinearities for use in neural networks. These include smooth nonlinearities (<code>sigmoid</code>, <code>tanh</code>, <code>elu</code>, <code>selu</code>, <code>softplus</code>, and <code>softsign</code>), continuous but not everywhere differentiable functions (<code>relu</code>, <code>relu6</code>, <code>crelu</code> and <code>relu_x</code>), and random regularization (<code>dropout</code>).</p>
<p>All activation ops apply componentwise, and produce a tensor of the same shape as the input tensor.</p>
<ul>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/relu" target="_blank" rel="noopener"><code>tf.nn.relu</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/relu6" target="_blank" rel="noopener"><code>tf.nn.relu6</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/crelu" target="_blank" rel="noopener"><code>tf.nn.crelu</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/elu" target="_blank" rel="noopener"><code>tf.nn.elu</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/selu" target="_blank" rel="noopener"><code>tf.nn.selu</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/math/softplus" target="_blank" rel="noopener"><code>tf.nn.softplus</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/softsign" target="_blank" rel="noopener"><code>tf.nn.softsign</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/dropout" target="_blank" rel="noopener"><code>tf.nn.dropout</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/bias_add" target="_blank" rel="noopener"><code>tf.nn.bias_add</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/sigmoid" target="_blank" rel="noopener"><code>tf.sigmoid</code></a></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/nn/tanh" target="_blank" rel="noopener"><code>tf.tanh</code></a></li>
</ul>
<h2 id="Dropout-解决-overfitting"><a href="#Dropout-解决-overfitting" class="headerlink" title="Dropout 解决 overfitting"></a>Dropout 解决 overfitting</h2><ul>
<li>Overfitting 也被称为过度学习，过度拟合。</li>
<li>简单说就是对训练数据拟合效果特别好，但是对测试数据预测能力很差。</li>
<li>TensorFlow提供了强大的dropout方法来解决overfitting问题。</li>
<li>保留概率<code>keep_prob</code>是我们要保留结果所占比例，作为一个<code>placeholder</code>，在<code>run</code>时传入。当<code>keep_prob=1</code>的时候，相当于100%保留，也就是dropout没有起作用。</li>
</ul>
]]></content>
      <tags>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>感知机解决二分类问题</title>
    <url>/2019/02/20/%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%A7%A3%E5%86%B3%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>机器学习之感知机。</p>
<a id="more"></a>

<h3 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h3><p>感知机(perceptron)是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取+1和-1二值。感知机对应于输入空间(特征空间)中将实例划分为正负两类的分离超平面，属于判别模型。感知机学习旨在求出将训练数据进行线性划分的分离超平面，为此，导入基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型。感知机学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。感知机预测是用学习得到的感知机模型对新的输入实例进行分类。感知机1957年由Rosenblatt提出，是神经网络与支持向量机的基础。</p>
<h3 id="感知机的二分类模型"><a href="#感知机的二分类模型" class="headerlink" title="感知机的二分类模型"></a>感知机的二分类模型</h3><ul>
<li>输入空间：X∈Rn，表示实例的特征向量</li>
<li>输出空间Y={+1, -1}，实例的类别</li>
<li>感知机：f(x)=sign(w·x+b)，w和b为感知机模型参数，w∈Rn表示权值向量，b∈R表示偏置</li>
<li>符号函数sign：x≥0时sign(x)=+1，x≤0时sign(x)=-1</li>
<li>超平面：线性方程w·x+b对应于特征空间中的一个超平面，将特征空间划分为两部分以完成分类。</li>
<li>损失函数：L(w,b)=-∑yi(w·xi+b)</li>
</ul>
<h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">感知机解决二分类问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 感知机模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 二分类数据线性可分（一元一次线性方程）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.w = np.ones(len(data[<span class="number">0</span>]) - <span class="number">1</span>, dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.b = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.l_rate = <span class="number">0.1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 符号函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(self, x, w, b)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        y = np.dot(x, w) + b</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> y</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 随机梯度下降法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X_train, y_train)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        is_wrong = <span class="literal">False</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> is_wrong:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wrong_count = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> range(len(X_train)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                X = X_train[d]</span></pre></td></tr><tr><td class="code"><pre><span class="line">                y = y_train[d]</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> y * self.sign(X, self.w, self.b) &lt;= <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    self.w = self.w + self.l_rate * np.dot(y, X)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    self.b = self.b + self.l_rate * y</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    wrong_count += <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> wrong_count == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                is_wrong = <span class="literal">True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">'Perceptron Model!'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 手动实现的感知机模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyByMe</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 用感知机模型进行分类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    perceptron = Model()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    perceptron.fit(X, y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 画出散点图及分类结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x_points = np.linspace(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_ = -(perceptron.w[<span class="number">0</span>] * x_points + perceptron.b) / perceptron.w[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(x_points, y_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(data[:<span class="number">50</span>, <span class="number">0</span>], data[:<span class="number">50</span>, <span class="number">1</span>], <span class="string">'bo'</span>, color=<span class="string">'blue'</span>, label=<span class="string">'0'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">0</span>], data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">1</span>], <span class="string">'bo'</span>, color=<span class="string">'orange'</span>, label=<span class="string">'1'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.xlabel(<span class="string">'sepal length'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.ylabel(<span class="string">'sepal width'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.legend()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 使用scikit库里面的感知机模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyByScikit</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Perceptron</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 用感知机模型进行分类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    clf = Perceptron(fit_intercept=<span class="literal">False</span>, max_iter=<span class="number">1000</span>, shuffle=<span class="literal">False</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    clf.fit(X, y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(clf.coef_)  <span class="comment"># 权值向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(clf.intercept_)  <span class="comment"># 截距</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 画出散点图及分类结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x_ponits = np.arange(<span class="number">4</span>, <span class="number">8</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_ = -(clf.coef_[<span class="number">0</span>][<span class="number">0</span>] * x_ponits + clf.intercept_) / clf.coef_[<span class="number">0</span>][<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(x_ponits, y_)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(data[:<span class="number">50</span>, <span class="number">0</span>], data[:<span class="number">50</span>, <span class="number">1</span>], <span class="string">'bo'</span>, color=<span class="string">'blue'</span>, label=<span class="string">'0'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">0</span>], data[<span class="number">50</span>:<span class="number">100</span>, <span class="number">1</span>], <span class="string">'bo'</span>, color=<span class="string">'orange'</span>, label=<span class="string">'1'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.xlabel(<span class="string">'sepal length'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.ylabel(<span class="string">'sepal width'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.legend()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 加载iris数据集中两个分类的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 并以[sepal length，sepal width]作为特征</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    iris = load_iris()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    df = pd.DataFrame(iris.data, columns=iris.feature_names)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    df[<span class="string">'label'</span>] = iris.target</span></pre></td></tr><tr><td class="code"><pre><span class="line">    df.columns = [<span class="string">'sepal length'</span>, <span class="string">'sepal width'</span>, <span class="string">'petal length'</span>, <span class="string">'petal width'</span>, <span class="string">'label'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    df.label.value_counts()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 画出散点图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.scatter(df[:<span class="number">50</span>][<span class="string">'sepal length'</span>], df[:<span class="number">50</span>][<span class="string">'sepal width'</span>], label=<span class="string">'0'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.scatter(df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal length'</span>], df[<span class="number">50</span>:<span class="number">100</span>][<span class="string">'sepal width'</span>], label=<span class="string">'1'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.xlabel(<span class="string">'sepal length'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.ylabel(<span class="string">'sepal width'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.legend()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 为感知机模型处理数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    data = np.array(df.iloc[:<span class="number">100</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>]])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X, y = data[:, : <span class="number">-1</span>], data[:, <span class="number">-1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y = np.array([<span class="number">1</span> <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> y])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 感知机模型完成分类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># classifyByMe()  # 手动实现的感知机模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    classifyByScikit()  <span class="comment"># 使用scikit库里面的感知机模型</span></span></pre></td></tr></table></figure>

<h3 id="分类结果"><a href="#分类结果" class="headerlink" title="分类结果"></a>分类结果</h3><table>
<thead>
<tr>
<th align="center">初始数据</th>
<th align="center">分类结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/assets/blogimg/Perceptron-1.png" alt=""></td>
<td align="center"><img src="/assets/blogimg/Perceptron-2.png" alt=""></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘法拟合曲线</title>
    <url>/2019/02/01/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E6%8B%9F%E5%90%88%E6%9B%B2%E7%BA%BF/</url>
    <content><![CDATA[<p>机器学习相关：最小二乘法拟合曲线。</p>
<a id="more"></a>

<h3 id="使用最小二乘法拟和曲线"><a href="#使用最小二乘法拟和曲线" class="headerlink" title="使用最小二乘法拟和曲线"></a>使用最小二乘法拟和曲线</h3><ul>
<li><p><strong>高斯</strong>于1823年在误差e1 ,… , en独立同分布的假定下,证明了最小二乘方法的一个最优性质: <strong>在所有无偏的线性估计类中,最小二乘方法的方差最小！</strong></p>
</li>
<li><p>对于数据(xi, yi) (i = 1, 2, 3…, m)，拟合出函数​h(x)有误差，即残差：ri = h(xi) - yi，此时L2范数(残差平方和)最小时， h(x) 和 y 相似度最高，更拟合。</p>
</li>
<li><p>一般的H(x)为n次的多项式，H(x) = w0 + w1x + w2x^2 + … wnx^n​， w(w0, w1, w2, … , wn)为参数。最小二乘法就是要找到一组 w(w0, w1, w2, … , wn)使得sum((h(xi)-yi)^2​) (残差平方和) 最小，即求min(sum((h(xi)-yi)^2))</p>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>目标函数 y = sin2pix​, 加上一个正太分布的噪音干扰，用多项式去拟合</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> leastsq</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 目标函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">real_func</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> np.sin(<span class="number">2</span>*np.pi*x)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 生成多项式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_func</span><span class="params">(p, x)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    f = np.poly1d(p)  <span class="comment"># numpy.poly1d([1,2,3])  生成  1x^2+2x^1+3x^0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> f(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算残差</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">residuals_func</span><span class="params">(p, x, y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ret = fit_func(p, x) - y</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ret</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 拟合曲线：M为多项式的次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitting</span><span class="params">(M=<span class="number">0</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 拟合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p_init = np.random.rand(M + <span class="number">1</span>)  <span class="comment"># 随机初始化多项式参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p_lsq = leastsq(residuals_func, p_init, args=(x, y))  <span class="comment"># 最小二乘法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'Fitting Parameters:'</span>, p_lsq[<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 可视化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(x_points, real_func(x_points), label=<span class="string">'real'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(x_points, fit_func(p_lsq[<span class="number">0</span>], x_points), label=<span class="string">'fitted curve'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(x, y, <span class="string">'bo'</span>, label=<span class="string">'noise'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.legend()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> p_lsq</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x_points = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 正态分布噪音的目标函数的值y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_ = real_func(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y = [np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>) + y1 <span class="keyword">for</span> y1 <span class="keyword">in</span> y_]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 0次拟合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p_lsq_0 = fitting(M=<span class="number">0</span>)</span></pre></td></tr></table></figure>

<ul>
<li>拟合结果</li>
</ul>
<p>0次拟合：[0.00461176]</p>
<p>1次拟合：[-1.36961924  0.66545983]</p>
<p>3次拟合：[21.63282404 -31.80863265  10.24969763   0.08377312]</p>
<p>9次拟合：[-1.28594657e+04  5.80684524e+04 -1.09218448e+05  1.10695847e+05  -6.53112529e+04  2.26030006e+04 -4.36787154e+03  3.94053281e+02 -4.24850439e+00 -1.42083411e-01]</p>
<table>
<thead>
<tr>
<th align="center">拟合次数</th>
<th align="center">图示</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/assets/blogimg/p_lsq_0.png" alt="">0次拟合</td>
<td align="center"><img src="/assets/blogimg/p_lsq_1.png" alt="">1次拟合</td>
</tr>
<tr>
<td align="center"><img src="/assets/blogimg/p_lsq_3.png" alt="">3次拟合</td>
<td align="center"><img src="/assets/blogimg/p_lsq_9.png" alt="">9次拟合</td>
</tr>
</tbody></table>
<p>当M=9时，多项式曲线通过了每个数据点，但是造成了过拟合。</p>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>结果显示过拟合，我们引入正则化项(regularizer)，降低过拟合。<img src="/assets/blogimg/regularizer.png" alt=""></p>
<p>回归问题中，损失函数是平方损失，正则化可以是参数向量的L2范数,也可以是L1范数。</p>
<ul>
<li>L1: regularization*abs(p)</li>
<li>L2: 0.5 * regularization * np.square(p)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正则函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">regularization = <span class="number">0.0001</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">residuals_func_regularization</span><span class="params">(p, x, y)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ret = fit_func(p, x) - y</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ret = np.append(ret, np.sqrt(<span class="number">0.5</span>*regularization*np.square(p))) <span class="comment"># L2范数作为正则化项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ret</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x_points = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1000</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 正态分布噪音的目标函数的值y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_ = real_func(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y = [np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>) + y1 <span class="keyword">for</span> y1 <span class="keyword">in</span> y_]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 最小二乘法, 加正则化项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p_init = np.random.rand(<span class="number">9</span> + <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p_lsq_regularization = leastsq(residuals_func_regularization, p_init, args=(x, y))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(x_points, real_func(x_points), label=<span class="string">'real'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(x_points, fit_func(p_lsq_9[<span class="number">0</span>], x_points), label=<span class="string">'fitted curve'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(x_points, fit_func(p_lsq_regularization[<span class="number">0</span>], x_points), label=<span class="string">'regularization'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.plot(x, y, <span class="string">'bo'</span>, label=<span class="string">'noise'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.legend()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr></table></figure>

<p>带有正则化的9次拟合：<img src="/assets/blogimg/p_lsq_9_r.png" alt=""></p>
<p>可见，绿色曲线在避免过拟合的影响下，能够最好的完成拟合。</p>
]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>探索.ipynb</title>
    <url>/2019/01/21/%E6%8E%A2%E7%B4%A2-ipynb/</url>
    <content><![CDATA[<p><code>.ipynb</code>全称叫<code>ipython notebook</code>，在浏览器下打开，可以在线编辑、在线运行。</p>
<a id="more"></a>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li><p>需要安装jupyter库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip3 install jupyter</span></pre></td></tr></table></figure>
</li>
<li><p>Jupyter Notebook是一个Web应用程序，便于创建和共享程序文档，支持实时代码，数学方程，可视化和markdown。用途包括：数据清理和转换，数值模拟，统计建模，机器学习等。</p>
</li>
</ul>
<h2 id="如何运行-ipynb文件"><a href="#如何运行-ipynb文件" class="headerlink" title="如何运行.ipynb文件"></a>如何运行.ipynb文件</h2><ul>
<li><p><code>jupyter notebook</code>在浏览器启动<code>Jupyter</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span></pre></td></tr></table></figure>
</li>
<li><p>自动打开浏览器页面</p>
<p><img src="/assets/blogimg/Jupyter_1.png" alt=""></p>
</li>
<li><p>点击需要查看的<code>.ipynb</code>文件</p>
<p><img src="/assets/blogimg/Jupyter_2.png" alt=""></p>
</li>
</ul>
<h2 id="将-ipynb转为-py文件"><a href="#将-ipynb转为-py文件" class="headerlink" title="将.ipynb转为.py文件"></a>将.ipynb转为.py文件</h2><ul>
<li><p>将<code>demo.ipynb</code>文件转为<code>demo.py</code></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter nbconvert --to script demo.ipynb</span></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>kNN及手写数字识别</title>
    <url>/2019/01/18/kNN%E5%8F%8A%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>kNN（k-近邻， k-Nearest Neighbor）算法是一种基本的分类与回归方法，是一个简单的无显示学习过程、非泛化学习的监督学习模型。</p>
<a id="more"></a>

<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>获取带有标签的样本数据集</li>
<li>输入没有标签的新数据，将新数据的每个特征与样本集中数据对应的特征进行比较：<ul>
<li>计算新数据与样本数据集中每条数据的距离</li>
<li>对求得的所有距离进行升序排序（从小到大，越小表示越相似）</li>
<li>取前 k （k 一般小于等于 20 ）个样本数据所对应的分类标签</li>
</ul>
</li>
<li>求 k 个数据中出现次数最多的分类标签作为新数据的分类标签</li>
<li>完成分类</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>优点：精度高、对异常值不敏感、无数据输入假定</li>
<li>缺点：计算复杂度高、空间复杂度高</li>
<li>适用数据范围：数值型和标称型</li>
</ul>
<h3 id="k值选取"><a href="#k值选取" class="headerlink" title="k值选取"></a>k值选取</h3><ul>
<li>k值小：近似误差小，估计误差大，整体模型变得复杂，容易发生过拟合。</li>
<li>k值大：近似误差大，估计误差小，整体的模型变得简单。</li>
<li>近似误差：对训练集的训练误差，关注训练集，近似误差小了会出现过拟合，对现有训练集有很好预测，但对未知测试样本的预测会有较大偏差，模型本身不是最接近最佳模型。</li>
<li>测试误差：对测试集的测试误差，关注测试集，估计误差小了说明对未知数据的预测能力好，模型本身最接近最佳模型。</li>
<li>通过<strong>交叉验证（cross validation）</strong>来选取适合的k值 。</li>
</ul>
<h2 id="kNN应用：手写数字的识别"><a href="#kNN应用：手写数字的识别" class="headerlink" title="kNN应用：手写数字的识别"></a>kNN应用：手写数字的识别</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><table>
<thead>
<tr>
<th>手写数字图片</th>
<th>二进制文件</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/assets/blogimg/digit.png" alt="digit"></td>
<td><img src="/assets/blogimg/digit_code.png" alt="digit"></td>
</tr>
</tbody></table>
<h3 id="识别结果"><a href="#识别结果" class="headerlink" title="识别结果"></a>识别结果</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">**1NN实现的手写数字识别**</span></pre></td></tr><tr><td class="code"><pre><span class="line">识别成功！这是数字: 9</span></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 读取数据文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：目录，文件名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 返回：数据矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(f_dir, f_name)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    f = open(f_dir + f_name, <span class="string">'r'</span>, encoding=<span class="string">'utf8'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f_width, f_height = <span class="number">32</span>, <span class="number">32</span>  <span class="comment"># 数字数据尺寸为32*32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    digit_mat = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(f_height):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mat = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str = f.readline()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(f_width):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mat.append(int(str[j]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        digit_mat.append(mat)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> digit_mat</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 准备数字数据文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：训练数字文件目录</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 返回：数字样本及类别矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare_digits</span><span class="params">(f_dir)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    f_list = listdir(f_dir)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    digits = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f_list:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> i[<span class="number">0</span>].isdigit():</span></pre></td></tr><tr><td class="code"><pre><span class="line">            digits.append([read_data(f_dir, i), i[<span class="number">0</span>]])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> digits</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 将图像转为只包含0和1的txt文件，内容区域用1填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：输入的图片文件，输出的txt文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2code</span><span class="params">(img_file, code_file)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    img = Image.open(img_file)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    img = img.resize((<span class="number">32</span>, <span class="number">32</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    img = img.convert(<span class="string">'1'</span>)  <span class="comment"># 转换为黑白图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    width, height = img.size</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f1 = open(img_file, <span class="string">'r'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f2 = open(code_file, <span class="string">'w'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(height):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(width):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pixel = int(img.getpixel((j, i)) / <span class="number">255</span>)  <span class="comment"># 获取每个像素值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> pixel == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pixel = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">elif</span> pixel == <span class="number">1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pixel = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            f2.write(str(pixel))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> j == width - <span class="number">1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                f2.write(<span class="string">'\n'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f1.close()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f2.close()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 欧式距离计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：训练数字数据集，未知数字数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 返回：距离列表(序号, 距离)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_diatance</span><span class="params">(training_digits, unknown_digit)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    distance = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    i = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> training_digits:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        distance.append([i, np.linalg.norm(np.array(t[<span class="number">0</span>]) - np.array(unknown_digit))])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i = i + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> distance</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 手写数字识别</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">digit_identify</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    trainingdigits_dir = <span class="string">'./trainingDigits/'</span>  <span class="comment"># 训练数据目录</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    digits = prepare_digits(trainingdigits_dir)  <span class="comment"># 训练数据列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'**1NN实现的手写数字识别**'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    unknown_digit_img = <span class="string">'./digits_img/digit.png'</span>  <span class="comment"># 图片文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    unknown_digit_txt = <span class="string">'./digits_img/digit.txt'</span>  <span class="comment"># 转化成二进制文件后的文件名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    img2code(unknown_digit_img, unknown_digit_txt)  <span class="comment"># 转化成二进制文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    unknown_digit = read_data(<span class="string">'./digits_img/'</span>, <span class="string">'digit.txt'</span>)  <span class="comment"># 读取待识别数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    distance = get_diatance(digits, unknown_digit)  <span class="comment"># 计算距离矩阵(序号, 距离)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    distance = sorted(distance, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])  <span class="comment"># 根据距离排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    k = <span class="number">5</span>  <span class="comment"># k值选取</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    labels = distance[<span class="number">0</span>:k]  <span class="comment"># 截取前k个最相似的数据样本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    count = list(np.zeros(<span class="number">10</span>))  <span class="comment"># 各个标记的次数列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 统计次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> labels:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        index = i[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        l = int(digits[index][<span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        count[l] = count[l] + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    label = count.index(max(count))  <span class="comment"># 待识别数据的标记</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'识别成功！这是数字: '</span> + str(label))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    digit_identify()</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>根据距离指定点的二维坐标</title>
    <url>/2018/12/01/%E6%A0%B9%E6%8D%AE%E8%B7%9D%E7%A6%BB%E6%8C%87%E5%AE%9A%E7%82%B9%E7%9A%84%E4%BA%8C%E7%BB%B4%E5%9D%90%E6%A0%87/</url>
    <content><![CDATA[<p>根据相互距离指定n个点的二维坐标。</p>
<a id="more"></a>

<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="1-首先指定前3个点的坐标（根据2个圆）"><a href="#1-首先指定前3个点的坐标（根据2个圆）" class="headerlink" title="1. 首先指定前3个点的坐标（根据2个圆）"></a>1. 首先指定前3个点的坐标（根据2个圆）</h3><ul>
<li>设置常量<strong>Ax</strong>， <strong>Ay</strong>作为<strong>A</strong>点坐标</li>
<li><strong>A</strong>与<strong>B</strong>的距离为<strong>Dab</strong>，则<strong>B</strong>点坐标设置为<strong>Bx = Ax - Dab</strong>, <strong>By = Ay</strong></li>
<li><strong>C</strong>与<strong>A</strong>的距离为<strong>Dac</strong>作为<strong>第1个圆</strong>的半径<strong>R1</strong>，<strong>C</strong>与<strong>B</strong>的距离为<strong>Dbc</strong>作为<strong>第2个圆</strong>的半径<strong>R2</strong></li>
<li>以<strong>A</strong>点为圆心，<strong>R1</strong>为半径画<strong>圆1</strong>，以<strong>B</strong>点为圆心，<strong>R2</strong>为半径画<strong>圆2</strong></li>
<li>两个交点任选一个作为<strong>C点坐标</strong></li>
</ul>
<h3 id="2-然后指定剩余n-3个点的坐标（根据3个圆）"><a href="#2-然后指定剩余n-3个点的坐标（根据3个圆）" class="headerlink" title="2. 然后指定剩余n-3个点的坐标（根据3个圆）"></a>2. 然后指定剩余n-3个点的坐标（根据3个圆）</h3><ul>
<li>利用<strong>A、B和C</strong>三个点依次确定剩余点的坐标</li>
<li>对于剩余点中的某一个点<strong>P</strong><ul>
<li><strong>P</strong>与<strong>A</strong>的距离为<strong>Dap</strong>作为<strong>第1个圆</strong>的半径<strong>R1</strong>，<strong>P</strong>与<strong>B</strong>的距离为<strong>Dbp</strong>作为<strong>第2个圆</strong>的半径<strong>R2</strong></li>
<li>以<strong>A</strong>点为圆心，<strong>R1</strong>为半径画<strong>圆1</strong>，以<strong>B</strong>点为圆心，<strong>R2</strong>为半径画<strong>圆2</strong></li>
<li>得到<strong>两个交点</strong>，根据<strong>P</strong>与<strong>C</strong>的距离确定<strong>P点坐标</strong></li>
</ul>
</li>
<li>完成</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 已知n个点两两之间的距离，指定他们的坐标，相互距离保持不变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 用欧式距离计算样本集的距离矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：样本集x，类型为np.array</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_distance</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    size = len(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    distance = np.zeros(shape=(len(x), len(x)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size - <span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            distance[i][j] = np.sqrt(np.sum(np.power(x[i] - x[j], <span class="number">2</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            distance[j][i] = distance[i][j]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> distance</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算2个圆的交点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circle_2</span><span class="params">(p1, r1, p2, r2)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = p1[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y = p1[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    R = r1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = p2[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    b = p2[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    S = r2</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = math.sqrt((abs(a - x)) ** <span class="number">2</span> + (abs(b - y)) ** <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> d &gt; (R + S) <span class="keyword">or</span> d &lt; (abs(R - S)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"Two circles have no intersection!"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">elif</span> d == <span class="number">0</span> <span class="keyword">and</span> R == S:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(<span class="string">"Two circles have same center!"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A = (R ** <span class="number">2</span> - S ** <span class="number">2</span> + d ** <span class="number">2</span>) / (<span class="number">2</span> * d)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        h = math.sqrt(R ** <span class="number">2</span> - A ** <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x2 = x + A * (a - x) / d</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y2 = y + A * (b - y) / d</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x3 = round(x2 - h * (b - y) / d, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y3 = round(y2 + h * (a - x) / d, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x4 = round(x2 + h * (b - y) / d, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y4 = round(y2 - h * (a - x) / d, <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c1 = np.array([x3, y3])  <span class="comment"># 第1个交点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        c2 = np.array([x4, y4])  <span class="comment"># 第2个交点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> c1, c2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算3个圆的交点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circle_3</span><span class="params">(p1, r1, p2, r2, p3, r3)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c1, c2 = circle_2(p1, r1, p2, r2)  <span class="comment"># 前2个交点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 从c1和c2中选择正确的一个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    d1 = np.sqrt(np.power(c1[<span class="number">0</span>] - p3[<span class="number">0</span>], <span class="number">2</span>) + np.power(c1[<span class="number">1</span>] - p3[<span class="number">1</span>], <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d2 = np.sqrt(np.power(c2[<span class="number">0</span>] - p3[<span class="number">0</span>], <span class="number">2</span>) + np.power(c2[<span class="number">1</span>] - p3[<span class="number">1</span>], <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> d1 == r3:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> c1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">elif</span> d2 == r3:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> c2</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 指定坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_coordinate</span><span class="params">(dist)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 先固定前三个点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = [<span class="number">5</span>]  <span class="comment"># 第1个点的x坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    y = [<span class="number">5</span>]  <span class="comment"># 第1个点的y坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x.append(<span class="number">5</span>-dist[<span class="number">0</span>][<span class="number">1</span>])  <span class="comment"># 第2个点的x坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    y.append(<span class="number">5</span>)  <span class="comment"># 第2个点的y坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = np.array([x[<span class="number">0</span>], y[<span class="number">0</span>]])  <span class="comment"># a点坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b = np.array([x[<span class="number">1</span>], y[<span class="number">1</span>]])  <span class="comment"># b点坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    r1 = dist[<span class="number">0</span>][<span class="number">2</span>]  <span class="comment"># a、c点距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    r2 = dist[<span class="number">1</span>][<span class="number">2</span>]  <span class="comment"># b、c点距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C = circle_2(a, r1, b, r2)  <span class="comment"># c点坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    c = C[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x.append(c[<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y.append(c[<span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 现在前三个点a,b,c坐标已知，现在指定剩余的n-3个点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, len(dist)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Ra = dist[<span class="number">0</span>][i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Rb = dist[<span class="number">1</span>][i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Rc = dist[<span class="number">2</span>][i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c = np.array(c)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        P = circle_3(a, Ra, b, Rb, c, Rc)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        new_x = P[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        new_y = P[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x.append(new_x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y.append(new_y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x, y</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = [[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">2</span>], [<span class="number">4</span>, <span class="number">6</span>], [<span class="number">2</span>, <span class="number">7</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dist = get_distance(np.array(x))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    X, Y = set_coordinate(dist)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    xx = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(X)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        xx.append([X[i], Y[i]])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(xx)  <span class="comment"># 指定后n个点的二维坐标列表，形式同x</span></span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>用Dijkstra算法求最短路径</title>
    <url>/2018/11/27/%E7%94%A8Dijkstra%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>Dijkstra算法是单源最短路算法的一种，可用于求从出发节点到所有可到达节点的最短路长度。</p>
<a id="more"></a>

<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><table>
<thead>
<tr>
<th align="center">有向图</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="/assets/blogimg/dijkstra-1.png" alt=""></td>
<td align="center"><img src="/assets/blogimg/dijkstra-2.png" alt=""></td>
</tr>
</tbody></table>
<h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 100000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> E[N][N], dist[N], path[N];  <span class="comment">// 边集，与源点的距离，路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// dijkstra算法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：源点s，总节点数n</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> visit[N] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 已访问节点数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dist[i] = E[s][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    visit[s] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dist[s] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> min_dsit = INF;  <span class="comment">// 最小距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> min_no;  <span class="comment">// 最小距离对应的节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(!visit[j] &amp;&amp; dist[j] &lt; min_dsit)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                min_dsit = dist[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                min_no = j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        visit[min_no] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(dist[j] &gt; min_dsit + E[min_no][j])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                path[j] = min_no;  <span class="comment">// min_no为到节点j的最后一个中途节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                dist[j] = min_dsit + E[min_no][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;            </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 输出最短路径和距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：源点s，总节点数n</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(path[j] != <span class="number">-1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            st.push(j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            j = path[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        st.push(j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; i &lt;&lt; <span class="string">", distance: "</span> &lt;&lt; dist[i] &lt;&lt; <span class="string">", path: "</span> &lt;&lt; s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(!st.empty())&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; st.top() ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            st.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(path, <span class="number">-1</span>, <span class="keyword">sizeof</span>(path));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            E[i][j] = i==j? <span class="number">0</span>:INF;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 有向图举例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    E[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">12</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">9</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">5</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">13</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">15</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    E[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 求源点0到其余节点的最短路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dijkstra(<span class="number">0</span>, n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    show(<span class="number">0</span>, n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>爱、尊重与理解</title>
    <url>/2018/11/06/%E7%88%B1%E3%80%81%E5%B0%8A%E9%87%8D%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>观《放牛班的春天》有感。<a href="https://movie.douban.com/subject/1291549/" target="_blank" rel="noopener">豆瓣电影：放牛班的春天</a></p>
<a id="more"></a>

<p>生活从来都不那么容易，虽不绝对，但在这世界的某个角落里，就有着我们常人难以想象的艰难与悲伤。对他们来说，“寒冬”已然成为生活的绝妙比喻，但只要有爱、有尊重、有理解，生活的“暖春”很快就来了。“放牛班的春天”是一部关怀人性、启迪教育，且充满温情的作品，“池塘之底”里面被人遗弃的孩子们，正是因为马修和他带来的音乐，才慢慢袒露深藏着的柔弱的真心，才真正迎来了他们的“春天”。</p>
<p>在这样一所被称为“池塘底教养院”的男子寄宿学校里，生活中一群几乎被放弃的男孩们，严酷且不近人情的体罚是他们的家常便饭，“问题少年”或许并不是一开始就有问题的，生活的环境和遭受的态度才是他们的致命伤。</p>
<h3 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h3><p>校长是一个作威作福、溜须拍马、唯我独尊的人，他的“犯错-惩罚”原则对孩子们来说很残酷，而他自己内心毫无波澜。虽然在马修合唱团的练习中，校长有过一丝丝改变，我想在他站在椅子上努力飞纸飞机的时候，内心一定是干净且美好的，但弱小的萌芽面对长久以往根深蒂固的病态心理，瞬间毫无还手之力，只得死在贫瘠的土壤里。</p>
<p>体育老师热爱运动与音乐，认为运动与音乐是促进人民团结的主要动力，他会在关键时刻保护孩子们，甚至勇敢地去揭露校长的丑行。他的温情和勇敢在盗用校长私人木柴的时候真正展现，他愿意让孩子们洗个热水澡。</p>
<p>校工心地善良、待人和气真诚，虽然屡次因调皮男孩们而受伤，但他心中有爱，且宽容孩子。看不惯马修的遭遇甚至愿意一起下岗，可以说是一种下层弱小阶级的无声抵抗。</p>
<p>皮埃尔的妈妈，一位优雅的单身母亲，无可奈何才让深爱的皮埃尔在这里生活，她努力工作，为皮埃尔带来好吃的蛋糕，为自己的幸福勇敢去爱，也因为最疼爱的儿子而选择孤独终老，圣母般的贞洁形象深深印刻在观众脑海。</p>
<p>佩皮诺是一个傻乎乎的小男孩，性格怯懦却又机灵，不会愚蠢的拼命而是寻求强者的保护，最珍贵的是他心中一直有爱，一直坚信某一个“星期六”他爸爸会带他离开这里。而最终圆他所梦，在马修离开的那个星期六等到了那个带他离开的人。</p>
<p>马修老师，这个音乐梦想受挫且怀才不遇的音乐家在这里迎来了他音乐创作的春天，他是一个理想父亲的形象，善良、尊重、理解的品性使他会竭尽全力保护男孩们，循循善诱与鼓励支持，只为点燃孩子们心中那盏几近熄灭的灯。马修是平凡的，他没有能力反抗上层的压迫，只能以“地下党”的形式开展合唱团计划。他善于发现孩子们的优点并给予希望，因为孩子们单纯的渴望而愿意成为同党，会在深夜里为孩子们盖好被子。可以说，马修才是孩子们真正父亲一般的存在，因为他，孩子们内心的恐慌与不安有了着落，也有了希望。</p>
<p>皮埃尔，真正的主人公。“天使面孔，毒蛇心肠”的形容并不贴切，从头到尾，皮埃尔并未有毒蛇心肠，只不过是内心极度敏感的他有一些破坏力而已。他几乎不信任任何人，甚至是自己的母亲，但当同学侮辱他妈妈的时候，他会奋不顾身地反抗和厮打，是的，他爱他妈妈。但因为他是私生子，他的内心也极度敏感和不安，偷偷观察母亲的举动也合乎情理。但他过往的经历，流言蜚语也好，恶语中伤也罢，都将他的内心摧残得千疮百孔，以至于他宁愿独自参加母亲的葬礼。因为马修老师这位伯乐，他如愿进入里昂音乐学院，成为世界顶级的音乐家。</p>
<h3 id="悲伤"><a href="#悲伤" class="headerlink" title="悲伤"></a>悲伤</h3><p>从这些主要角色的人物性格，我们不难窥视出那个情景下人们生活的不易与内心的悲伤。整部影片都荡漾着合唱团的美妙旋律，但看到结尾，悲伤之感去了又回。校长内心的纯真终于没有长大，也最终为自己的恶行买单。蒙丹因校长的误解和酷刑生出了更加恐怖的报复心理，以至于点燃学校，这还没结束，因为马修没有机会去影响和感化蒙丹，蒙丹之后的生活将以过往的心态甚至更加恐怖的行径延续，教养院只是社会的一个缩影，而蒙丹将镜头延伸出了学校。对于皮埃尔来说，马修无疑是他生命中最珍贵、最重要、最有影响的人，父亲、伯乐、老师，这些词语都难以描述。但当马修离开之时，皮埃尔依然无动于衷，仅仅同其他孩子一样扔纸飞机以送别马修，这似乎有些残忍和无情，或许因为胆怯与校长的酷刑，但这都不是最重要的，起决定性作用的还是内心。甚至多年以后，当佩皮诺跟他谈起教养院的时光，他甚至无法记得马修的名字，虽然时隔多年，但用佩皮诺的话来说，“只不过50来年而已”，这的确有些悲凉。</p>
<h3 id="温情"><a href="#温情" class="headerlink" title="温情"></a>温情</h3><p>虽然有不可避免的悲伤，但整部影片依然是温情的，是充满爱与理解的。可以说，这是一部启迪教育的佳作。马修让孩子们发掘自己的内心并写下自己的梦想，他用一种平等且尊重的方式对待孩子们，他支持孩子们有个性、有喜好，他宽容孩子们犯错误，他认为这些“被放弃”的孩子们依然有价值，他用音乐感化了一颗颗脆弱和饱受磨难的心灵。孩子们并不坏，只不过是想要得到尊重，想要平等，想要被人理解和爱护。就像偷钱的小男孩只是单纯的渴望买一个热气球一样，孩子们天性纯真，顽劣的帽子只不过是那些不懂方法且缺乏爱的人所扣上的帽子。合唱团里动听的旋律才是对思想的批判和灵魂的发现，才会让温情将人们内心的坚冰消融。西方教育倡导平等，只有在没有歧视的平等基础上，天才才能闪耀出耀眼的光辉，马修以人为本的思想是才是对学生心灵和思想重塑的法宝，这因该是这部影片带给教育界最珍贵的思考和启迪。</p>
<h3 id="感恩"><a href="#感恩" class="headerlink" title="感恩"></a>感恩</h3><p>悲伤于孩子们不幸的境遇，感动于合唱团温暖的旋律，回味于影片背后的思考，优秀且经典的作品总会让人产生思考和感悟，这部《放牛班的春天》正是如此。对比之下，我不由得感恩，感恩自己的美好生活。因为爸妈和家人的爱护，我远离了那种被放弃的生活；因为朋友的陪伴和鼓励，我的内心没有变得扭曲和病态；因为老师的循循善诱，我没有经受“放牛班”的糟糕教育。我感谢生命中的一切，让我远离阴霾和悲伤，让我的生活积极阳光有希望。</p>
<p>爱、尊重与理解，是这世界上最珍贵的财富，我希望每个人都能拥有这财富。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法</title>
    <url>/2018/11/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>几道动态规划算法题解。</p>
<a id="more"></a>

<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划求斐波那契数列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib_dp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>)    <span class="keyword">return</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">0</span>, s = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        s = x + y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(n != <span class="number">-1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"F("</span> &lt;&lt; n &lt;&lt; <span class="string">") = "</span> &lt;&lt; fib_dp(n) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><h3 id="1-输出公共子序列长度"><a href="#1-输出公共子序列长度" class="headerlink" title="1. 输出公共子序列长度"></a>1. 输出公共子序列长度</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划求最长公共子序列问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m = b.<span class="built_in">size</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> L[n+<span class="number">1</span>][m+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        L[i][<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        L[<span class="number">0</span>][j] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(a[i] == b[j])    L[i][j] = L[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>    L[i][j] = <span class="built_in">max</span>(L[i][j<span class="number">-1</span>], L[i<span class="number">-1</span>][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> L[n][m];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> a = <span class="string">"xzyzzyx"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> b = <span class="string">"zxyyzxz"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" 和 "</span> &lt;&lt; b &lt;&lt; <span class="string">" 最长公共子序列的长度为: "</span> &lt;&lt; lcs(a, b) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2-输出所有最长的公共子序列"><a href="#2-输出所有最长的公共子序列" class="headerlink" title="2. 输出所有最长的公共子序列"></a>2. 输出所有最长的公共子序列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待完成</span></span></pre></td></tr></table></figure>

<h2 id="矩阵链相乘问题"><a href="#矩阵链相乘问题" class="headerlink" title="矩阵链相乘问题"></a>矩阵链相乘问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待完成</span></span></pre></td></tr></table></figure>

<h2 id="所有点对的最短路径"><a href="#所有点对的最短路径" class="headerlink" title="所有点对的最短路径"></a>所有点对的最短路径</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试: 4 0 7 1 6 100 0 9 100 4 4 0 2 1 100 100 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划求所有点对的最短路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n; <span class="comment">// 点数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> d[n][n]; <span class="comment">// 距离矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; d[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k]+d[k][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最短路径矩阵: "</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; d[i][j] &lt;&lt; <span class="string">' '</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待完成</span></span></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待完成</span></span></pre></td></tr></table></figure>

<h2 id="金币兑换问题"><a href="#金币兑换问题" class="headerlink" title="金币兑换问题"></a>金币兑换问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试: 30 4 1 5 7 11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划求解金币兑换问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数: 总钱数s, 总金币种类数n, 金币面值V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goldcoin</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n, <span class="keyword">int</span> V[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> r[s+<span class="number">1</span>]; <span class="comment">// 各个价值下所需的金币数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> w[s+<span class="number">1</span>]; <span class="comment">// 各个价值下是那种金币</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=s; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        r[i] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V[i]; j&lt;=s; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> temp = r[j-V[i]] + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(temp &lt; r[j]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                r[j] = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                w[j] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"最少金币数: "</span> &lt;&lt; r[s] &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map_dp; <span class="comment">// 各种金币的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(s &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        map_dp[w[s]]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        s = s - V[w[s]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"面值为 "</span> &lt;&lt; V[i] &lt;&lt; <span class="string">" 的金币需要 "</span> &lt;&lt; map_dp[i] &lt;&lt; <span class="string">" 个"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> s; <span class="comment">// 总钱数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n; <span class="comment">// 金币种类数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> V[n]; <span class="comment">// 各个金币的面值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; V[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    goldcoin(s, n, V);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯依然有梦想</title>
    <url>/2018/11/04/%E8%85%BE%E8%AE%AF%E4%BE%9D%E7%84%B6%E6%9C%89%E6%A2%A6%E6%83%B3/</url>
    <content><![CDATA[<p>读潘乱《腾讯没有梦想》有感。</p>
<a id="more"></a>

<p>《腾讯没有梦想》站在互联网公司的角度，列举了很多论点论据，都有理有据，矛头直指这个“没有梦想”的腾讯，作者认为腾讯越来越像一家斗志昂扬的投资公司，而非一家创新型的互联网公司，正在丧失产品能力和创业精神。但是，当我们将格局放大，以一种更广阔的视角去看待，就会发现并非如此。</p>
<h3 id="腾讯是什么"><a href="#腾讯是什么" class="headerlink" title="腾讯是什么"></a>腾讯是什么</h3><p>腾讯自称是“一家以互联网为基础的科技与文化公司”，它们的使命是“提升人类生活品质”，单从这一点来看，腾讯就是有梦想的。腾讯的核心业务在于社交，亦即“连接一切”，正是因为腾讯比其他任何互联网公司更清楚自己的核心使命，才没有丧失梦想。的缺，腾讯几乎成了当今最大的互联网VC，表面上似乎成了一家真正的VC，但腾讯在社交与游戏上从未有过丝毫松懈。在互联网+的时代，“+”已然是最具价值的，各行各业的“+”都离不开流量与平台，而这，正是腾讯为之奋斗的原因。</p>
<h3 id="腾讯做什么"><a href="#腾讯做什么" class="headerlink" title="腾讯做什么"></a>腾讯做什么</h3><p>腾讯的核心能力在于“流量”和“资本”，腾讯会用资本和流量牢牢捍卫自己的核心竞争力。在收购与投资的极力扩张的同时，腾讯凭借自己“天眼”一般的数据，让一切更好的连接。互联网公司的本质就是商业公司，腾讯也不例外。而对于一家公司来讲，其所有负担的责任便不仅仅是做出一个好的产品或者有一个好的创意点子，而是更关乎战略、未来发展蓝图以及社会使命。往往我们说某个小公司具有很强的创新能力、开发的产品很受人们喜爱，是因为这些小公司当前的使命除了活下去之外，别无他物，更别说如何承担更大的社会责任，他们只能不断打磨产品这把用来生存的宝剑。在战略上，腾讯只选择最好的那一个，腾讯有自己的尚方宝剑——流量和平台，可以帮助小的创业公司活下去、在市场站住脚，而腾讯获得的，是进一步的连接。投资，只是连接的一个手段，而非为了投资而投资。正如迈克尔·波特所言，“决定不做什么和决定做什么同样重要”，腾讯正是因为深知这一秘诀，才从未丧失自己的核心竞争力。</p>
<h3 id="腾讯想什么"><a href="#腾讯想什么" class="headerlink" title="腾讯想什么"></a>腾讯想什么</h3><p>回到本质，腾讯是想让社会变得更好。当今社会下的万众创新、大众创业，离不开行业巨头的投资与扶持，和硅谷的科技巨头们一样，投资只为更好的创投氛围。腾讯是想连接一个又一个极具创新能力的创业公司，利用自己的优势，铺设一张张“互联”的巨网，这才使得国内有越来越多的创新型企业生根发芽、长成参天大树。腾讯致力于各行各业的连接，始终坚守初心、坚守自己的核心业务，正在以行业巨头在大格局的视角下审视整个行业，乃至整个社会的发展。腾讯不仅在战略合作、开放互联上畅想与飞跃，更在社会公益与行业融合发展上积极部署规划，不断发挥作用。</p>
<p>总体来说，我认为腾讯依然有梦想，依然知其所长、做其所向。其表象上的战略投资与扩张，根本上都是在为自己“连接一切，让社会更好”的梦想而服务。</p>
<p><a href="https://36kr.com/p/5132597.html" target="_blank" rel="noopener">腾讯没有梦想</a><br><a href="https://36kr.com/p/5132595.html?from=related" target="_blank" rel="noopener">谁说腾讯没有梦想</a><br><a href="http://www.tmtpost.com/3229138.html" target="_blank" rel="noopener">为什么说腾讯没有梦想，阿里没有盟友</a></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>5道Google面试题</title>
    <url>/2018/11/03/5%E9%81%93Google%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>5道有趣的Google面试题，放心，与计算机技术无关！</p>
<a id="more"></a>

<h3 id="1-台球"><a href="#1-台球" class="headerlink" title="1. 台球"></a>1. 台球</h3><p>有8个台球，其中一个比其他的7个都要重一些。如果仅仅是使用天平而不称出具体的重量，请问最少几次能找出那个最重的台球？</p>
<h3 id="2-沙漠里的男尸"><a href="#2-沙漠里的男尸" class="headerlink" title="2. 沙漠里的男尸"></a>2. 沙漠里的男尸</h3><p>在沙漠里发现一具男人的尸体，他手里有一根火柴。没有脚印。请问他为什么会死，是怎么死的？</p>
<h3 id="3-四升水"><a href="#3-四升水" class="headerlink" title="3. 四升水"></a>3. 四升水</h3><p>你有足够多的水和两个杯子：5L和3L。请精确地量出4L水。</p>
<h3 id="4-熊"><a href="#4-熊" class="headerlink" title="4. 熊"></a>4. 熊</h3><p>你刚建造了一间房子，房子的每一面墙都是朝南的。突然你看见了一只熊，请问这只熊是什么颜色的？</p>
<h3 id="5-药片"><a href="#5-药片" class="headerlink" title="5. 药片"></a>5. 药片</h3><p>医生给了病人4片药：每一种药2片，医生叮嘱千万不能弄混了。早上一种药吃1片，晚上一种药吃1片。如果吃错了或者不吃，病人就会死掉。然而，病人把要弄混了，怎么办？</p>
<!-- more -->

<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="1-台球-1"><a href="#1-台球-1" class="headerlink" title="1. 台球"></a>1. 台球</h3><p>2次。把所有的球分成3组，其中2组是3个球，最后一组是两个球。首先把3个球的两组放在天平上，如果其中一方比较重，把偏重的那一组球任意拿出来两个放在天平上。如果两组球一样重，那就把剩下的2个球放在天平上称重。</p>
<p>也可用<strong>信息熵</strong>求解：<strong>k·log2(3)&gt;=log2(8)  k&gt;=1.89</strong>，取 <strong>k=2</strong>，故需2次。参考：<a href="https://coolr321.github.io/2018/11/02/%E4%BF%A1%E6%81%AF%E7%86%B5%E7%9A%84%E6%9C%89%E8%B6%A3%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">信息熵的有趣应用</a></p>
<h3 id="2-沙漠里的男尸-1"><a href="#2-沙漠里的男尸-1" class="headerlink" title="2. 沙漠里的男尸"></a>2. 沙漠里的男尸</h3><p>这个问题主要是测试你还原事件真相的能力。这个男人是在跳下飞机的时候摔死的，飞机上的降落伞不够，所以用抽火柴的方式决定。不幸的是，这个男人抽中的是短火柴，所以就只能在没有降落伞的情况下跳下去了。</p>
<h3 id="3-四升水-1"><a href="#3-四升水-1" class="headerlink" title="3. 四升水"></a>3. 四升水</h3><ol>
<li>先把5L水的杯子装满，然后用5L的杯子里的水把3L的杯子装满。</li>
<li>把3L杯子里的水倒掉。</li>
<li>把5L杯子里剩的2L水倒入3L的杯子。</li>
<li>把5L的杯子装满，再用5L杯子里的水补满3L的杯子（里边有2L的水），这样5L的杯子里就有4L水。</li>
</ol>
<h3 id="4-熊-1"><a href="#4-熊-1" class="headerlink" title="4. 熊"></a>4. 熊</h3><p>白色，因为这是一只北极熊，只有在北极才能做到房子的每一面墙都是朝南的。</p>
<h3 id="5-药片-1"><a href="#5-药片-1" class="headerlink" title="5. 药片"></a>5. 药片</h3><p>把四片药都分成两半，早上吃4个半片，晚上吃4个半片。</p>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>用PV操作解决生产者消费者问题</title>
    <url>/2018/11/02/%E7%94%A8PV%E6%93%8D%E4%BD%9C%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>操作系统进程相关：用PV操作解决生产者消费者问题。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>当进程并发执行时，如果对进程访问的共享变量不加限制，就会产生“与时间有关”的错误。为了防止这类错误，系统必须用同步机构来控制进程对共享变量的访问。一般说，同步机构是由若干条同步原语所组成。本实验要求模拟<strong>P</strong>、<strong>V</strong>操作实现同步机构，且用<strong>P</strong>、<strong>V</strong>操作解决生产者—消费者问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/imysql/p/5442458.html" target="_blank" rel="noopener">操作系统中的P,V操作</a></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DO_NUM 30 <span class="comment">// 调度次数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 进程控制块PCB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PNode</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> name;        <span class="comment">// 进程名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> state;       <span class="comment">// 状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> reason;      <span class="comment">// 等待原因</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> breaking;       <span class="comment">// 断点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; produce, consume, *<span class="built_in">run</span>, *<span class="built_in">ready</span>; <span class="comment">// 生产者进程、消费者进程、当前运行进程、当前就绪进程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化数据结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s1 = <span class="number">10</span>, s2 = <span class="number">0</span>, PC; <span class="comment">// 两个信号量，程序计数器PC</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> PA[<span class="number">5</span>]; <span class="comment">// PA[i]存放生产者程序中的一条模拟指令执行的入口地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> SA[<span class="number">5</span>]; <span class="comment">// SA[i]存放消费者程序中的一条模拟指令执行的入口地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> IN = <span class="number">0</span>, OUT = <span class="number">0</span>; <span class="comment">// 进出缓冲期的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> product, X; <span class="comment">// 生产的产品、消费的产品</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> B[<span class="number">10</span>]; <span class="comment">// 缓冲器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化程序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        PA[i] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SA[i] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    produce.name = <span class="string">"Produce"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    produce.state = <span class="string">"Ready"</span>; <span class="comment">// 生产者就绪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    produce.breaking = <span class="number">0</span>; <span class="comment">// 断点为0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    consume.name = <span class="string">"Consume"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    consume.state = <span class="string">"Ready"</span>; <span class="comment">// 消费者就绪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    consume.breaking = <span class="number">0</span>; <span class="comment">// 断点为0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    PC = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 处理机调度程序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(produce.state==<span class="string">"Ready"</span> &amp;&amp; consume.state==<span class="string">"Ready"</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> a = rand() % <span class="number">2</span>; <span class="comment">// 随机数 0或1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">run</span> = &amp;produce; <span class="comment">// 生产者进程运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">ready</span> = &amp;consume; <span class="comment">// 消费者进程就绪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">run</span> = &amp;consume; <span class="comment">// 消费者进程运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">ready</span> = &amp;produce; <span class="comment">// 生产者进程就绪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(produce.state==<span class="string">"Ready"</span> &amp;&amp; consume.state==<span class="string">"Wait"</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">run</span> = &amp;produce; <span class="comment">// 生产者进程运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">ready</span> = &amp;consume; <span class="comment">// 消费者进程就绪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(produce.state==<span class="string">"Wait"</span> &amp;&amp; consume.state==<span class="string">"Ready"</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">run</span> = &amp;consume; <span class="comment">// 消费者进程运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">ready</span> = &amp;produce; <span class="comment">// 生产者进程就绪</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PC = <span class="built_in">run</span>-&gt;breaking; <span class="comment">// 设置断点保护现场</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 处理器执行指令程序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="built_in">run</span>-&gt;name == <span class="string">"Produce"</span>) &#123; <span class="comment">// 当前生产者程序在运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = PA[PC++]; <span class="comment">// 生产者程序指令执行的入口地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span>(j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"生产!请输入一个字符 &gt; "</span>; <span class="built_in">cin</span> &gt;&gt; product; <span class="keyword">break</span>; <span class="comment">// produce</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// P(s1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                s1--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(s1 &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">run</span>-&gt;state = <span class="string">"Wait"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">run</span>-&gt;reason = <span class="string">"s1"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"生产者等待原因: "</span> &lt;&lt; <span class="built_in">run</span>-&gt;reason &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;<span class="keyword">else</span> <span class="built_in">run</span>-&gt;state = <span class="string">"Ready"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// PUT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                B[IN] = product;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                IN = (IN + <span class="number">1</span>) % <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"缓冲器内容: "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; B[i] &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// V(s2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                s2++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(s2 &lt;= <span class="number">0</span>)	<span class="built_in">ready</span>-&gt;state = <span class="string">"Ready"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span>	<span class="built_in">run</span>-&gt;state = <span class="string">"Ready"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: PC = <span class="number">0</span>; <span class="keyword">break</span>; <span class="comment">// GOTO 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">run</span>-&gt;breaking = PC; <span class="comment">// 设置断点保护现场</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 当前消费者程序在运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = SA[PC++]; <span class="comment">// 消费者程序指令执行的入口地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span>(j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// P(s2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                s2--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(s2 &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">run</span>-&gt;state = <span class="string">"Wait"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">run</span>-&gt;reason = <span class="string">"s1"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"消费者等待原因: "</span> &lt;&lt; <span class="built_in">run</span>-&gt;reason &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;<span class="keyword">else</span> <span class="built_in">run</span>-&gt;state = <span class="string">"Ready"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: X = B[OUT]; OUT = (OUT + <span class="number">1</span>) % <span class="number">10</span>; <span class="keyword">break</span>; <span class="comment">// GET</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// V(s1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                s1++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(s1 &lt;= <span class="number">0</span>)	<span class="built_in">ready</span>-&gt;state = <span class="string">"Ready"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span>	<span class="built_in">run</span>-&gt;state = <span class="string">"Ready"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"消费!显示消费的结果 &gt; "</span> &lt;&lt; X &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; <span class="comment">// consume</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: PC = <span class="number">0</span>; <span class="keyword">break</span>; <span class="comment">// GOTO 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">run</span>-&gt;breaking = PC; <span class="comment">// 设置断点保护现场</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    init(); <span class="comment">// 初始化程序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"**用PV操作解决生产者消费者问题**"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;DO_NUM; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        schedule(); <span class="comment">// 处理机调度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        perform(); <span class="comment">// 处理机执行指令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>信息熵的有趣应用</title>
    <url>/2018/11/02/%E4%BF%A1%E6%81%AF%E7%86%B5%E7%9A%84%E6%9C%89%E8%B6%A3%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>信息熵？维基百科这样说：<a href="https://www.wikiwand.com/zh/%E7%86%B5_(%E4%BF%A1%E6%81%AF%E8%AE%BA)" target="_blank" rel="noopener">熵-信息论</a></p>
<a id="more"></a>

<h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p>设随机变量<strong>X = { Xi | i = 1, 2, 3, …, n}</strong>，<strong>Xi</strong> 出现的概率为 <strong>P(Xi)</strong>。则 <strong>X</strong> 的不确定性或熵（Entropy）定义为：<strong>H(X) = 𝜮 P(Xi) * log2P(Xi)</strong></p>
<h2 id="有趣应用"><a href="#有趣应用" class="headerlink" title="有趣应用"></a>有趣应用</h2><p><strong>1. 甲任意取一个不超过10的整数，由乙来猜，但允许乙提K个问题，甲只回答“是”或者“非”，问K多大时可以确定猜到该数。</strong></p>
<p>答：若令乙猜想作为事件V，V可能有10种结果，假定这10种结果是等概率的，V的熵为：H(V)=log2(10)=3.32。令事件Ak=U1U2U3…Uk 为提问k个问题，但Ui的熵不超过log2(2)=1，（因为只有“是”或者“非”），故Ak的熵为不超过k比特，则：log2(10)&lt;=k·log2(2)=k，k&gt;=3.32，k = 4。故K为4时可以猜到这个数。 </p>
<p><strong>2. 有25个外表完全相同的硬币，其中24个重量完全一样，有一个较轻的伪币，用无砝码的天平，试问要做多少次的比较，可以找到这枚伪币？</strong></p>
<p>答：事件V为找出伪币，可能有25个结论，他们是等概率，故：H(V)=log2(25)，事件U为天平称的结果，可能有3种情况：左右平衡、左边重、右边重。故：H(U)=log2(3)。令Ak=U1U2U3…Uk为连续用k次天平的事件，由于 k·log2(3)&gt;=log2(25)，k = 3。故最少3次可以找到这枚伪币。</p>
]]></content>
      <tags>
        <tag>信息论</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA加密算法</title>
    <url>/2018/11/02/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>维基百科这样说：<a href="https://www.wikiwand.com/zh/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">RSA加密算法</a></p>
<a id="more"></a>

<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><ol>
<li>RSA 是非对称算法，加解密使用不同的密钥。</li>
<li>RSA 算法的可靠性基础：<strong>对极大整数做因数分解是很困难的</strong>（NP问题）。</li>
<li><strong>(n, e)</strong> 是公钥，<strong>(n, d)</strong> 是私钥，公钥发送给所有通信对象，私钥则必须保管好，防止泄露。</li>
<li>若使RSA安全，<strong>p</strong> 与 <strong>q</strong> 必为足够大的素数，使破解者没办法在多项式时间内将 <strong>n</strong> 分解。</li>
</ol>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul>
<li>现在<strong>Bob</strong>想要发送一封密信给<strong>Alice</strong>，他需要这样做：</li>
</ul>
<ol>
<li>寻找两个大素数 <strong>p</strong> 和 <strong>q</strong></li>
<li>计算 <strong>n = p * q</strong> 和 <strong>𝝋(n) = (p-1) * (q-1)</strong></li>
<li>选择一个随机数 <strong>e</strong>（0 &lt; e &lt; 𝝋(n)），满足 <strong>e 与 𝝋(n) 互质</strong>  </li>
<li>使用辗转相除法计算 <strong>e 关于 𝝋(n) 的模反元素 d</strong>，记为 <strong>d = e^{-1} (mod  𝝋(n))</strong></li>
<li>在目录中公开 <strong>n</strong> 和 <strong>e</strong> 作为公钥，并销毁 <strong>p</strong> 和 <strong>q</strong></li>
<li>将明文划分成块，使每个明文报文 <strong>P</strong> 的长度 <strong>m</strong> 满足：<strong>0 &lt; m &lt; n</strong></li>
<li>依次加密 <strong>P</strong> 得到密文：<strong>C = P^e  (mod n)</strong></li>
<li>向<strong>Alice</strong>发送密文 <strong>C</strong> 和公钥 <strong>(e, n)</strong></li>
</ol>
<ul>
<li><strong>Alice</strong>收到密文后，这样解密：用私钥 <strong>(d, n)</strong>解密得到明文 <strong>P＝C^d (mod n)</strong></li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>用位示图管理磁盘存储空间</title>
    <url>/2018/11/02/%E7%94%A8%E4%BD%8D%E7%A4%BA%E5%9B%BE%E7%AE%A1%E7%90%86%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>操作系统存储相关：用位示图管理磁盘存储空间。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>为了提高磁盘存储空间的利用率，可在磁盘上组织成链接文件、索引文件，这类文件可以把逻辑记录存放在不连续的存储空间。为了表示哪些磁盘空间已被占用，哪些磁盘空间是空闲的，可用位示图来指出。</li>
<li><strong>位示图</strong>由若干字节构成，每位与磁盘上的一块对应，“<strong>1</strong>”状态表示相应块已占用，“<strong>0</strong>”表示该块为空闲。</li>
<li><strong>申请</strong>一块磁盘空间时，由分配程序查位示图，找出一个为“<strong>0</strong>”的位，计算出这一位对应块的磁盘物理地址，且把该位置成占用状态“<strong>1</strong>”。假设现在有一个盘组共<strong>8</strong>个柱面，每个柱面有<strong>2</strong>个磁道（盘面），每个磁道分成<strong>4</strong>个物理记录。那么，当在位示图中找到某一字节的某一位为“<strong>0</strong>”时，这个空闲块对应的<strong>磁盘物理地址</strong>为：<ul>
<li><strong>柱面号 = 字节号</strong></li>
<li><strong>磁道号 = 位数 / 4</strong></li>
<li><strong>物理记录号 = 位数 % 4</strong></li>
</ul>
</li>
<li><strong>归还</strong>一块磁盘空间时，由回收程序根据归还的磁盘物理地址计算出归还块在位示图中的对应位，把该位置成“<strong>0</strong>”。归还块在<strong>位示图中的位置</strong>计算如下：<ul>
<li><strong>字节号 = 柱面号</strong></li>
<li><strong>位数 = 磁道号 * 4 + 物理记录号</strong></li>
</ul>
</li>
</ol>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol>
<li>能接受来自键盘的空间申请及释放请求，能显示或打印程序运行前和运行后的位示图</li>
<li>分配时把分配到的磁盘空间的物理地址显示或打印出来，归还时把归还块对应于位示图的字节号和位数显示或打印出来</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 8 <span class="comment">// 柱面数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化位示图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_bitmap</span><span class="params">(<span class="keyword">int</span> bitmap[MAX_SIZE][MAX_SIZE])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cylinder, track, record; <span class="comment">// 柱面号，磁道号，物理记录号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> order; <span class="comment">// 指令: 继续 or 退出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"是否需要初始化已分配空间(y or n)?"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(order == <span class="string">'n'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"**位示图初始化**"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入已分配空间的柱面号, 磁道号和物理记录号(用空格分隔): "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; cylinder &gt;&gt; track &gt;&gt; record;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        bitmap[cylinder][<span class="number">4</span>*track+record] = <span class="number">1</span>; <span class="comment">// 已分配的空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"继续(c) or 退出(q): "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(order == <span class="string">'q'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 分配空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> bitmap[MAX_SIZE][MAX_SIZE])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 判断是否有可分配空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX_SIZE; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAX_SIZE; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(bitmap[i][j] == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                bitmap[i][j] = <span class="number">1</span>; <span class="comment">// 分配空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"成功分配空间: 第"</span> &lt;&lt; i &lt;&lt; <span class="string">"柱面 "</span>; <span class="comment">// 柱面号==字节号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; j / <span class="number">4</span> &lt;&lt; <span class="string">"磁道 "</span>; <span class="comment">// 磁道号==位数/4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; j % <span class="number">4</span> &lt;&lt; <span class="string">"物理记录"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 物理记录号==位数%4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"磁盘空间不足，分配失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 回收空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recover</span><span class="params">(<span class="keyword">int</span> bitmap[MAX_SIZE][MAX_SIZE])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cylinder, track, record; <span class="comment">// 柱面号，磁道号，物理记录号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入柱面号, 磁道号和物理记录号(用空格分隔): "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; cylinder &gt;&gt; track &gt;&gt; record;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(bitmap[cylinder][<span class="number">4</span>*track+record] == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"该空间未分配，回收失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"成功回收空间: 第"</span> &lt;&lt; cylinder &lt;&lt; <span class="string">"字节 第"</span>  &lt;&lt; <span class="number">4</span>*track+record &lt;&lt; <span class="string">"位"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        bitmap[cylinder][<span class="number">4</span>*track+record] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 显示位示图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bitmap</span><span class="params">(<span class="keyword">int</span> bitmap[MAX_SIZE][MAX_SIZE])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAX_SIZE; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;MAX_SIZE; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d"</span>, bitmap[i][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 用位示图管理磁盘存储空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitMap</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 位示图数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> bitmap[MAX_SIZE][MAX_SIZE];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 将bitmap全置为0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(bitmap, <span class="number">0</span>, <span class="keyword">sizeof</span>(bitmap));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 初始化位示图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    init_bitmap(bitmap);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 循环运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> order; <span class="comment">// 指令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入(a:分配, r:回收, s:显示, q:退出): "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"&gt; "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; order;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">switch</span>(order) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>: allocate(bitmap); <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>: recover(bitmap); <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>: show_bitmap(bitmap); <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'q'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"Bye"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">default</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入正确的指令!"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"**用位示图管理磁盘存储空间**"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    BitMap();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>.gitignore详解</title>
    <url>/2018/11/01/gitignore%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>.gitignore</strong>在<strong>Git</strong>中十分重要，一般每个<strong>Git项目</strong>都需要一个<strong>.gitignore</strong>文件，这个文件的作用就是告诉<strong>Git</strong>哪些文件<strong>不需要</strong>添加到版本管理中。</p>
<a id="more"></a>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>只需要在项目根目录下新建一个<strong>.gitignore</strong>文件，然后把要忽略的文件名填进去，<strong>Git</strong>就会自动忽略这些文件。在实际应用中，我们并不需要一一写<strong>.gitignore</strong>文件，<strong>GitHub</strong>已为我们准备了各种配置文件，我们只需<strong>按需组合</strong>。</p>
<p><strong>GitHub</strong>上的<strong>.gitignore</strong>配置文件：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，比如Java编译产生的<code>.class</code>文件；</li>
<li>忽略带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><p>看<code>git status</code>命令后是否输出：<code>working directory clean</code></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>检查规则是否正确：<strong>git check-ignore -v filename</strong></li>
<li>如果某文件无法添加到Git，可能是因为这个文件被<strong>.gitignore</strong>忽略了<ul>
<li>解决方案：<strong>git add -f filename</strong>（<strong>-f</strong> 强制添加）</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://uusama.com/542.html" target="_blank" rel="noopener">Git 忽略提交 .gitignore</a></li>
<li><a href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" rel="noopener">Git忽略提交规则 - .gitignore配置运维总结</a></li>
</ol>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：加速时间序列聚类的新策略</title>
    <url>/2018/11/01/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E5%8A%A0%E9%80%9F%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E8%81%9A%E7%B1%BB%E7%9A%84%E6%96%B0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>Accelerating Dynamic Time Warping Clustering with a Novel Admissible Pruning Strategy</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>本文提出了一种新的策略，来应对海量数据下DTW对时间序列的聚类问题。本文提出的新方法<strong>TADPole（Time-series Anytime DP）</strong>通过一种可接受的剪枝策略，避免昂贵的距离计算成本，从而加速聚类进程。</p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>对时间序列的聚类仍然在很多领域有重要应用价值，人们普遍认为DTW在大多数领域是最好的，几乎总是优于欧氏距离。然而有研究指出，面对海量数据，基于欧式距离的动态时间规整策略无法展现出其优越性，也就是说DTW对时间序列的有效聚类仍然是个挑战。因此本文创造性的提出一种新的策略，来加速时间序列聚类任务的进程。</p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><ol>
<li>扩充DP框架来解决大型时间序列的聚类问题</li>
<li>增加DP框架来解决大型时间序列聚类问题</li>
<li>结合DTW与上下限修剪策略，修剪不必要的计算，避免了昂贵的距离计算成本</li>
<li>用启发式算法来将不可避免的计算排序成一个最有效的优先顺序</li>
<li>可以很容易的扩展和应用到多元时间序列的聚类问题</li>
</ol>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><ol>
<li>计算数据集DTW距离的上下界矩阵</li>
<li>采用上下限修剪策略计算局部密度</li>
<li>用上下限修剪策略计算高密度样本的NN距离</li>
<li>结合DP算法完成聚类任务 </li>
<li>扩展到多元时间序列只需对所有维度的相应计算求和</li>
</ol>
<h3 id="优缺点与思考"><a href="#优缺点与思考" class="headerlink" title="优缺点与思考"></a>优缺点与思考</h3><p>本文提出的新策略是在DP聚类算法的基础上，扩展得到一个基于DTW和上下限修剪策略的DP聚类框架，目的就是应对海量的数据集，只将计算资源放在真正需要的过程中，有效节省了计算成本，同时也能很好地完成聚类任务。</p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：DP聚类算法</title>
    <url>/2018/11/01/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-DP%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Clustering by fast search and find of density peaks</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>本文提出了一种新型的基于密度的聚类算法，思路新颖、方法巧妙，能够实现对任意形状分布的数据进行聚类。</p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>传统基于距离的聚类算法仅仅局限于球面分布的数据聚类，为了实现对非球面数据、甚至对任意分布形状的数据聚类，密度聚类算法应用而生。密度聚类的典型代表DBSCAN算法能完成上述任务，但必须设定一个密度阈值来去除低于此密度阈值的噪音点。阈值的选取非常关键，甚至决定了聚类的成败，这增大了聚类的难度。本文提出的方法解决了该问题。</p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><ol>
<li>DP聚类核心思想：<strong>聚类簇中心被具有较低局部密度的邻居点包围，且与具有更高密度的任何点有相对较大的距离。</strong>这样我们仅需聚算两个量就能完成聚类：局部密度<strong>𝜌i</strong>和NN距离<strong>𝜹i</strong>。</li>
<li>用一种简单的方式衡量样本得分：<strong>𝛄i = 𝜌i * 𝜹i, i ∈ Is</strong>（需要对<strong>𝜌i</strong>和<strong>𝜹i</strong>归一化处理来消除数量级的干扰）</li>
</ol>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><ol>
<li>计算样本集两两之间的距离，构成距离矩阵</li>
<li>确定截断距离<strong>dc</strong>：选取一个<strong>dc</strong>，使样本平均近邻数约为总样本数的<strong>1%～2%</strong></li>
<li>计算局部密度<strong>𝜌i</strong>：可通过<strong>Cut-off kernel</strong>方法或者<strong>Gaussian kernel</strong>方法计算</li>
<li>计算NN距离<strong>𝜹i</strong>：样本<strong>i</strong>到任何比其局部密度<strong>𝜌i</strong>大的样本的距离的最小值<ul>
<li><strong>𝜹i = min（dij）, 𝜌j &gt; 𝜌i</strong></li>
<li><strong>𝜹i = max（dij）, 𝜌i = max（𝜌）</strong></li>
</ul>
</li>
<li>做出决策图（局部密度-距离图）和得分排序图</li>
<li>决定聚类簇的个数，得到聚类中心</li>
<li>依次对剩余样本完成聚类</li>
</ol>
<h3 id="优缺点及思考"><a href="#优缺点及思考" class="headerlink" title="优缺点及思考"></a>优缺点及思考</h3><p>本文提出的方法不仅能胜任任意形状数据分布的聚类任务，可以很好地描述数据分布，而且思路新颖，方法巧妙，在算法复杂度上也比一般的K-means算法低。同时该算法只考虑点与点之间的距离，不需要将点映射到一个向量空间中。该算法将非聚类中心点的聚类过程分离成一个单独的过程，使得聚类中心的选择和非聚类点的归类分离开来，增大了聚类精度。</p>
<p>2018.11.1</p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>DP聚类算法</title>
    <url>/2018/10/31/DP%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>DP聚类算法是<strong>Science</strong>上一篇文章提出的一种新型的基于密度的聚类算法，思路新颖、方法巧妙。</p>
<a id="more"></a>

<p>原文：<a href="http://science.sciencemag.org/content/344/6191/1492" target="_blank" rel="noopener"><strong>Clustering by Fast Search and Find of Density Peaks</strong></a><br>参考：<a href="https://www.cnblogs.com/nolonely/p/6964852.html" target="_blank" rel="noopener">一种新型聚类算法</a></p>
<h2 id="基本假设"><a href="#基本假设" class="headerlink" title="基本假设"></a>基本假设</h2><p><strong>聚类簇中心被具有较低局部密度的邻居点包围，且与具有更高密度的任何点有相对较大的距离。</strong></p>
<h2 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h2><ul>
<li>并不局限于球面类别的数据分布，可以对任意形状分布的数据进行聚类</li>
<li>相比于DBSCAN算法，DP算法不需要指定密度阈值</li>
</ul>
<h2 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h2><ol>
<li>局部密度<strong>𝜌i</strong>：可通过<strong>Cut-off kernel</strong>方法或者<strong>Gaussian kernel</strong>方法计算</li>
<li>NN距离<strong>𝜹i</strong>：样本<strong>i</strong>到任何比其局部密度<strong>𝜌i</strong>大的样本的距离的最小值</li>
</ol>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ol>
<li>计算样本集两两之间的距离矩阵</li>
<li>计算局部密度列表</li>
<li>计算NN距离列表</li>
<li>找出聚类中心</li>
<li>根据与聚类中心的距离标记其余样本</li>
</ol>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DP Algorithm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 用欧式距离计算样本集的距离矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：样本集x，类型为np.array</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_distance</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    size = len(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    distance = np.zeros(shape=(len(x), len(x)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size - <span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            distance[i][j] = np.sqrt(np.sum(np.power(x[i] - x[j], <span class="number">2</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            distance[j][i] = distance[i][j]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> distance</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 选择最优的截断距离dc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：距离矩阵distance，平均近邻百分比t（t=2表示平均每个样本的近邻样本数为样本总数的2%）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_dc</span><span class="params">(distance, t)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(distance[<span class="number">0</span>])):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(distance[<span class="number">0</span>])):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            temp.append(distance[i][j])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    temp.sort()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dc = temp[int(len(temp) * t / <span class="number">100</span>)]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> dc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 通过Cut-off kernel方法计算局部密度列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：距离矩阵distance，截断距离dc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_discrete_density</span><span class="params">(distance, dc)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    density = np.zeros(shape=len(distance))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> index, node <span class="keyword">in</span> enumerate(distance):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        density[index] = len(node[node &lt; dc])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> density</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 通过Gaussian kernel方法计算局部密度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Gaussian kernel方法：np.sum(np.exp(-(dist / dc) ** 2))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：距离矩阵distance，截断距离dc</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_continous_density</span><span class="params">(distance, dc)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    density = np.zeros(shape=len(distance))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> index, dist <span class="keyword">in</span> enumerate(distance):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        density[index] = np.sum(np.exp(-(dist / dc) ** <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> density</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算NN距离列表，找到聚类中心列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：密度列表density，距离矩阵distance</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dist_center</span><span class="params">(density, distance)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dist = np.zeros(shape=len(distance))  <span class="comment"># 距离列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    closest_leader = np.zeros(shape=len(distance), dtype=np.int32)  <span class="comment"># 聚类中心列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> index, node <span class="keyword">in</span> enumerate(distance):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 局部密度更大的样本列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        larger_density = np.squeeze(np.argwhere(density &gt; density[index]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 如果存在局部密度更大的样本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> larger_density.size != <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 局部密度更大样本与当前样本的距离列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            larger_distance = distance[index][larger_density]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 当前样本的距离为larger_distance中的最小值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            dist[index] = np.min(larger_distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 局部密度更大样本中与当前样本距离相等（最小值可能有多个）的样本集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            min_distance_sample = np.squeeze(np.argwhere(larger_distance == dist[index]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment"># 有多个局部密度更大且距离当前样本最近的样本时，选择第一个样本作为聚类中心</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> min_distance_sample.size &gt;= <span class="number">2</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                min_distance_sample = np.random.choice(a=min_distance_sample)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> larger_distance.size &gt; <span class="number">1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                closest_leader[index] = larger_density[min_distance_sample]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                closest_leader[index] = larger_density</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 如果没有局部密度更大的样本（当前样本局部密度最大）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dist[index] = np.max(distance)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            closest_leader[index] = index</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> dist, closest_leader</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 画原始数据分布图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：样本数据集x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_x</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(x)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        plt.scatter(x=x[j, <span class="number">0</span>], y=x[j, <span class="number">1</span>], marker=<span class="string">'o'</span>, c=<span class="string">'k'</span>, s=<span class="number">8</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.xlabel(<span class="string">'x'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.ylabel(<span class="string">'y'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.title(<span class="string">'Sample data'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 画密度-距离图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：局部密度列表density，距离列表dist，样本集x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_density_dist</span><span class="params">(density, dist, x)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.figure(num=<span class="number">1</span>, figsize=(<span class="number">15</span>, <span class="number">9</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        plt.scatter(x=density[i], y=dist[i], c=<span class="string">'k'</span>, marker=<span class="string">'o'</span>, s=<span class="number">15</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.xlabel(<span class="string">'Density'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.ylabel(<span class="string">'Distance'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.title(<span class="string">'Decision graph'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算得分：局部密度与距离的乘积，并画出得分排序图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：局部密度列表density，距离列表dist</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(density, dist)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 分别对局部密度和距离做归一化处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    normal_density = (density - np.min(density)) / (np.max(density) - np.min(density))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    normal_distance = (dist - np.min(dist)) / (np.max(dist) - np.min(dist))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 计算得分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    score = normal_density * normal_distance</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 画出决策图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.figure(num=<span class="number">2</span>, figsize=(<span class="number">15</span>, <span class="number">10</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.scatter(x=range(len(dist)), y=-np.sort(-score), c=<span class="string">'k'</span>, marker=<span class="string">'o'</span>, s=-np.sort(-score) * <span class="number">100</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.xlabel(<span class="string">'n'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.ylabel(<span class="string">'score'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.title(<span class="string">'Rank Score'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> score</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 完成聚类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：聚类中心cluster_centers，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clustering</span><span class="params">(cluster_centers, chose_list)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(cluster_centers)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> cluster_centers[i] <span class="keyword">not</span> <span class="keyword">in</span> chose_list:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            j = cluster_centers[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cluster_centers[i] = cluster_centers[j]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    C = cluster_centers[:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> C  <span class="comment"># C[i]表示第i点所属最终分类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 画聚类结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：聚类簇C，样本集x，聚类中心centers</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_cluster</span><span class="params">(C, x, centers)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    colors = [<span class="string">'b'</span>, <span class="string">'r'</span>, <span class="string">'c'</span>, <span class="string">'m'</span>, <span class="string">'g'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'w'</span>, <span class="string">'gold'</span>, <span class="string">'pink'</span>, <span class="string">'orange'</span>, <span class="string">'purple'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    center_color = &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    final = dict(collections.Counter(C)).keys()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> index, i <span class="keyword">in</span> enumerate(final):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        center_color[i] = index</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 画最终聚类图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.figure(num=<span class="number">3</span>, figsize=(<span class="number">15</span>, <span class="number">10</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i, categorie <span class="keyword">in</span> enumerate(C):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> centers:  <span class="comment"># 标出各个聚类簇的中心</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            plt.scatter(x=x[i, <span class="number">0</span>], y=x[i, <span class="number">1</span>], marker=<span class="string">'s'</span>, s=<span class="number">100</span>, c=<span class="string">'K'</span>, alpha=<span class="number">0.8</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            plt.scatter(x=x[i, <span class="number">0</span>], y=x[i, <span class="number">1</span>], c=colors[center_color[categorie]], s=<span class="number">5</span>, marker=<span class="string">'h'</span>, alpha=<span class="number">0.66</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.title(<span class="string">'Cluster Result'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    plt.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># dp聚类算法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：样本数据集X</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(X)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    t = <span class="number">1.1</span>  <span class="comment"># 样本集大小的百分比：1.1%</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    distance = get_distance(X)  <span class="comment"># 样本的距离矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dc = choose_dc(distance, t)  <span class="comment"># 最优截断距离dc（根据t）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    density = get_continous_density(distance, dc)  <span class="comment"># 局部密度列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dist, cluster_center = get_dist_center(density, distance)  <span class="comment"># 得到距离列表和聚类中心列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    draw_x(X)  <span class="comment"># 画样本数据分布图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    draw_density_dist(density, dist, X)  <span class="comment"># 画密度-距离图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    scores = get_score(density, dist)  <span class="comment"># 计算局部密度与距离的乘积，并画出得分排序图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cluster_num = int(input(<span class="string">'Input clusters num: '</span>))  <span class="comment"># 看图决定最终的聚类簇数目</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    centers = np.argsort(-scores)[: cluster_num]  <span class="comment"># 得分最高的前cluster_num个作为最终聚类中心</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C = clustering(cluster_center, centers)  <span class="comment"># 完成所有点的聚类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    draw_cluster(C, X, centers)  <span class="comment"># 画出聚类结果图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    data = <span class="string">r'./x_train.txt'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    X = np.loadtxt(data, delimiter=<span class="string">' '</span>, usecols=[<span class="number">0</span>, <span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp(X)  <span class="comment"># DP聚类</span></span></pre></td></tr></table></figure>

<h2 id="聚类结果"><a href="#聚类结果" class="headerlink" title="聚类结果"></a>聚类结果</h2><p><img src="/assets/blogimg/dp.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP网络编程实例</title>
    <url>/2018/10/30/UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>Linux网络编程：UDP网络编程实例。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Linux系统下，采用C语言编写一个UDP服务器程序和一个UDP客户端程序。客户端向服务器发送字符串后，服务器能把该字符串返回给客户端，客户端再把字符串显示出来。如果客户端向服务器端发送<strong>GetTime</strong>字符串时，客户机端能接收并显示当前服务器端的系统时间。</p>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="什么是UDP协议"><a href="#什么是UDP协议" class="headerlink" title="什么是UDP协议"></a>什么是UDP协议</h3><ul>
<li><p>UDP（User Datagram Protocol），即用户数据报协议，是一种面向非连接的协议。面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。至于对方是否可以接收到这些数据内容，UDP协议无法控制，因此UDP协议是一种不可靠的协议。</p>
</li>
<li><p>UDP适用于一次只传送少量数据、对可靠性要求不高的应用和环境。由于没有建立连接的过程，所以它的通信效率高。使用UDP传输，需要发送端和接收端。</p>
</li>
<li><p>UDP特点：无连接的，不可靠的，数据报包小于等于64k，效率高。</p>
</li>
</ul>
<h3 id="UDP编程框架"><a href="#UDP编程框架" class="headerlink" title="UDP编程框架"></a>UDP编程框架</h3><p>UDP网络编程可以分为客户端和服务器端两部分。服务器端主要包含建立套接字、将套接字与地址结构进行绑定、读写数据、关闭套接字几个过程。客户端包括建立套接字、读写数据、关闭套接字几个过程。服务器端和客户端两个流程之间的主要差别在于对地址的绑定（bind()）函数，客户端可以不用进行地址和端口的绑定操作。</p>
<p><img src="/assets/blogimg/udp.jpeg" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udp.h</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span></pre></td></tr></table></figure>



<h3 id="服务器端程序"><a href="#服务器端程序" class="headerlink" title="服务器端程序"></a>服务器端程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udp_server.c</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udp.h"</span>	<span class="comment">// UDP编程所需头文件</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80	<span class="comment">// 数据缓冲区大小</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000	<span class="comment">// 服务器端口</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> data_buf[MAXLINE]; <span class="comment">// 数据缓冲区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">// socket()建立套接字文件描述符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span> <span class="comment">// 服务端网络地址结构信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span> <span class="comment">// 存放数据发送方的地址信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">socklen_t</span> client_address_len; <span class="comment">// client_address所指内容的长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bzero(&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_family = AF_INET; <span class="comment">// 地址类型为AF_INET</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// 任意本地地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_port = htons(SERV_PORT); <span class="comment">// 服务器端口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    bind(sockfd, (struct sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address)); <span class="comment">// bind()函数绑定侦听端口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepting connections ...\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        client_address_len = <span class="keyword">sizeof</span>(client_address);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// recvfrom()函数接收客户端的网络数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> n = recvfrom(sockfd, data_buf, MAXLINE, <span class="number">0</span>, (struct sockaddr *)&amp;client_address, &amp;client_address_len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            perror(<span class="string">"Recvfrom error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Received from %s at PORT %d\n"</span>, inet_ntop(AF_INET, &amp;client_address.sin_addr, str, <span class="keyword">sizeof</span>(str)), ntohs(client_address.sin_port));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 如果需要获取时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> Get[MAXLINE] = <span class="string">"GetTime"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(data_buf[i] == Get[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> flag = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">time_t</span> times = time(<span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">utcTime</span> = <span class="title">gmtime</span>(&amp;<span class="title">times</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">sprintf</span>(data_buf, <span class="string">"%04d.%02d.%02d %02d:%02d:%02d\n"</span>, utcTime-&gt;tm_year+<span class="number">1900</span>, utcTime-&gt;tm_mon+<span class="number">1</span>, utcTime-&gt;tm_mday, utcTime-&gt;tm_hour+<span class="number">8</span>, utcTime-&gt;tm_min, utcTime-&gt;tm_sec);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            n = <span class="keyword">sizeof</span>(data_buf);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// sendto()函数向服务器主机发送数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        n = sendto(sockfd, data_buf, n, <span class="number">0</span>, (struct sockaddr*)&amp;client_address, <span class="keyword">sizeof</span>(client_address));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            perror(<span class="string">"Sendto error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udp_client.c</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udp.h"</span> <span class="comment">// UDP编程所需头文件</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80 <span class="comment">// 数据缓冲区大小</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000 <span class="comment">// 服务器端口</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sockfd = sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">// Socket()函数建立套接字文件描述符 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span> <span class="comment">// 服务端网络地址结构信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">socklen_t</span> server_address_len; <span class="comment">// server_address所指内容的长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> data_buf[MAXLINE]; <span class="comment">// 数据缓冲区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> str[INET_ADDRSTRLEN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bzero(&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_family = AF_INET; <span class="comment">// 地址类型为AF_INET</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;server_address.sin_addr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_port = htons(SERV_PORT); <span class="comment">// 服务器端口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (fgets(data_buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// sendto()向服务器发送数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> n = sendto(sockfd, data_buf, <span class="built_in">strlen</span>(data_buf), <span class="number">0</span>, (struct sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            perror(<span class="string">"Sendto error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// recvfrom()接收服务器的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        n = recvfrom(sockfd, data_buf, MAXLINE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            perror(<span class="string">"Recvfrom error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, data_buf, n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 关闭套接字</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">close</span>(sockfd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><h3 id="编译并运行服务器端程序"><a href="#编译并运行服务器端程序" class="headerlink" title="编译并运行服务器端程序"></a>编译并运行服务器端程序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o udp_server udp_server.c</span></pre></td></tr><tr><td class="code"><pre><span class="line">./udp_server</span></pre></td></tr></table></figure>

<h3 id="编译并运行客户端程序"><a href="#编译并运行客户端程序" class="headerlink" title="编译并运行客户端程序"></a>编译并运行客户端程序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o udp_client udp_client.c</span></pre></td></tr><tr><td class="code"><pre><span class="line">./udp_client</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP网络编程实例</title>
    <url>/2018/10/30/TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>Linux网络编程：TCP网络编程实例。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Linux系统下，采用C语言编写一个TCP服务器程序和一个TCP客户端程序。客户端向服务器发送字符串后，服务器能把该字符串返回给客户端，客户端再把字符串显示出来。服务器采用<strong>多进程并发服务的方式，保证多个客户连接到该服务器</strong>。如果客户端向服务器端发送<strong>GetTime</strong>字符串时，客户机端能接收并显示当前服务器端的系统时间。</p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="什么是TCP协议"><a href="#什么是TCP协议" class="headerlink" title="什么是TCP协议"></a>什么是TCP协议</h3><ul>
<li><a href="https://www.wikiwand.com/zh/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">TCP传输控制协议-维基百科</a></li>
<li><a href="https://baike.baidu.com/item/TCP/33012?fr=aladdin" target="_blank" rel="noopener">TCP传输控制协议-百度百科</a></li>
</ul>
<h3 id="TCP编程框架"><a href="#TCP编程框架" class="headerlink" title="TCP编程框架"></a>TCP编程框架</h3><p><img src="/assets/blogimg/tcp.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tcp.h</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span></pre></td></tr></table></figure>

<h3 id="服务器端程序"><a href="#服务器端程序" class="headerlink" title="服务器端程序"></a>服务器端程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tcp_server</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"tcp.h"</span> <span class="comment">// TCP编程所需头文件</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">"127.0.0.1"</span> <span class="comment">// 服务器IP</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000	<span class="comment">// 服务器端口</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LISTEN 5 <span class="comment">// 最大连接客户程序数</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 200	<span class="comment">// 数据缓冲区大小</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 多进程并发服务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server_process</span><span class="params">(<span class="keyword">int</span> conn_fd)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> recv_num, send_num; <span class="comment">// 收发字节数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> recv_buf[MAXLINE], send_buf[MAXLINE]; <span class="comment">// 收发数据缓冲区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> pid = getpid(); <span class="comment">// 当前进程号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nService for client %d has started.\n"</span>, pid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        recv_num = recv(conn_fd, recv_buf, <span class="keyword">sizeof</span>(recv_buf), <span class="number">0</span>); <span class="comment">// 接收客户端的网络数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(recv_num &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">close</span>(conn_fd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        recv_buf[recv_num] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child process %d received: %s\n"</span>, pid, recv_buf);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(recv_buf,<span class="string">"quit"</span>) == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child process %d quit.\n"</span>, pid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">strcpy</span>(send_buf, recv_buf);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 如果需要获取时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> Get[MAXLINE] = <span class="string">"GetTime"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(send_buf[i] == Get[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> flag = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">time_t</span> times = time(<span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">utcTime</span> = <span class="title">gmtime</span>(&amp;<span class="title">times</span>);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">sprintf</span>(send_buf, <span class="string">"%04d.%02d.%02d %02d:%02d:%02d"</span>, utcTime-&gt;tm_year+<span class="number">1900</span>, utcTime-&gt;tm_mon+<span class="number">1</span>, utcTime-&gt;tm_mday, utcTime-&gt;tm_hour+<span class="number">8</span>, utcTime-&gt;tm_min, utcTime-&gt;tm_sec);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        send_num = send(conn_fd, send_buf, <span class="built_in">strlen</span>(send_buf), <span class="number">0</span>); <span class="comment">// 向客户端主机发送数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(send_num &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">close</span>(conn_fd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child process %d sent: %s\n"</span>, pid, send_buf);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">close</span>(conn_fd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">pid_t</span> pid; <span class="comment">// 进程号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> conn_fd; <span class="comment">// 接收的套接字文件描述符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 建立套接字文件描述符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(sock_fd &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        perror(<span class="string">"Create socket failed"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span> <span class="comment">// 存放数据发送方的地址信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">socklen_t</span> client_size = <span class="keyword">sizeof</span>(client_address); <span class="comment">// client_address所指内容的长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span> <span class="comment">// 服务端网络地址结构信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(&amp;server_address, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_address));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_family = AF_INET; <span class="comment">// 地址类型为AF_INET</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_port = htons(SERVER_PORT); <span class="comment">// 服务器端口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_addr.s_addr = inet_addr(SERVER_IP); <span class="comment">// 服务器地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(bind(sock_fd, (struct sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) &#123; <span class="comment">// 绑定侦听端口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        perror(<span class="string">"Bind error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sock_fd, MAX_LISTEN) &lt; <span class="number">0</span>) &#123; <span class="comment">// 开始监听(参数: 服务器的套接字, 连接等待队列的最大数目)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        perror(<span class="string">"Listen failed"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        conn_fd = accept(sock_fd, (struct sockaddr *)&amp;client_address, &amp;client_size); <span class="comment">// 开始接收客户端的连接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(conn_fd &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            perror(<span class="string">"Accept failed"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pid = fork(); <span class="comment">// 创建子进程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">// 当前是子进程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">close</span>(sock_fd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            server_process(conn_fd); <span class="comment">// 该子进程服务客户请求conn_fd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>   <span class="built_in">close</span>(conn_fd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">close</span>(sock_fd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tcp_client</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"tcp.h"</span> <span class="comment">// TCP编程所需头文件</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_IP <span class="meta-string">"127.0.0.1"</span> <span class="comment">// 服务器地址</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 8000 <span class="comment">// 服务器端口</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 200	<span class="comment">// 数据缓冲区大小</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sock_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 建立套接字文件描述符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(sock_fd &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        perror(<span class="string">"create socket failed"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span> <span class="comment">// 服务器网络地址结构信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(&amp;server_address, <span class="number">0</span> ,<span class="keyword">sizeof</span>(server_address));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_family = AF_INET; <span class="comment">// 地址类型为AF_INET</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_port = htons(SERVER_PORT); <span class="comment">// 服务器端口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    server_address.sin_addr.s_addr = inet_addr(SERVER_IP); <span class="comment">// 服务器地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock_fd, (struct sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) &#123; <span class="comment">// 把socket套接字连上服务端</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        perror(<span class="string">"Connect failed"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> recv_num, send_num; <span class="comment">// 收发字节数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> recv_buf[MAXLINE], send_buf[MAXLINE]; <span class="comment">// 收发数据缓冲区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, send_buf);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        send_num = send(sock_fd, send_buf, <span class="built_in">strlen</span>(send_buf), <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(send_num &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            perror(<span class="string">"Send error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        recv_num = recv(sock_fd, recv_buf, <span class="keyword">sizeof</span>(recv_buf), <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(recv_num &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            perror(<span class="string">"Receive error"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        recv_buf[recv_num] = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, recv_buf);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">close</span>(sock_fd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><h3 id="编译并运行服务器端程序"><a href="#编译并运行服务器端程序" class="headerlink" title="编译并运行服务器端程序"></a>编译并运行服务器端程序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o tcp_server tcp_server.c</span></pre></td></tr><tr><td class="code"><pre><span class="line">./tcp_server</span></pre></td></tr></table></figure>

<h3 id="编译并运行（多个）客户端程序"><a href="#编译并运行（多个）客户端程序" class="headerlink" title="编译并运行（多个）客户端程序"></a>编译并运行（多个）客户端程序</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o tcp_client tcp_client.c</span></pre></td></tr><tr><td class="code"><pre><span class="line">./tcp_client</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>利用fork()系统调用创建进程</title>
    <url>/2018/10/30/%E5%88%A9%E7%94%A8fork-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>操作系统进程相关：利用fork()系统调用创建进程。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>编制一段程序，使用系统调用fork( )创建两个子进程，这样在此程序运行时，系统中就有一个父进程和两个子进程在活动。每一个进程在屏幕上显示一个字符，父进程显示字符 A ，子进程分别显示 B 和 C 。试观察、记录并分析屏幕上进程调度的情况。</p>
<h2 id="fork-函数"><a href="#fork-函数" class="headerlink" title="fork()函数"></a>fork()函数</h2><ol>
<li>系统调用格式：<code>pid = fork();</code> , fork() 返回值：<ul>
<li>=0：当前进程是子进程</li>
<li>&gt;0：当前进程是父进程，返回值为子进程的pid值</li>
<li>-1：进程创建失败</li>
</ul>
</li>
<li>如果 fork() 调用成功，它向父进程返回子进程的pid，并向子进程返回0，即 fork() 被调用了一次，但返回了两次。此时OS在内存中建立一个新进程，所建的新进程是调用 fork() 父进程的副本，称为子进程。子进程继承了父进程的许多特性，并具有与父进程完全相同的用户级上下文，父进程与子进程并发执行。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">pid_t</span> pid1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pid1 = fork();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(pid1 == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        perror(<span class="string">"Fail to fork!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid1 == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"B\tCurrent Process Pid: %d\tParent Process Pid: %d\n"</span>, getpid(), getppid());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">pid_t</span> pid2 = fork();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(pid2 == <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            perror(<span class="string">"Fail to fork!\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(pid2 == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"C\tCurrent Process Pid: %d\tParent Process Pid: %d\n"</span>, getpid(), getppid());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wait(<span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"A\tCurrent Process Pid: %d\n"</span>, getpid());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>一个fork()调用的例子</title>
    <url>/2018/10/30/%E4%B8%80%E4%B8%AAfork-%E8%B0%83%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>操作系统进程相关：一个fork()调用的例子。</p>
<a id="more"></a>

<h2 id="调用fork-函数创建进程"><a href="#调用fork-函数创建进程" class="headerlink" title="调用fork()函数创建进程"></a>调用fork()函数创建进程</h2><p>程序 a 创建子进程，在子进程中输出自己的学号，并在子进程、父进程中分别输出当前被调度执行的进程pid，ppid。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Linux 程序a</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> pid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pid = fork();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fork failed.\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"2016xxxxxxxxx\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child's pid=%d\n"</span>, getpid());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child's ppid=%d\n"</span>, getppid());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        wait();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent's pid=%d\n"</span>, getpid());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parent's ppid=%d\n"</span>, getppid());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="调用exec系函数执行其他可执行文件"><a href="#调用exec系函数执行其他可执行文件" class="headerlink" title="调用exec系函数执行其他可执行文件"></a>调用exec系函数执行其他可执行文件</h2><p>程序 b 在创建的子进程中调用exec系函数，执行前一个要求中生成的程序即a.exe，也可选择其它可执行文件作为exec函数的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Linux 程序b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> **environ)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> pid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pid = fork();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fork failed.\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Call another program a.out.\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        execve(<span class="string">"a.out"</span>, argv, environ);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>首次适应算法实现主存分配和回收</title>
    <url>/2018/10/29/%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>操作系统内存相关：首次适应算法实现主存分配和回收。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>可变分区方式是按作业需要的主存空间大小来分割分区的。当要装入一个作业时，根据作业需要的主存容量查看是否有足够的空闲空间，若有，则按需分配，否则，作业无法装入。</li>
<li>假定内存大小为128K，空闲区说明表格式为：<ul>
<li>分区号（表示是第几个空闲分区）</li>
<li>起始地址（指出空闲区的起始地址）</li>
<li>长度（一个连续空闲区的长度）</li>
</ul>
</li>
<li>采用首次适应算法分配回收内存空间。运行时，输入一系列分配请求和回收请求。</li>
</ol>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>要求能接受来自键盘的空间申请及释放请求，能显示分区分配及回收后的内存布局情况。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="方法一：使用二叉树存储空闲区说明表"><a href="#方法一：使用二叉树存储空闲区说明表" class="headerlink" title="方法一：使用二叉树存储空闲区说明表"></a>方法一：使用二叉树存储空闲区说明表</h3><ul>
<li>节点结构为：<ul>
<li><code>address</code> ：首地址</li>
<li><code>length</code>：分区长度</li>
<li><code>state</code>：状态（F：空闲，B：忙碌，P：左右孩子节点的父节点）</li>
<li><code>homework</code>：作业号（-1表示没有作业装入）</li>
<li><code>*lchild</code>：左孩子（Busy状态）</li>
<li><code>*rchild</code>：右孩子（Free状态）</li>
</ul>
</li>
<li>最开始只有一个根节点</li>
<li>每次作业装入都是将一个节点划分为左右孩子，左孩子装入作业，右孩子为剩余空间</li>
<li>每次卸载作业只需找到该作业将其 <code>state</code> 改为 <code>F</code></li>
<li>每次卸载作业成功后合并相邻空闲分区</li>
<li>打印空闲区说明表时只打印度为0的节点，这才是真正的表项</li>
<li><strong>待优化：因为二叉树结构的特殊性，本程序无法合并不同深度的相邻空闲节点</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">// 装入一个作业时赋值为1，用来判断是否成功装入作业</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">// 卸载一个作业时赋值为1，用来判断是否成功卸载作业</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 空闲区说明表结构体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> address;		<span class="comment">// 首地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> length;			<span class="comment">// 长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> state;			<span class="comment">// 状态（F：空闲，B：忙碌，P：左右孩子节点的父节点）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> homework;		<span class="comment">// 作业号(-1表示没有作业装入)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>;</span>	<span class="comment">// 左孩子（Busy状态）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rchild</span>;</span>	<span class="comment">// 右孩子（Free状态）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;TNode;		  		<span class="comment">// 空闲区说明表节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化空闲区说明表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_table</span><span class="params">(TNode *p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;address = <span class="number">0</span>;	<span class="comment">// 从0开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;length = <span class="number">128</span>;	<span class="comment">// 大小为128K</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;state = <span class="string">'F'</span>;	<span class="comment">// 空闲</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;homework = <span class="number">-1</span>;	<span class="comment">// 没有作业装入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;lchild = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;rchild = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*首地址为0，大小为128K的内存空间已初始化完成*"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 打印空闲区说明表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_item</span><span class="params">(TNode *p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;address &lt;&lt; <span class="string">"\t"</span> &lt;&lt; p-&gt;length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p-&gt;state == <span class="string">'F'</span>)		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tFree"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tBusy"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p-&gt;homework != <span class="number">-1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; p-&gt;homework;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"\tnull"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 采用二叉树的先序遍历打印空闲区说明表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_table</span><span class="params">(TNode *p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!p-&gt;lchild &amp;&amp; !p-&gt;rchild &amp;&amp; p-&gt;length!=<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            show_item(p); <span class="comment">// 度为0的节点才是一个表项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        show_table(p-&gt;lchild);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        show_table(p-&gt;rchild);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 采用二叉树的后序遍历合并相邻空闲区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 因为二叉树结构的特殊性，只能合并处于同一深度的空闲分区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_table</span><span class="params">(TNode *p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        merge_table(p-&gt;lchild);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        merge_table(p-&gt;rchild);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p-&gt;lchild &amp;&amp; p-&gt;rchild &amp;&amp; p-&gt;lchild-&gt;state==<span class="string">'F'</span> &amp;&amp; p-&gt;rchild-&gt;state==<span class="string">'F'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;state = <span class="string">'F'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;homework = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;address = p-&gt;lchild-&gt;address;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;length = p-&gt;lchild-&gt;length + p-&gt;rchild-&gt;length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;lchild = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;rchild = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 装入新作业</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：空闲区说明表，作业号，作业长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_homework</span><span class="params">(TNode *p, <span class="keyword">int</span> work, <span class="keyword">int</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 当改节点：空闲 + 足够大 + 是一个表项 时，才能装入新作业</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p-&gt;state==<span class="string">'F'</span> &amp;&amp; len&lt;=p-&gt;length &amp;&amp; !p-&gt;lchild &amp;&amp; !p-&gt;rchild &amp;&amp; flag==<span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TNode *left = <span class="keyword">new</span> TNode;  <span class="comment">// 左孩子装入作业</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            TNode *right = <span class="keyword">new</span> TNode; <span class="comment">// 右孩子为剩余空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 设置左孩子节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            left-&gt;homework = work;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            left-&gt;address = p-&gt;address;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            left-&gt;length = len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            left-&gt;state = <span class="string">'B'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            left-&gt;lchild = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            left-&gt;rchild = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 设置右孩子节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            right-&gt;homework = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            right-&gt;address = left-&gt;address + len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            right-&gt;length = p-&gt;length - left-&gt;length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            right-&gt;state = <span class="string">'F'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            right-&gt;lchild = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            right-&gt;rchild = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 设置p节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;state = <span class="string">'P'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;lchild = left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;rchild = right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            flag = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            insert_homework(p-&gt;lchild, work, len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            insert_homework(p-&gt;rchild, work, len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 卸载作业</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：空闲区说明表，作业号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_homework</span><span class="params">(TNode *p, <span class="keyword">int</span> work)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p-&gt;homework == work) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;homework = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;state = <span class="string">'F'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            temp = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            delete_homework(p-&gt;lchild, work);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            delete_homework(p-&gt;rchild, work);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 可变分区管理方式下采用首次适应算法实现主存分配和回收</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">First_Fit</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 初始化空闲区说明表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    TNode *p = <span class="keyword">new</span> TNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    init_table(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 打印初始空闲区说明表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*初始化空闲区说明表*"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"首地址\t长度\t状态\t作业号"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    show_table(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 作业信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> how; <span class="comment">// 作业装入或卸载命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> no;   <span class="comment">// 作业号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> len;  <span class="comment">// 作业长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 响应来自键盘的作业装入和卸载请求</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*指令格式：装入/卸载 作业号 [作业长度]（如：n 1 20 / d 1)，输入'#'结束*"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*请输入："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; how;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(how != <span class="string">'#'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; no;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(how == <span class="string">'n'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            flag = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            	insert_homework(p, no, len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            	<span class="keyword">if</span>(flag == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"装入作业"</span> &lt;&lt; no &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"首地址\t长度\t状态\t作业号"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    show_table(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            	&#125;<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"空间不足，装入失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"作业所需空间大小需为正数！"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(how == <span class="string">'d'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            temp = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            delete_homework(p, no);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(temp == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                merge_table(p); <span class="comment">// 合并空闲分区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"卸载作业"</span> &lt;&lt; no &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"首地址\t长度\t状态\t作业号"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                show_table(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"作业不存在，卸载失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"指令格式错误，请重新输入！"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"*请输入："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; how;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"**可变分区管理方式下采用首次适应算法实现主存分配和回收**"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    First_Fit();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h3 id="方法二：使用单链表存储空闲区说明表"><a href="#方法二：使用单链表存储空闲区说明表" class="headerlink" title="方法二：使用单链表存储空闲区说明表"></a>方法二：使用单链表存储空闲区说明表</h3><ul>
<li>节点结构为：<ul>
<li><code>address</code> ：首地址</li>
<li><code>length</code>：分区长度</li>
<li><code>state</code>：状态（F：空闲，B：忙碌）</li>
<li><code>homework</code>：作业号（-1表示没有作业装入）</li>
<li><code>*next</code>：后继节点</li>
</ul>
</li>
<li>每次装入作业时：<ul>
<li>该空闲区大小和作业大小相等，直接将作业信息赋给当前分区节点</li>
<li>否则，装入作业当前节点，新建一个节点作为剩余空间节点</li>
</ul>
</li>
<li>每次卸载作业只需找到该作业将其 <code>state</code> 改为 <code>F</code></li>
<li>每次卸载作业成功后合并相邻空闲分区</li>
<li><strong>本方法克服了方法一的不足，能够实现任意相邻空闲分区的合并</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 空闲区说明表结构体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> address;		<span class="comment">// 首地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> length;			<span class="comment">// 长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> state;			<span class="comment">// 状态（F：空闲，B：忙碌）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> homework;		<span class="comment">// 作业号(-1表示没有作业装入)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>		<span class="comment">// 后继节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;TNode;		  		<span class="comment">// 空闲区说明表节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化空闲区说明表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_table</span><span class="params">(TNode *p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;address = <span class="number">0</span>;	<span class="comment">// 从0开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;length = <span class="number">128</span>;	<span class="comment">// 大小为128K</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;state = <span class="string">'F'</span>;	<span class="comment">// 空闲</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;homework = <span class="number">-1</span>;	<span class="comment">// 没有作业装入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*首地址为0，大小为128K的内存空间已初始化完成*"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 打印空闲区说明表节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_item</span><span class="params">(TNode *p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; p-&gt;address &lt;&lt; <span class="string">"\t"</span> &lt;&lt; p-&gt;length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p-&gt;state == <span class="string">'F'</span>)		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tFree"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tBusy"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p-&gt;homework != <span class="number">-1</span>)	<span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; p-&gt;homework;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"\tnull"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 打印空闲区说明表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_table</span><span class="params">(TNode *p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        show_item(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 装入新作业</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：空闲区说明表，作业号，作业长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值：true装入成功，false装入失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_homework</span><span class="params">(TNode *p, <span class="keyword">int</span> work, <span class="keyword">int</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 当改节点：空闲 + 足够大 + 是一个表项 时，才能装入新作业</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p-&gt;state==<span class="string">'F'</span> &amp;&amp; len&lt;=p-&gt;length) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(len == p-&gt;length) &#123; <span class="comment">// 作业完全填充该表项，没有剩余空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                p-&gt;homework = work;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p-&gt;state = <span class="string">'B'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 新表项表示装入作业后的剩余空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                TNode *q = <span class="keyword">new</span> TNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                q-&gt;address = p-&gt;address + len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                q-&gt;state = <span class="string">'F'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                q-&gt;homework = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                q-&gt;length = p-&gt;length - len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 作业装入当前表项的前len长度的空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                p-&gt;state = <span class="string">'B'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p-&gt;homework = work;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p-&gt;length = len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 链接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                q-&gt;next = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p-&gt;next = q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 合并相邻空闲区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_table</span><span class="params">(TNode *p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p-&gt;state == <span class="string">'F'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;state==<span class="string">'F'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                TNode *q = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p-&gt;length += q-&gt;length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p-&gt;next = q-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">free</span>(q);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;next &amp;&amp; p-&gt;next-&gt;state==<span class="string">'B'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p = p-&gt;next-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 卸载作业</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：空闲区说明表，作业号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值：true卸载成功，false卸载失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_homework</span><span class="params">(TNode *p, <span class="keyword">int</span> work)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p-&gt;homework == work) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;homework = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;state = <span class="string">'F'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 可变分区管理方式下采用首次适应算法实现主存分配和回收</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">First_Fit</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 初始化空闲区说明表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    TNode *p = <span class="keyword">new</span> TNode;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    init_table(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 打印初始空闲区说明表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*初始化空闲区说明表*"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"首地址\t长度\t状态\t作业号"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    show_table(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 作业信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> how; <span class="comment">// 作业装入或卸载命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> no;   <span class="comment">// 作业号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> len;  <span class="comment">// 作业长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 响应来自键盘的作业装入和卸载请求</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*指令格式：装入/卸载 作业号 [作业长度]（如：n 1 20 / d 1)，输入'#'结束*"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*请输入："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; how;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(how != <span class="string">'#'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; no;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(how == <span class="string">'n'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">bool</span> flag = insert_homework(p, no, len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(flag == <span class="literal">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"装入作业"</span> &lt;&lt; no &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"首地址\t长度\t状态\t作业号"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    show_table(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"空间不足，装入失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"作业所需空间大小需为正数！"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(how == <span class="string">'d'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">bool</span> flag = delete_homework(p, no);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                merge_table(p); <span class="comment">// 合并空闲分区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"卸载作业"</span> &lt;&lt; no &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"首地址\t长度\t状态\t作业号"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                show_table(p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"作业不存在，卸载失败！"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"指令格式错误，请重新输入！"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"*请输入："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; how;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"**可变分区管理方式下采用首次适应算法实现主存分配和回收**"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    First_Fit();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="程序中的命令格式"><a href="#程序中的命令格式" class="headerlink" title="程序中的命令格式"></a>程序中的命令格式</h3><ul>
<li>装入作业：n 作业号 作业长度，如：<ul>
<li>n 1 20</li>
<li>n 2 50</li>
</ul>
</li>
<li>卸载作业：d 作业号，如：<ul>
<li>d 2</li>
<li>d 1</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>时间片轮转调度算法</title>
    <url>/2018/10/28/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>操作系统进程相关：时间片轮转调度算法。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>假定系统有5个进程，每个进程用一个PCB来代表。PCB的结构为：<ul>
<li>进程名（如Q1~Q5）</li>
<li>指针（按优先数大小把进程连成队列，用指针指出下一个进程PCB的首地址）</li>
<li>要求运行时间（假设进程需要运行的单位时间数）</li>
<li>已运行时间（进程已运行的时间单位数，初始值为0）</li>
<li>状态（假设两种状态：就绪和结束，用R表示就绪，用E表示结束。初始状态都为就绪状态）</li>
</ul>
</li>
<li>运行之前，为每个进程确定它的“要求运行时间”。通过键盘输入这些参数。</li>
<li>把5个进程按顺序排成循环队列，用指针指出队列连接情况。用一个标志单元记录轮到运行的进程。处理器调度总是选择标志单元指示的进程运行，对所指的进程，将其“已运行时间”加1。</li>
<li>进程运行一次后，若“要求运行时间”等于“已运行时间”，则将状态改为“结束”，退出队列，否则继续。</li>
<li>若就绪队列为空，结束，否则转到 3 重复。</li>
</ol>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>能接受键盘输入的进程优先数及要求运行时间，能显示每次进程调度的情况，如哪个进程在运行，哪些进程就绪，就绪进程的排列情况。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 进程控制块PCB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PNode</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];       <span class="comment">// 进程名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一节点的指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> All_time;        <span class="comment">// 总运行时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> Run_Time;        <span class="comment">// 已运行时间(初始都为0)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">char</span> state;          <span class="comment">// 进程状态（R：就绪，E：结束）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; *Proc;                 <span class="comment">// 指向该PCB的指针</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化就绪队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_pcb</span><span class="params">(Proc &amp;P, <span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> Num = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    P = (Proc)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PNode));   <span class="comment">// 进程队列头结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    P-&gt;next = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Proc p = P;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请依次输入进程信息："</span>&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(Num--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next = (Proc)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PNode));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"进程名，总运行时间："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; p-&gt;name &gt;&gt; p-&gt;All_time;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;Run_Time = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;state = <span class="string">'R'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    p-&gt;next = P-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 输出运行中的进程信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(Proc P)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Proc p = P-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">do</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p-&gt;state != <span class="string">'E'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"进程名:"</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">"\t总运行时间:"</span> &lt;&lt; p-&gt;All_time;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t已运行时间"</span> &lt;&lt; p-&gt;Run_Time &lt;&lt; <span class="string">"\t状态:"</span> &lt;&lt; p-&gt;state &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">while</span>(p != P-&gt;next); </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 时间片轮转法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Round_Robin</span><span class="params">(Proc &amp;P, <span class="keyword">int</span> n, <span class="keyword">int</span> timeslice)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> round = <span class="number">0</span>;    <span class="comment">// 轮转数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Proc p = P-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (p-&gt;All_time &gt; p-&gt;Run_Time) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        round++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Round"</span> &lt;&lt; round &lt;&lt; <span class="string">"--正在运行"</span> &lt;&lt; <span class="string">"进程"</span> &lt;&lt; p-&gt;name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p-&gt;All_time - p-&gt;Run_Time &lt;= timeslice) <span class="comment">// 还需要的时间小于时间片大小时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;Run_Time = p-&gt;All_time;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>	p-&gt;Run_Time += timeslice;	<span class="comment">// 更新已运行的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        show_info(P);         <span class="comment">// 展示此时就绪队列的进程信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p-&gt;All_time == p-&gt;Run_Time) &#123; <span class="comment">// 该进程结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            p-&gt;state = <span class="string">'E'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            n--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">"进程运行结束，删除！\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = p-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(n &amp;&amp; p-&gt;All_time == p-&gt;Run_Time)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p = p-&gt;next;      <span class="comment">// 跳过已结束的进程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, timeslice; <span class="comment">// 总进程数，时间片大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"**时间片轮转调度算法**"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入总进程个数："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入时间片大小："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; timeslice;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Proc P;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Init_pcb(P, n);	<span class="comment">// PCB初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"进程初始状态为："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    show_info(P);      <span class="comment">// 输出此刻的进程状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Round_Robin(P, n, timeslice); <span class="comment">// 时间片轮转法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>优先数调度算法</title>
    <url>/2018/10/27/%E4%BC%98%E5%85%88%E6%95%B0%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>操作系统进程相关：优先数调度算法。</p>
<a id="more"></a>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ol>
<li>假定系统有5个进程，每个进程用一个PCB来代表，PCB的结构为：<ul>
<li>进程名（如P1~P5）</li>
<li>指针（按优先数大小把进程连成队列，用指针指出下一个进程PCB的首地址）</li>
<li>要求运行时间（假设进程需要运行的单位时间数）</li>
<li>优先数（赋予进程的优先数，调度时总是选取优先数大的进程先执行）</li>
<li>状态（假设两种状态：就绪和结束，用R表示就绪，用E表示结束。初始状态都为就绪状态）</li>
</ul>
</li>
<li>开始运行之前，键盘输入为每个进程确定它的“优先数”和“要求运行时间”。</li>
<li>处理器总选队首进程运行，用动态改变优先数的办法，进程每运行1次，优先数减1，要求运行时间减1。</li>
<li>进程运行一次后若要求运行时间不为0，则将它加入就绪队列，否则将状态改为“结束”，退出就绪队列。 </li>
<li>若就绪队列为空，结束，否则转到 3 重复。 </li>
</ol>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>能接受键盘输入的进程优先数及要求运行时间，能显示每次进程调度的情况，如哪个进程在运行，哪些进程就绪，就绪进程的排列情况。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 进程控制块PCB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCB</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>]; <span class="comment">// 进程名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> runtime;   <span class="comment">// 要求运行时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> priority;  <span class="comment">// 优先数（优先数越大优先级越高）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> state;    <span class="comment">// 进程状态（R：就绪，E：结束，r：正在运行）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; PCB;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 进程初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：所有进程PCB的开始指针，总进程数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pcb</span><span class="params">(PCB *p, <span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入"</span> &lt;&lt; n &lt;&lt;<span class="string">"个进程的名称，运行时间及优先数（如：P1 2 1）："</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Process"</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">": "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; p[i].name &gt;&gt; p[i].priority &gt;&gt; p[i].runtime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p[i].state = <span class="string">'R'</span>; <span class="comment">// 初始化每个进程都为就绪状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 每一调度后各进程状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：所有进程PCB的开始指针，总进程数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(PCB *p, <span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"进程名 优先数 运行时间 状态"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\t%d\t%d\t%c\n"</span>, p[i].name, p[i].priority, p[i].runtime, p[i].state);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 得到最大优先级的进程序号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：所有进程PCB的开始指针，总进程数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_priority_process</span><span class="params">(PCB *p, <span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> index, max_priority = <span class="number">-100</span>; <span class="comment">// 最大优先数进程序号，最大优先数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p[i].state == <span class="string">'r'</span>) <span class="comment">// 正在运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 在就绪队列中找到优先数最大的进程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(max_priority &lt; p[i].priority &amp;&amp; p[i].state == <span class="string">'R'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                max_priority = p[i].priority;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                index = i; </span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 优先数最大的进程已运行结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p[index].state == <span class="string">'E'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> index;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 进程调度算法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：所有进程PCB的开始指针，总进程数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(PCB *p, <span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v; <span class="comment">// 进程依次运行顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 总运行时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        t += p[i].runtime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"*进程初始状态*"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    show(p, n);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 开始运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=t; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(max_priority_process(p, n) != <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p[max_priority_process(p, n)].state = <span class="string">'r'</span>; <span class="comment">// 继续运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(p[i].state == <span class="string">'r'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p[i].priority--; <span class="comment">// 优先数减一</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                p[i].runtime--; <span class="comment">// 要求运行时间减一</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n第 %d 次: 进程 %s, 优先数 %d, 要求运行时间 %d\n"</span>, j, p[i].name, p[i].priority, p[i].runtime);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                show(p, n); <span class="comment">// 本次运行后进程状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">string</span> s = p[i].name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                v.push_back(s); <span class="comment">// 将该进程放入运行顺序表中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 继续运行与否</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(p[i].runtime == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    p[i].state = <span class="string">'E'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span>    </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    p[i].state = <span class="string">'R'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 输出进程运行顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"优先数调度算法调度顺序："</span> &lt;&lt; v[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;v.<span class="built_in">size</span>(); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" —&gt; "</span> &lt;&lt; v[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n; <span class="comment">// 总进程数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"**优先数调度算法**"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入总进程个数："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    PCB *p = <span class="keyword">new</span> PCB[n]; <span class="comment">// 创建进程空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pcb(p, n); <span class="comment">// 初始化进程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">run</span>(p, n); <span class="comment">// 进程调度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">delete</span>[] p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>密度聚类算法</title>
    <url>/2018/10/27/%E5%AF%86%E5%BA%A6%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>密度聚类，即基于密度的聚类（density-based clustering），此类算法假设聚类结构能通过样本分布的紧密程度确定，可以发现任意形状的聚类，且对带有噪音点的数据起着重要的作用。</p>
<a id="more"></a>

<h2 id="DBSCAN算法"><a href="#DBSCAN算法" class="headerlink" title="DBSCAN算法"></a>DBSCAN算法</h2><p>DBSCAN(Density-Based Spatial Clustering of Application with Noise)是一种典型的密度聚类算法，能够将足够高密度的区域划分成簇，并能在具有噪声的空间数据库中发现任意形状的簇。该方法基于“邻域”参数(ϵ, MinPts)来刻画样本分布的紧密程度。</p>
<p>DBSCAN的相关概念和原理参考：<a href="https://baike.baidu.com/item/DBSCAN/4864716?fr=aladdin" target="_blank" rel="noopener">DBSCAN</a></p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 数据处理：得到训练数据集dataset</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dataset</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 西瓜数据集：每三个一组（编号，密度，含糖量）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    data = <span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    1,0.697,0.46,2,0.774,0.376,3,0.634,0.264,4,0.608,0.318,5,0.556,0.215,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    6,0.403,0.237,7,0.481,0.149,8,0.437,0.211,9,0.666,0.091,10,0.243,0.267,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    11,0.245,0.057,12,0.343,0.099,13,0.639,0.161,14,0.657,0.198,15,0.36,0.37,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    16,0.593,0.042,17,0.719,0.103,18,0.359,0.188,19,0.339,0.241,20,0.282,0.257,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    21,0.748,0.232,22,0.714,0.346,23,0.483,0.312,24,0.478,0.437,25,0.525,0.369,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    26,0.751,0.489,27,0.532,0.472,28,0.473,0.376,29,0.725,0.445,30,0.446,0.459</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    """</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = data.split(<span class="string">','</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> [(float(a[i]), float(a[i+<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)<span class="number">-1</span>, <span class="number">3</span>)]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算欧几里得距离：a,b分别为两个元组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dist</span><span class="params">(a, b)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> math.sqrt(math.pow(a[<span class="number">0</span>]-b[<span class="number">0</span>], <span class="number">2</span>) + math.pow(a[<span class="number">1</span>]-b[<span class="number">1</span>], <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 算法模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：邻域参数e, Minpts，dist距离函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DBSCAN</span><span class="params">(D, e, Minpts, dist)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    T = set()   <span class="comment"># 核心对象集合T</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    k = <span class="number">0</span>       <span class="comment"># 聚类个数k</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C = []      <span class="comment"># 聚类集合C</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    P = set(D)  <span class="comment"># 未访问集合P</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 计算核心对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> D:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> len([i <span class="keyword">for</span> i <span class="keyword">in</span> D <span class="keyword">if</span> dist(d, i) &lt;= e]) &gt;= Minpts:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            T.add(d)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 开始聚类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> len(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        P_old = P</span></pre></td></tr><tr><td class="code"><pre><span class="line">        o = list(T)[np.random.randint(<span class="number">0</span>, len(T))]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        P = P - set(o)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Q = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Q.append(o)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> len(Q):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            q = Q[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Nq = [i <span class="keyword">for</span> i <span class="keyword">in</span> D <span class="keyword">if</span> dist(q, i) &lt;= e]</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> len(Nq) &gt;= Minpts:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                S = P &amp; set(Nq)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Q += (list(S))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                P = P - S</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Q.remove(q)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        k += <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Ck = list(P_old - P)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T = T - set(Ck)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C.append(Ck)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> C, k</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练结果可视化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(C)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    color = [<span class="string">'r'</span>, <span class="string">'y'</span>, <span class="string">'g'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'k'</span>, <span class="string">'m'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(C)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = []    <span class="comment"># x坐标列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        y = []    <span class="comment"># y坐标列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(C[i])):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            x.append(C[i][j][<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            y.append(C[i][j][<span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pl.scatter(x, y, marker=<span class="string">'x'</span>, color=color[i%len(color)], label=i+<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pl.legend(loc=<span class="string">'upper left'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pl.title(<span class="string">'DBSCAN'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pl.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 数据处理得到训练数据集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dataset = get_dataset()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 设置邻域参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    e = <span class="number">0.11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Minpts = <span class="number">5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 密度聚类得到k个聚类簇：以dist函数作为距离度量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C, k = DBSCAN(dataset, e, Minpts, dist)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 聚类结果展示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    draw(C)</span></pre></td></tr></table></figure>

<h2 id="聚类结果"><a href="#聚类结果" class="headerlink" title="聚类结果"></a>聚类结果</h2><p><img src="/assets/blogimg/%E8%A5%BF%E7%93%9C%E6%95%B0%E6%8D%AE%E9%9B%86%E5%AF%86%E5%BA%A6%E8%81%9A%E7%B1%BB.jpeg" alt=""></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>层次聚类算法</title>
    <url>/2018/10/27/%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>层次聚类算法的Python实现。</p>
<a id="more"></a>

<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 数据处理：得到训练数据集dataset</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dataset</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 西瓜数据集：每三个一组（编号，密度，含糖量）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    data = <span class="string">"""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    1,0.697,0.46,2,0.774,0.376,3,0.634,0.264,4,0.608,0.318,5,0.556,0.215,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    6,0.403,0.237,7,0.481,0.149,8,0.437,0.211,9,0.666,0.091,10,0.243,0.267,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    11,0.245,0.057,12,0.343,0.099,13,0.639,0.161,14,0.657,0.198,15,0.36,0.37,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    16,0.593,0.042,17,0.719,0.103,18,0.359,0.188,19,0.339,0.241,20,0.282,0.257,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    21,0.748,0.232,22,0.714,0.346,23,0.483,0.312,24,0.478,0.437,25,0.525,0.369,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    26,0.751,0.489,27,0.532,0.472,28,0.473,0.376,29,0.725,0.445,30,0.446,0.459</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">    """</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = data.split(<span class="string">','</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> [(float(a[i]), float(a[i+<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(a)<span class="number">-1</span>, <span class="number">3</span>)]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算两个元组的欧几里得距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dist</span><span class="params">(a, b)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> math.sqrt(math.pow(a[<span class="number">0</span>]-b[<span class="number">0</span>], <span class="number">2</span>) + math.pow(a[<span class="number">1</span>]-b[<span class="number">1</span>], <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 计算两个聚类簇的平均距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dist_avg</span><span class="params">(Ci, Cj)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> sum(dist(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> Ci <span class="keyword">for</span> j <span class="keyword">in</span> Cj) / (len(Ci)*len(Cj))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 找到距离最小的下标及最小距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_Min</span><span class="params">(M)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    min = <span class="number">10000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    y = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(M[i])):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> i != j <span class="keyword">and</span> M[i][j] &lt; min:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                min = M[i][j]</span></pre></td></tr><tr><td class="code"><pre><span class="line">                x = i</span></pre></td></tr><tr><td class="code"><pre><span class="line">                y = j</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x, y, min</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 算法模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：样本数据集, 距离计算函数，聚类簇数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AGNES</span><span class="params">(D, dist, k)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 先初始化为|D|个类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    M = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> D:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Ci = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Ci.append(i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C.append(Ci)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># M存放C中两两间的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> C:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Mi = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> C:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Mi.append(dist(i, j))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        M.append(Mi)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 实时聚类个数q</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    q = len(D)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 合并更新</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> q &gt; k:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x, y, min = find_Min(M)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C[x].extend(C[y])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C.remove(C[y])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 更新距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        M = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> C:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Mi = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> C:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Mi.append(dist(i, j))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            M.append(Mi)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># 聚类数减一</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        q -= <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> C</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 训练结果可视化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span><span class="params">(C)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    color = [<span class="string">'r'</span>, <span class="string">'y'</span>, <span class="string">'g'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'k'</span>, <span class="string">'m'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(C)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = []    <span class="comment"># x坐标列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        y = []    <span class="comment"># y坐标列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(C[i])):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            x.append(C[i][j][<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            y.append(C[i][j][<span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pl.scatter(x, y, marker=<span class="string">'x'</span>, color=color[i%len(color)], label=i+<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pl.legend(loc=<span class="string">'upper left'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pl.title(<span class="string">'AGNES'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pl.show()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 数据处理得到训练数据集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    dataset = get_dataset()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 设置聚类簇个数k</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    k = <span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 层次聚类形成k个聚类簇</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C = AGNES(dataset, dist_avg, k)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    draw(C)</span></pre></td></tr></table></figure>

<h2 id="聚类结果"><a href="#聚类结果" class="headerlink" title="聚类结果"></a>聚类结果</h2><p><img src="/assets/blogimg/%E8%A5%BF%E7%93%9C%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB.jpeg" alt=""></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治策略求解棋盘覆盖问题</title>
    <url>/2018/10/26/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%E6%B1%82%E8%A7%A3%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在一个2k×2k 个方格组成的棋盘中，恰有一个方格与其它方格不同，称该方格为特殊方格，且称该棋盘为特殊棋盘。试用4种不同形态的L型骨牌, 覆盖给定特殊棋盘上除特殊方格以外的所有方格，且任何2个不得重叠。</p>
<a id="more"></a>

<p><img src="/assets/blogimg/chess.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CHESS[<span class="number">101</span>][<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">// 最大棋盘数组，行列序号为1～100</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> t=<span class="number">0</span>, m; <span class="comment">// 临时变量，实际棋盘大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 显示棋盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=length; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span>.<span class="built_in">width</span>(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; CHESS[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(j == length)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 棋盘覆盖算法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 参数：a，b为子棋盘左上角坐标。x，y为特殊点坐标，length为子棋盘长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chess</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> length)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(length == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tem = t, l = length / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(x&lt;a+l &amp;&amp; y&lt;b+l) <span class="comment">// 特殊点在左上的正方形中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        chess(a,b,x,y,l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        CHESS[a+l<span class="number">-1</span>][b+l<span class="number">-1</span>] = tem;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        chess(a, b, a+l<span class="number">-1</span>, b+l<span class="number">-1</span>, l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(x&gt;=a+l &amp;&amp; y&lt;b+l) <span class="comment">// 左下角的子棋盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        chess(a+l, b, x, y, l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        CHESS[a+l][b+l<span class="number">-1</span>] = tem;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        chess(a+l, b, a+l, b+l<span class="number">-1</span>, l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(x&lt;a+l &amp;&amp; y&gt;=b+l) <span class="comment">// 右上角的子棋盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        chess(a, b+l, x, y, l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        CHESS[a+l<span class="number">-1</span>][b+l] = tem;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        chess(a, b+l, a+l<span class="number">-1</span>, b+l, l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(x&gt;=a+l &amp;&amp; y&gt;=b+l) <span class="comment">// 右下角的子棋盘</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        chess(a+l, b+l, x, y, l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        CHESS[a+l][b+l] = tem;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        chess(a+l, b+l, a+l, b+l, l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a, b; <span class="comment">// 子棋盘左上角的行号和列号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x, y; <span class="comment">// 特殊点的行号和列号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 棋盘大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入棋盘大小（1-100）："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入特殊点行号："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入特殊点列号："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = b = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    chess(a, b, x, y, length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    show(length);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治策略计算二叉树高度</title>
    <url>/2018/10/26/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E5%BA%A6/</url>
    <content><![CDATA[<p>测试二叉树输入序列：+-a##/b##+c##d##*e##f##<br>测试结果（高度）：5</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxh = <span class="number">0</span>; <span class="comment">// 二叉树高度 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>&#123;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> data; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;BTNode, *BTree; <span class="comment">// 二叉树节点，二叉树</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(BTree &amp;T)</span> </span>&#123; <span class="comment">// 创建二叉树</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> ch; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(ch == <span class="string">'#'</span>) T = <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        T = (BTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T-&gt;data = ch; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        CreateTree(T-&gt;lchild);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        CreateTree(T-&gt;rchild);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTDepth1</span><span class="params">(BTree T, <span class="keyword">int</span> depth)</span> </span>&#123; <span class="comment">// 方法一 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(T) &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(T-&gt;lchild)   BTDepth1(T-&gt;lchild, depth + <span class="number">1</span>); </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(T-&gt;rchild)   BTDepth1(T-&gt;rchild, depth + <span class="number">1</span>); </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(depth &gt; maxh)     </span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxh = depth; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> depth; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTDepth2</span><span class="params">(BTree T)</span> </span>&#123; <span class="comment">// 方法二</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> m = BTDepth2(T-&gt;lchild); </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> n = BTDepth2(T-&gt;rchild); </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (m &gt; n) ? (m+<span class="number">1</span>) : (n+<span class="number">1</span>);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    BTree T = <span class="literal">NULL</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    CreateTree(T); </span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    BTDepth1(T,<span class="number">1</span>); </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"方法一求树高：H = "</span> &lt;&lt; maxh &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"方法二求树高：H = "</span> &lt;&lt; BTDepth2(T) &lt;&lt; <span class="built_in">endl</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最近点对问题</title>
    <url>/2018/10/26/%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在n(n&gt;=2)个点的集合S中寻找最近点对及最近距离（距离用欧几里得距离度量）。</p>
<a id="more"></a>

<h3 id="分治算法求解"><a href="#分治算法求解" class="headerlink" title="分治算法求解"></a>分治算法求解</h3><ul>
<li>|S| &lt;= 2：直接计算两点距离</li>
<li>|S| == 3：三个点中最近的两点距离</li>
<li>|S|  &gt;  3：<ul>
<li>根据点的x值和y值对S中的点排序</li>
<li>划分集合S为SL和SR，|SL| == |SR|，划分线为L</li>
<li>分别在SL和SR中递归求解子问题，得到两个最小距离dl和dr，令d = min(dl, dr)</li>
<li>将 [L-d, L+d] 内的点以y值排序，对于每一个点(x‘, y’)找出y值在 [y‘-d, y’+d] 内接下来的<strong>7个点</strong>，计算距离为d’</li>
<li>如果d’ &lt; d，令d = d’，返回d</li>
</ul>
</li>
</ul>
<p><img src="/assets/blogimg/ClosestPair.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NO_DISTANCE 1000000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 二维点Point, x, y范围为[-100, 100]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span> <span class="keyword">float</span> x, y; &#125; Point;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 随机初始化points数组中的二维点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitPoints</span><span class="params">(Point *points, <span class="keyword">int</span> length)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    srand(<span class="keyword">unsigned</span>(time(<span class="literal">NULL</span>)));  <span class="comment">// 设置随机种子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = (rand()%<span class="number">20000</span>) / <span class="number">100.0</span> - <span class="number">100</span>;    <span class="comment">// 调整rand(),使得横纵坐标范围为[-100,100]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = (rand()%<span class="number">20000</span>) / <span class="number">100.0</span> - <span class="number">100</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 距离公式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Distance</span><span class="params">(Point a, Point b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 排序规则：依照Point中的x 升序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CmpX</span><span class="params">(Point a, Point b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a.x &lt; b.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 分治策略求最近点对，该两点记为a, b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ClosestPair</span><span class="params">(Point points[], <span class="keyword">int</span> length, Point &amp;a, Point &amp;b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> distance;        <span class="comment">// points中最近两点的距离 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> d1, d2;          <span class="comment">// 分割后两子集中各自最小点对的距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, k=<span class="number">0</span>;     <span class="comment">// 用于for循环</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Point a1, b1, a2, b2;  <span class="comment">// 分割后两子集中的最小点对</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(length &lt; <span class="number">2</span>)  <span class="keyword">return</span> NO_DISTANCE;    <span class="comment">// 当子集长度小于2时定义为最大距离：不可达</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(length == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a = points[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        b = points[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        distance = Distance(points[<span class="number">0</span>], points[<span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Point *pts1 = <span class="keyword">new</span> Point[length];     <span class="comment">// 开辟两个子集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Point *pts2 = <span class="keyword">new</span> Point[length];  </span></pre></td></tr><tr><td class="code"><pre><span class="line">        sort(points, points+length, CmpX);   <span class="comment">// 对points进行排序，排序规则为CmpX</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">float</span> mid = points[(length<span class="number">-1</span>)/<span class="number">2</span>].x;  <span class="comment">// 排完序后的中位数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;length/<span class="number">2</span>; i++) <span class="comment">// 左子集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            pts1[i] = points[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,i=length/<span class="number">2</span>; i&lt;length; i++) <span class="comment">// 右子集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            pts2[j++] = points[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        d1 = ClosestPair(pts1, length/<span class="number">2</span>, a1, b1);           <span class="comment">// 分治求解左子集的最近点对距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        d2 = ClosestPair(pts2, length-length/<span class="number">2</span>, a2, b2);    <span class="comment">// 分治求解右子集的最近点对距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(d1 &lt; d2) &#123; distance = d1; a = a1; b = b1; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> &#123; distance = d2; a = a2; b = b2; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 求解跨分割线并在δ×2δ区间内的最近点对</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Point *pts3 = <span class="keyword">new</span> Point[length];   </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>,k=<span class="number">0</span>; i&lt;length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(points[i].x-mid) &lt;= distance)    pts3[k++] = points[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;k; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;=i+<span class="number">7</span>&amp;&amp;j&lt;k; j++)    <span class="comment">// 只需与有序的邻接的的7个点进行比较</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(Distance(pts3[i], pts3[j]) &lt; distance) &#123; <span class="comment">// 跨分割线的两点距离小于已知最小距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    distance = Distance(pts3[i], pts3[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    a = pts3[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    b = pts3[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> distance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 显示点集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowPoints</span><span class="params">(Point points[], <span class="keyword">int</span> length)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; points[i].x &lt;&lt; <span class="string">", "</span> &lt;&lt; points[i].y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> N;          <span class="comment">// 随机生成的点对个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Point a, b;     <span class="comment">// 最近点对</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> diatance; <span class="comment">// 最近距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请您输入点对个数："</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(N &lt; <span class="number">2</span>)   <span class="built_in">cout</span> &lt;&lt; <span class="string">"点个数要 &gt;= 2 !"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; N &lt;&lt; <span class="string">"个随机二维点对："</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Point *points = <span class="keyword">new</span> Point[N]; <span class="comment">// 点集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        InitPoints(points, N);        <span class="comment">// 随机初始化点集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ShowPoints(points, N);        <span class="comment">// 打印点集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 求最近点对距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        diatance = ClosestPair(points, N, a, b); </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"按横坐标排序后的点对:"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ShowPoints(points, N);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"最近点对为："</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; a.x &lt;&lt; <span class="string">", "</span> &lt;&lt; a.y &lt;&lt; <span class="string">")和"</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; b.x &lt;&lt; <span class="string">", "</span> &lt;&lt; b.y &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最近点对距离为："</span> &lt;&lt; diatance &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：来自不同贴标签者的经济有效的主动学习</title>
    <url>/2018/10/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E6%9D%A5%E8%87%AA%E4%B8%8D%E5%90%8C%E8%B4%B4%E6%A0%87%E7%AD%BE%E8%80%85%E7%9A%84%E7%BB%8F%E6%B5%8E%E6%9C%89%E6%95%88%E7%9A%84%E4%B8%BB%E5%8A%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Cost-Effective Active Learning from Diverse Labelers</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>本文提出了一种新的主动选择标准来评估实例-标签对的成本效益，实现了在保证所选实例能够有效改进分类模型的基础上最大化的降低标记成本。 </p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>传统的主动学习中，仅仅通过一个标记者来对实例样本做标记，但这不满足实际应用需求。实际应用中往往采用多标记者的方式。但是不同标记者拥有不同的标记精度和成本，也就是说不同的标记者拥有各自擅长和不擅长的标记领域，我们应该尽可能让他们参与各自最擅长的领域。本文正是从这一角度着手，提出了这种最大成本效益的实用的多标记者参与的标记方法。 </p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><p>说选取的实例有利于改进分类模型；选取的标记者应用于各自擅长的领域；低成本。总体来说，实现了为每个实例自适应地选择最具成本效益的标记者。 </p>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><ol>
<li>输入：规格较小的已标记实例样本集L，大量未标记样本集U，所有标记者对L的标记Y’ </li>
<li>初始化：计算所有标记者的的Cost </li>
<li>循环：对于U中的每一个实例样本xj和A中的每一个标记者ai <ul>
<li>计算xj的不确定性 </li>
<li>计算ai对xj标记精确度的预测值 </li>
<li>计算方案（xj，ai）的成本效益 </li>
</ul>
</li>
<li>选择最大成本效益的实例-标记者对（x*，a*） </li>
<li>A*对x*做出标记y*</li>
<li>将最大成本效益的实例-标记者对（x*，a*）放入集合L，并将x*从U中除去 </li>
<li>训练分类模型并在测试集上评估 </li>
<li>返回步骤3，直到超出Cost预算或者达到了要求对精度 </li>
</ol>
<h3 id="优缺点及思考"><a href="#优缺点及思考" class="headerlink" title="优缺点及思考"></a>优缺点及思考</h3><p>本文提出了一种对于多标记者参与的主动学习模型的改进方法，即让具有不同专业知识的标记者标记自己最擅长领域内的未标记样本实例，这样可以达到在满足精确度要求情况下最小的成本开销。 </p>
<p>该方法的最大先进性在于专业领域划分，与“分工”思想一致，仅让每个标记者参与自己最擅长领域的标记工作。因为每个标记者每进行一次标记的cost固定，因此提前计算好每个标记者的cost可以加速整个过程的进度。</p>
<p>2018.10.22 </p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：基于不确定性和密度的有源半监督学习方案，用于正无标记多元时间序列的分类</title>
    <url>/2018/10/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E5%9F%BA%E4%BA%8E%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%92%8C%E5%AF%86%E5%BA%A6%E7%9A%84%E6%9C%89%E6%BA%90%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%A1%88%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%AD%A3%E6%97%A0%E6%A0%87%E8%AE%B0%E5%A4%9A%E5%85%83%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>An uncertainty and density based active semi-supervised learning scheme for positive unlabeled multivariate time series classification</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>本文提出一种结合主动学习和半监督学习，仅用最少的人工标记来获得用以多元时间序列分类问题的一个置信且标记充分的数据集，用以更好的训练从而完成分类任务。 </p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>传统的分类算法通常需要大量标记的训练数据来学习高质量的分类模型，然而实际上有标记的数据通常数量很少，且采用人工标记的成本相当大。训练样本的数量将直接决定模型的预测效果，因此充足数量的标记训练样本是至关重要的。多元时间序列问题的复杂性导致传统的半监督学习方法效率低下，因此本文提出的方法将在最大程度节省人力资源的同时更高效的对多元时间序列做出标记。 </p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><p>在最大程度节省人力标注的资源的同时得到一个置信且充分的标记训练集；提出基于不确定性和密度的采样策略，只需人工标记信息量最大的样本数据；提出一种有效的主动半监督学习框架，逐渐标注信息量最大的样本数据；提出了一种有效的无参数主动学习停止准则，以平衡整体框架的性能与成本。 </p>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><ol>
<li>输入：一个包含少量正例样本P和大量未标记样本U的训练数据集 </li>
<li>输出：充分标记的训练数据集D </li>
<li>首先找到一个置信的负例样本。 </li>
<li>循环遍历，直到满足停止准则： <ul>
<li>计算U中每一个未标记多元时间序列的得分Score（S）（该得分基于局部密度和不确定性） </li>
<li>根据得分Score从U中选择出信息量最大的样本Y，并对Y进行人工专家标注 </li>
<li>使用半监督学习方法，自动对Y的近邻进行分类 </li>
</ul>
</li>
<li>停止准则：新标记的数据不再提供更多信息以学习更好的分类器模型，即未标记数据中的剩余示例无法进一步提高分类器性能。判断依据是：得分曲线的连续斜率极差在允许范围内，则表示得分曲线达到稳定且主动学习过程应该结束。 </li>
</ol>
<h3 id="优缺点及思考"><a href="#优缺点及思考" class="headerlink" title="优缺点及思考"></a>优缺点及思考</h3><p>本文提出的方法致力于解决多元时间序列分类中缺乏大量标记样本数据的问题，着重于用尽可能少的人力资源得到置信且标记充分的数据集，从而更好的学习分类模型。本文提出的抽样策略基于不确定性和局部密度，能够选择出未标记样本中最具有价值，即最值得人工标注的样本，这样做不仅大大节省人力成本，而且使训练数据更优。同时本文提出的停止准则将忽略剩余的那些标注价值并不高的样本，这也利于节省成本。 </p>
<p>本文的研究基于样本数据中正负样本基本平衡的假设，即正负例数量大致相同，但实际上多元时间序列数据往往是不平衡的，因此本文的标注方法对传统的多元时间序列分类更有效，因为传统多元时间序列分类也是基于正负样本平衡的假设。因此更进一步的研究应着眼于不平衡样本下的训练数据的标记和分类。 </p>
<p>2018.10.13 </p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：kShape-时间序列的高效准确聚类</title>
    <url>/2018/10/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-kShape-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E9%AB%98%E6%95%88%E5%87%86%E7%A1%AE%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<p>k-Shape: Efficient and Accurate Clustering of Time Series</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>本文提出一种新的时间序列聚类算法k-Shape，该方法基于一种考虑时间序列形状的距离度量和聚类质心计算方法，实现了独立于领域的时间序列聚类问题的高准确性和高稳健性。 </p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>大量的时间序列几乎出现在所有的学科中，时间序列的聚类研究十分广泛。大多数聚类算法的性能取决于距离测量的度量，而且不同领域对时间序列的聚类要求差异巨大，同时传统方法无法扩展到大数据时代下的海量数据集。因此本文提出一种新的时间序列聚类方法，该方法基于时间序列形状，高效且独立于领域。 </p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><p>基于互相关度量提出了一种新的距离度量——平移和位移不变度量，以及新的聚类质心的计算方法。提出了k-Shape方法，一种基于质心的时间序列聚类方法。。 </p>
<h3 id="具体方法："><a href="#具体方法：" class="headerlink" title="具体方法："></a>具体方法：</h3><ol>
<li>准备工作： <ul>
<li>基于互相关测量得出的新的距离度量算法SBD（x，y），该算法将得到时间序列x和y的不相似度dist，以及y针对x的对齐序列y’ </li>
<li>基于SBD得出的新的聚类质心计算算法ShapeExtraction（X，C），该算法将得到聚类质心序列 </li>
</ul>
</li>
<li>对于包含n个时间序列（每个序列m个数据点）的数据集X，和目标聚类数k，在k-Shape算法内进行多次循环迭代，迭代内容如下 <ul>
<li>通过ShapeExtraction方法对每个聚类更新聚类质心序列，得到k个类更新后的聚类质心序列 </li>
<li>通过SBD方法对聚类质心序列和n个时间序列的距离度量，得到n个不相似度和n个序列针对于质心序列的对齐序列 </li>
<li>当不相似度满足要求时，对该时间序列归类标记处理 </li>
</ul>
</li>
</ol>
<h3 id="优缺点及思考"><a href="#优缺点及思考" class="headerlink" title="优缺点及思考"></a>优缺点及思考</h3><p>本文提出的新的时间序列聚类方法，独立于研究领域，高效且稳健，比现有的其他时间序列的聚类算法都更实用，其可扩展性和鲁棒性也很高。通过与常用的距离度量：ED、DTW、cDTW做比较，证明了本文基于互相关测量提出的距离度量SBD方法的优越性。同时实验也通过与其他扩展聚类算法做比较，证明了k-Shape方法的优越性。 </p>
<p>本文提出的基于互相关测量的距离度量SBD同DTW等同样优越，但更高效。本文着重关注高效且与领域无关的时间序列聚类，能够保留时间序列的形状，并在缩放和位移不变性下有效计算聚类质心，具有很强的聚类性能。本文研究重点是针对于单变量时间序列的聚类问题，但目前在大数据时代，海量数据集往往都是多属性多变量的，在这种情况下，如何有效地拓展该方法以满足多元时间序列聚类问题的需要，具有很重要的意义。 </p>
<p>2018.10.7 </p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：通过轻量级核心集进行可扩展的k-Means聚类</title>
    <url>/2018/10/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E9%80%9A%E8%BF%87%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%B8%E5%BF%83%E9%9B%86%E8%BF%9B%E8%A1%8C%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84k-Means%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<p>Scalable k-Means Clustering via Lightweight Coresets</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>核心集是数据的紧凑表示，成功应用于海量数据的聚类问题。本文提出一种新的轻量级核心集构造方法，通过并行得到更小的核心集，来更好的推广到K-Means算法中。 </p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>大数据时代下的海量数据集给聚类问题带来巨大困难，核心集应用而生。现有的核心集方法通常指允许乘法误差。因此本文的研究重点是提出一种针对于K-Means算法的核心集构建方法，该方法不仅具有现有核心集的优点，允许乘法误差和加法误差，而且所需的成本大大减少。 </p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><p>本文提出了一种新的轻量级核心集构建方法，允许加法和乘法误差。通过并行算法构建轻量级核心集，成本低。该方法可进一步扩展到布雷格曼分歧的软硬聚类。通过实验，证实了该方法的实用性。 </p>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><ol>
<li>首先准备数据： n x d的数据集X（n个样本、d个属性），核心集规格大小m </li>
<li>计算X的均值𝜇 </li>
<li>循环计算重要性采样分布概率q(x)： 对于每个x∈X，q(x) =1/(2|X|) + d(x, 𝜇)^2/(2∑x’∈X d(x’, 𝜇)^2) </li>
<li>得到轻量级核心集C：m个加权点来自于X，每个点的权重为1/(mq(x))，以概率q(x)来采样得到。 </li>
</ol>
<h3 id="优缺点及思考："><a href="#优缺点及思考：" class="headerlink" title="优缺点及思考："></a>优缺点及思考：</h3><p>本文提出的新的轻量级核心集构造方法以采样足够多的点为保证，其在维数d中是线性的并且在聚类k的数量中接近线性。本文提出的轻量级核心集构建算法很容易并行化实施，并且可以在两轮分布式程序中实现，而且该方法可以进一步扩展到布雷格曼分歧的软硬聚类。 </p>
<p>对于统计k均值问题的目标是在Rd中找到k个聚类中心，使预期量化误差最小。本文提出的方法可用于在经验风险最小化的背景下进一步总结任何样本X，通常需要尽可能大的样本X以保证较好的近似质量，但轻量级核心集的尺寸远小于X。 </p>
<p>2018.10.5 </p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：使用特定于域的有用性分数进行聚类</title>
    <url>/2018/10/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E4%BD%BF%E7%94%A8%E7%89%B9%E5%AE%9A%E4%BA%8E%E5%9F%9F%E7%9A%84%E6%9C%89%E7%94%A8%E6%80%A7%E5%88%86%E6%95%B0%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<p>Clustering with Domain-Specific Usefulness Scores</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>对数据集对聚类算法通常有好多种，但最终聚类结果的好坏取决于该领域专业人员的评价与认可。因此本文着力研究在给定数据集专业评分情况下的有用性聚类问题。 </p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>好的聚类算法必须通过专业领域的认可，其聚类结果才是有意义的。目前的很多聚类方法都是基于实例级的，比如监督分类和半监督分类。很多时候，我们无法得到样本数据的准确标记，只能根据该领域内专家对样本点的评分来完成聚类任务。因此本文的研究重点是基于专家评分来完成有用性聚类任务。 </p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><p>本文提出了一种新的结合了领域知识的聚类方法，即我们对数据集做出聚类需要根据该领域内专家的有用性评分来完成。本文采用联合优化聚类解决方案，结合谱算法和HSIC方法综合考量聚类质量和有用性，这使得我们可以得到限制在高质量自然聚类和专家关心的子空间下的聚类结果。 </p>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><ol>
<li>首先准备数据： <ul>
<li>n x d的数据集X（n个样本、d个属性），领域专家提供的n x 1评分矩阵s </li>
<li>最终聚类数k，数据集核函数kc，评分核函数ks，衡量质量与有用性的权重µ </li>
<li>随机初始化的映射矩阵W^（0）（d x q，用来降维），最大迭代次数T，收敛精度ε </li>
</ul>
</li>
<li>计算评分s的核矩阵Ks，开始t = 0 : T的迭代，每次迭代中： <ul>
<li>让W=W^（t），优化聚类分配矩阵U；用W^（t）和U^（t）计算本次目标函数F^（t） </li>
<li>让U=U^（t），优化映射矩阵W；用W^（t+1）计算下一次目标函数F^（t+1） </li>
<li>计算收敛度r（t）=| F^（t+1）- F^（t）| / | F^ t | </li>
<li>判断是否收敛：当 || W ^ (t+1) – W^ t ||_F &lt; ε  and r^（t） &lt; ε 时，结束迭代；否则继续迭代 </li>
</ul>
</li>
<li>得到最优映射矩阵Wopt  = W^（t），并计算子空间XWopt的核矩阵K </li>
<li>根据核矩阵K，用谱聚类算法得到k个类别的聚类结果以及样本的标记Y </li>
</ol>
<h3 id="优缺点及思考"><a href="#优缺点及思考" class="headerlink" title="优缺点及思考"></a>优缺点及思考</h3><p>本文提出的基于域相关分数的有用性聚类框架，能够满足不同领域的特殊聚类需求。通过综合考量聚类质量与有用性，得到该领域专家关心的聚类结果。该方法没有直接使用原始数据集，而是通过梯度下降得到一个最优的映射矩阵，通过降维处理得到的新矩阵来完成分类任务，这使得我们在忽略一些相关性不大的属性的同时，最大化地利用了我们最关心的属性。通过与其他聚类算法做比较，该方法的聚类结果最令相关领域专家满意。 </p>
<p>通过任意随机初始化得到的初始正交映射矩阵W，通常会得到局部最小值。为了避免局部最小、达到全剧最优，我们不得不多次初始化W，并进行多次实验，最终选取最小的W作为我们的最佳正交映射矩阵。在优化聚类分配矩阵时，需要分解拉普拉斯矩阵，这将带来巨大的时间复杂度，我们可以对该方法做进一步改进，例如使用组合多重网格求解器来优化时间复杂度。该方法的进一步研究可着力于如何有效得出全局最优解。 </p>
<p>2018.10.1 </p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：基于约束规划的最小聚类修改框架</title>
    <url>/2018/10/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E5%9F%BA%E4%BA%8E%E7%BA%A6%E6%9D%9F%E8%A7%84%E5%88%92%E7%9A%84%E6%9C%80%E5%B0%8F%E8%81%9A%E7%B1%BB%E4%BF%AE%E6%94%B9%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>A Framework for Minimal Clustering Modification via Constraint Programming</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>好的聚类算法通常会受到异常属性的影响，本文着力研究如何用一种低成本且简单有效的方式来优化受到异常属性干扰的聚类，实现每个聚类的最大凝聚力。 </p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>一个比较好的聚类算法可能会因为少数属性（坏/异常的属性值）的影响而表现糟糕，花费大量成本重新聚类不是个好主意，更好的方法是通过删除不需要的属性来最低限度地修改聚类。之前的研究仅仅着重于聚类算法的好坏，将聚类结果归之于算法的好坏，而本文的研究重点是基于约束编程框架进一步优化那些好的聚类算法的聚类结果。 </p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><p>本文提出的方法从最初的聚类算法开始，基于约束编程框架，在删除不良属性的同时对其进行最小程度的修改，这省去了重新聚类的成本。对于其他现成聚类簇，该方法也可以做出进一步优化。同时，这种方法可以为任何聚类算法提供反馈。通过生成新的最小修改聚类，同时保留大部分原始数据，使得我们不用担心信息的过度丢失。  </p>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><ol>
<li>首先多次使用某种聚类算法对原始数据集进行聚类，得到最佳的聚类集群。 </li>
<li>接着计算所有属性在所有类中的直径，得到初始直径矩阵D（每行为一个类，每列为一个属性）。 </li>
<li>观察计算结果并制定收紧策略： 修改后的直径矩阵D’[i, j] = m D[i, j]（其中m为修改参数，0&lt;m&lt;=1）。 </li>
<li>计算约束条件“上限 – 下限 &lt;= D’”所需要的具体数值。每个类中关于每个属性的上限和下限： <ul>
<li>上限：类中各个属性值与最小属性值之差的最大值，再加该类中的最小属性值 </li>
<li>下限：类中各个属性值与最大属性值之差的最小值，再加该类中的最大属性值 </li>
</ul>
</li>
<li>根据得到的约束条件，在约束编程框架中得到可行解，即一个进步了的聚类结果。 </li>
<li>重新计算新的类直径矩阵，若对结果不满意可多次调整收紧策略，最终达到满意的聚类结果。 </li>
</ol>
<h3 id="优缺点及思考"><a href="#优缺点及思考" class="headerlink" title="优缺点及思考"></a>优缺点及思考</h3><p>本文所提出的聚类优化方法，是基于某种比较好的聚类算法，在不做重新聚类的情况下，基于约束编程框架最小限度的修改聚类，以达到各个聚类内的凝聚力最大的效果。这种方法需要我们提供反馈，即我们对聚类结果的评价，我们需要告诉程序应该修改哪一个类中的哪一个属性直径，以便于程序不去考虑那些异常属性对聚类的影响。 </p>
<p>一种效果更好的方法是让类中的任意两点的属性距离都不大于我们限定的属性直径，但这样做将需要很大内存和CPU，这很低效。因此本文改进方法，仅仅限制类内属性的最大差距，这样在不影响优化效果的同时极大的提高了效率并节省类开支。 </p>
<p>这种方法在实施的过程中会将那些受到不良属性影响的实例点移动到最适合他们的类中。基于约束编程框架，根据我们限定的约束条件，达到“类内距离最小、类间距离最大”的效果。 </p>
<p>本文的研究重点是一步步缩紧约束条件，在约束编程框架下得到更好的可行解。那么进一步探索，是否可以找到一些方法，可以通过修改聚类或者聚类数量，达到一种更广泛和适用性更强的修改框架。 </p>
<p>2018.9.24 </p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：MP相异性度量</title>
    <url>/2018/10/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-MP%E7%9B%B8%E5%BC%82%E6%80%A7%E5%BA%A6%E9%87%8F/</url>
    <content><![CDATA[<p>Mp-dissimilarity–A data dependent dissimilarity measure</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>本文通过研究如何利用数据分布来衡量两个实例之间的不相似性，进而提出一种新的数据相关差异度量，称为“mp-dissimilarity”，这为高维空间的分类和信息检索任务提供了更好的性能。 </p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>最近邻搜索是许多数据挖掘算法的核心过程，但在高维空间中可靠地实现仍然是一项具有挑战性的任务。这是因为传统基于几何模型的相异性度量的有效性会随着维数的增加而减小，无法到达高精度和高可靠性。因此本文提出一种新颖的相关差异度量来解决高维空间下的这一问题。 </p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><p>不依赖于传统的几何距离，而是利用数据分布来衡量实例之间的不相似性，这巧妙地避开了高纬度的难题。通常大范围的数据分布和距离测量中所有点对几乎等距，此时这种度量将发挥绝对优势。这也符合心理学上“两个实例之间的判断相异性会受到测量环境和其他实例的影响”这一观点。例如在非洲（白人很少和黑人很多）比在美国（有很多白人）的情况下，两个白人被认为更相似。 </p>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><ol>
<li>首先对样本数据集做尺寸一致化处理，得到d x m的训练数据集X（d为数据集维度，亦即实例的属性数；m为实例数）和与m个实例一一对应的标记集Y（1 x m） </li>
<li>依次遍历X的每一个维度，在每次遍历中，需要做： <ul>
<li>计算第i维度数据的标准差σi，得到邻域参数ςi = σi  /  2 </li>
<li>循环计算Xi上任意不同的两点度量：根据邻域Ri（Xij，Xik）=[min(Xij，Xik)-ςi, max(Xij，Xik)+ςi]，得到该邻域内实例点的数量n = | Ri（Xij，Xik）|，从而得到任意两点间度量mpi（Xij，Xik）=n / m </li>
</ul>
</li>
<li>对任意不同点的度量求所有维度上的Lp范数，即mp（Xj，Xk）=（∑（mpi（Xij，Xik））^p）^(1/p )</li>
<li>此时得到了m个样本点的mp度量矩阵mp（m x m），度量越小，两个实例点越相似 </li>
<li>应用mp度量矩阵我们可以采用KNN算法进行分类和预测等进一步研究 </li>
</ol>
<h3 id="优缺点及思考："><a href="#优缺点及思考：" class="headerlink" title="优缺点及思考："></a>优缺点及思考：</h3><p>可以在信息检索方面应用该度量，通常会进行多轮相关性反馈，每轮提供一组反馈实例（包含正反馈和负反馈）以优化性能，相比于传统的Lp范数，mp度量将会有更好的性能和准确度。 </p>
<p>本文提出一种新的距离度量，它根据数据分布而不是传统的几何距离来进行度量样本距离，进一步优化分类预测问题模型。这在高纬空间往往发挥巨大优势，但是在计算上需要巨大的时间成本，因为需要一维一维地计算每个维度上任意不同两点之间的mp度量。 </p>
<p>这种新的距离度量可在很多研究中应用，其进一步的研究应该放在如何用一种时间复杂度更小的算法求解距离度量。 </p>
<p>2018.9.24 </p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读：多元时间序列的马式距离DTW算法</title>
    <url>/2018/10/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E5%A4%9A%E5%85%83%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E9%A9%AC%E5%BC%8F%E8%B7%9D%E7%A6%BBDTW%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Learning a Mahalanobis Distance-Based Dynamic Time Warping Measure for Multivariate Time Series Classification</p>
<a id="more"></a>

<h3 id="研究的问题"><a href="#研究的问题" class="headerlink" title="研究的问题"></a>研究的问题</h3><p>针对多元时间序列的分类和预测问题，这篇论文提出了一种基于马式距离的动态时间规整算法，具有很高的精度和鲁棒性。</p>
<h3 id="研究动机"><a href="#研究动机" class="headerlink" title="研究动机"></a>研究动机</h3><p>多变量时间序列（MTS）数据集存在于众多领域，是各种计算机视觉与模式识别应用的基础之一，对其的准确分类已经成为一个热门研究课题。此前的DTW算法多用于单一变量时间序列，因此本文提出一种基于马式距离的动态时间规整算法用于多元时间序列的分类和预测。 </p>
<h3 id="先进性与贡献"><a href="#先进性与贡献" class="headerlink" title="先进性与贡献"></a>先进性与贡献</h3><p>基于马式距离的度量学习充分考虑到多变量之间的联系，通过为变量分配权重以消除噪声和耦合的影响，以便于准确地测量局部距离。基于三元约束模型和LogDet散度的度量学习使精度和鲁棒性更高。运用下限测量（LBM）方法和Woodbury公式极大地降低了计算成本。 </p>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><ol>
<li>首先根据训练集标签对训练样本进行排序。   </li>
<li>使用LBM方法扩展训练样本得到更近距离的两个多元时间序列。 </li>
<li>接着使用线性度量学习框架来学习马式距离函数，每次通过DTW算法计算动态构建的大量三元组，逐步优化马式距离函数中的M矩阵，以便于损失函数达到最小值。 </li>
<li>应用LogDet散度作为正则项来解决损失函数的最小化问题，并应用Woodbury公式来优化计算过程。 </li>
<li>再使用上述步骤得到的最优M矩阵，用K邻近算法（KNN）依次预测K值为1～10情况下的测试数据集，得到不同K值下的预测结果。 </li>
<li>计算不同K值下的预测精确度，并对本算法性能进行评估。 </li>
</ol>
<h3 id="优缺点及思考"><a href="#优缺点及思考" class="headerlink" title="优缺点及思考"></a>优缺点及思考</h3><p>   本文所提出的分类和预测方法，需要用到样本数据量三次方规模的三元组，并且是动态构建三元组方案，其计算时间复杂度为O(Nd2mn)（其中N为三元组数量），这导致该方法的计算过程很耗时。该方法在样本变量数量较大的情况，将会有更好的实验效果。这是因为马式距离函数着重强调变量及多变量之间的联系，变量太少的情况下，马式距离度量学习方法将会失去优势。同时该方法不善于处理正常和异常数据混杂的情况，此时我们不能获得最优的M矩阵。</p>
<p>   因为SVM+MDDTW方案仅要求相同样本具有相似的分布，这不同于KNN+MDDTW方案需要最小的马式距离，因此在大多数情况下SVM+MDDTW方案的性能更好。同时应该选取合适的学习速率参数α，α太大将使三元组对M矩阵的更新产生影响，使M矩阵更新过程不稳定，分类精度降低；太小又会使学习速率太缓慢且不充分，无法发挥马式距离的优势。 </p>
<p>   这篇论文提出一种新颖的针对多元时间序列分类和预测问题的方法，充分应用马式距离来测量MTS的局部距离，利用DTW找到最优路径来对齐MTS（在长度和相位上），实现来高精度和鲁棒性。对该问题的进一步研究应该着重在算法优化上，以得到更低的计算成本。   </p>
<p>2018.9.23 </p>
]]></content>
      <tags>
        <tag>论文阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>欧洲迪斯尼的错误</title>
    <url>/2018/10/25/%E6%AC%A7%E6%B4%B2%E8%BF%AA%E6%96%AF%E5%B0%BC%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>管理学原理课程上的案例讨论：欧洲迪斯尼的错误，本文记录一点思考。</p>
<a id="more"></a>

<ol>
<li>错误的决策：成本超出、无酒精政策、太少的淋浴卫生间、错误的认为法国人不在饭店的餐厅用早餐等。</li>
<li>公司认为是连续的欧洲经济衰退、高利率、法郎升值等造成了这些问题。</li>
<li>公司与员工关系很糟，它认为懂得最多，并坚持将之强加于员工。</li>
<li>迪斯尼在许多方面都表现得过于自信，结果造成严重的战略和财务失误。比如：<ul>
<li>管理者夸口他们能预测巴黎未来的生活模式</li>
<li>他们认为人们会转移到离欧洲迪斯尼很近的东部来</li>
<li>他们相信能够改变欧洲人的习惯</li>
</ul>
</li>
<li>过分骄傲、批评的压力、工人的士气低落等在一开始就使得游客远离。</li>
<li>欧洲迪斯尼的财务风险基于对利润过于乐观的估计，老式欧洲思维是不能和美式自由市场财务相比较的。</li>
<li>公园有许多游览者，但成本太高。同时经济环境也变了，迪斯尼完全没有看到欧洲经济处于不景气当中。</li>
<li>他执著要保证迪斯尼的质量，忽视了做事情的预算和评论家的警告。</li>
<li>新管理层降低了门票价格并削减了成本。</li>
<li>动画电影《大力神》和《THE HUNCHBACK OF NOTRE DAME》对原著的粗暴歪曲激怒了欧洲人。“好莱坞为了自己的顾客比迪斯尼更加歪曲欧洲文化”。</li>
</ol>
<h2 id="迪斯尼的六宗罪"><a href="#迪斯尼的六宗罪" class="headerlink" title="迪斯尼的六宗罪"></a>迪斯尼的六宗罪</h2><ol>
<li>欧美文化差异误判</li>
<li>餐饮、酒店住宿服务决策失误</li>
<li>公司管理团队不合理</li>
<li>决策者缺乏交流、盲目乐观</li>
<li>未意识到欧洲经济持续衰退</li>
<li>高风险的直接投资方式</li>
</ol>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><ol>
<li><strong>案例中有多少决策，各是什么类型，表现在何处，正确的做法应该是什么？</strong><ol>
<li>无酒精政策——业务决策、程序化决策</li>
<li>太少的淋浴卫生间——业务决策、程序化决策</li>
<li>错误的认为法国人不在饭店的餐厅用早餐——业务决策、程序化决策</li>
<li>为了克服成本而设定的比美国高的门票价格——非程序化决策、管理决策</li>
<li>新管理层降低了门票价格并削减了成本——战略决策、非程序化决策</li>
<li>在动画电影的选取上考虑不周，对原著的粗暴歪曲激怒了欧洲人——业务决策、非程序化决策</li>
<li>高风险的直接投资方式——战略决策、非程序化决策、风险型决策</li>
</ol>
</li>
<li><strong>为了长期利益，迪斯尼可以做哪些计划工作？</strong><ol>
<li>实地考察当地人的风俗文化，开发适应性的休闲产品和服务</li>
<li>制定合理的收费标准，将盈利来源重点放在为客户提供优质的服务上</li>
<li>要善于听取行业和地域内专家的建设性意见</li>
<li>善待员工，让组织更高效的运转</li>
<li>深刻研究欧洲经济形势，并制定相应的发展策略</li>
<li>深入调查，在欧洲人并不重视的地方节省开销，降低成本</li>
<li>让一些欧洲人参与管理与决策，这样迪士尼便能真正知道欧洲人喜欢什么</li>
</ol>
</li>
<li><strong>你认为迪斯尼公司的决策、计划和战略面临哪些不确定环境因素的影响？为什么？</strong><ol>
<li>风俗文化的不确定性。欧洲文化史与美国历史迥然不同</li>
<li>经济形势的不确定性。老式欧洲思维与美国自由市场不同，同时欧洲经济衰退</li>
<li>生活习惯的不确定性。欧洲人与美国人生活习惯差异巨大</li>
</ol>
</li>
<li><strong>你如何认为在最后一段中所描写的欧洲人的反应？迪斯尼应该怎样做？</strong><ol>
<li>反应合理，每个地方的人都热爱自己本土的文化，并且由于欧洲传统文化的优越感，一直对美国文化的代表——迪士尼乐园多有排斥感，再加之迪士尼对欧洲文化的扭曲与不尊重，欧洲人自然发怒。</li>
<li>应该这么做<ul>
<li>迪士尼高层管理者应该坦诚公开致歉，撤下不恰当的产品，通过降价或其他活动适当弥补当地人</li>
<li>设立专案组，致力于开发当地人更喜爱的产品和服务</li>
</ul>
</li>
</ol>
</li>
<li><strong>这个案例对中国企业的跨国经营具有什么启示？结合你所了解的中国企业的跨国经营例子，谈谈中国企业要成功进入国际市场应注意什么？应从哪些方面做起？为什么？</strong><ol>
<li>启示：<ul>
<li>要深入调查当地文化，避免做出不恰当的举措</li>
<li>决策者应更注重交流，不可过分自信，盲目自大</li>
<li>组织内部要更好的协同合作，避免内部矛盾</li>
<li>精确的市场调研，确立目标市场</li>
<li>利用文化差异获得竞争优势</li>
<li>不可过分依赖某一地域的顾客，应长远的获取国际市场</li>
</ul>
</li>
<li>怎么做：<ul>
<li>善待员工，达成组织内部的高效运转</li>
<li>深入研究，开发本土人喜爱的产品和服务</li>
<li>深入研究当地的经济局势，适应性地调整经济战略</li>
<li>开发本土人喜爱的产品和服务</li>
<li>高层管理者和决策者应多交流，致力于指定正确的战略</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="决策的类型"><a href="#决策的类型" class="headerlink" title="决策的类型"></a>决策的类型</h2><p>1、按照决策的时间长短分类（长期和短期）</p>
<p>2、按照决策的主体分类（集体和个人）</p>
<p>3、按照决策需要解决的问题分类（初始和追踪） </p>
<p>4、按照决策活动的重要性分类（战略、战术和业务）</p>
<p>5、按照决策问题的可控程度分类（确定型、风险型和非确定型）</p>
<p>6、按照决策问题的重复性程度分类（程序化和非程序化）</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2018/10/25/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Linux是一个通用操作系统。一个操作系统要负责任务调度、内存分配、处理外围设备I/O等操作。操作系统通常由内核和系统程序（设备驱动、底层库、shell、服务程序等）两部分组成。</p>
<a id="more"></a>

<h3 id="1-Linux优点"><a href="#1-Linux优点" class="headerlink" title="1  Linux优点"></a>1  Linux优点</h3><ul>
<li>通用操作系统，不跟特定的硬件绑定。</li>
<li>用C语言编写，有可移植性，有内核编程接口。</li>
<li>支持多用户和多任务，支持安全的分层文件系统。</li>
<li>大量的实用程序，完善的网络功能以及强大的支持文档。</li>
<li>可靠的安全性和良好的稳定性，对开发者更友好。</li>
</ul>
<h3 id="2-Linux基础命令"><a href="#2-Linux基础命令" class="headerlink" title="2 Linux基础命令"></a>2 Linux基础命令</h3><p>Linux系统的通用命令格式：<strong>命令名称 [命名参数][命令对象]</strong></p>
<ol>
<li><p>获取登录信息：w / who / last</p>
</li>
<li><p>查看进程：ps</p>
</li>
<li><p>查看命令的说明：whatis</p>
<ul>
<li>whatis ps</li>
</ul>
</li>
<li><p>查看命令的位置：which / whereis</p>
<ul>
<li>whereis python</li>
</ul>
</li>
<li><p>查看帮助文档：man / info / apropos</p>
<ul>
<li>ps –help</li>
<li>man ps</li>
<li>info ps</li>
</ul>
</li>
<li><p>切换用户：su</p>
<ul>
<li>su Tom</li>
</ul>
</li>
<li><p>以管理员身份执行命令：sudo</p>
<ul>
<li>sudo ls /root</li>
</ul>
</li>
<li><p>登入登出相关：logout / exit / adduser / userdel / passwd / ssh</p>
</li>
<li><p>查看系统和主机名：uname / hostname</p>
</li>
<li><p>重启和关机：reboot / init 6 / shutdown / init 0</p>
</li>
<li><p>查看历史命令：history</p>
</li>
</ol>
<h3 id="3-Linux实用程序"><a href="#3-Linux实用程序" class="headerlink" title="3 Linux实用程序"></a>3 Linux实用程序</h3><h4 id="3-1-文件和文件夹操作"><a href="#3-1-文件和文件夹操作" class="headerlink" title="3.1 文件和文件夹操作"></a>3.1 文件和文件夹操作</h4><ol>
<li><p>创建/删除目录：mkdir / rmdir</p>
</li>
<li><p>创建/删除文件：touch / rm</p>
<ul>
<li>touch命令用于创建空白文件或修改文件时间。</li>
<li>在Linux系统中一个文件有三种时间：<ul>
<li>更改内容的时间（mtime）</li>
<li>更改权限的时间（ctime）</li>
<li>最后访问时间（atime）</li>
</ul>
</li>
</ul>
</li>
<li><p>切换和查看当前工作目录：cd / pwd</p>
</li>
<li><p>查看目录内容：ls</p>
</li>
<li><p>查看文件内容：cat / head / tail / more / less</p>
</li>
<li><p>拷贝/移动文件：cp / mv</p>
</li>
<li><p>查看文件及内容：find / grep</p>
</li>
<li><p>符号链接：ln</p>
</li>
<li><p>压缩和归档：gzip / gunzip / xz / tar</p>
</li>
<li><p>其他工具：sort / uniq / diff / file / wc</p>
</li>
</ol>
<h4 id="3-2-管道和重定向"><a href="#3-2-管道和重定向" class="headerlink" title="3.2 管道和重定向"></a>3.2 管道和重定向</h4><ul>
<li>管道的使用：|</li>
<li>输出重定向和错误重定向：&gt; / 2&gt;</li>
<li>输入重定向：&lt;</li>
</ul>
<h4 id="3-3-别名"><a href="#3-3-别名" class="headerlink" title="3.3 别名"></a>3.3 别名</h4><ul>
<li>alias</li>
<li>unalias</li>
<li>alias nasm=’/usr/local/bin/nasm’</li>
</ul>
<h4 id="3-4-其他程序"><a href="#3-4-其他程序" class="headerlink" title="3.4 其他程序"></a>3.4 其他程序</h4><ul>
<li>时间和日期：date / cal</li>
<li>录制操作脚本：script</li>
<li>给用户发送消息：mesg / write / wall / mail</li>
</ul>
<h3 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4 文件系统"></a>4 文件系统</h3><h4 id="4-1-目录结构"><a href="#4-1-目录结构" class="headerlink" title="4.1 目录结构"></a>4.1 目录结构</h4><ul>
<li>/bin - 基本命令的二进制文件</li>
<li>/boot - 引导加载程序的静态文件</li>
<li>/dev - 设备文件</li>
<li>/etc - 配置文件</li>
<li>/home - 用户主目录的父目录</li>
<li>/lib - 共享库文件</li>
<li>/lib64 - 共享64位库文件</li>
<li>/lost+found - 存放未链接文件</li>
<li>/media - 自动识别设备的挂载目录</li>
<li>/mnt - 临时挂载文件系统的挂载点</li>
<li>/opt - 可选插件软件包安装位置</li>
<li>/proc - 内核和进程信息</li>
<li>/root - root账户主目录</li>
<li>/run - 存放系统运行时需要的东西</li>
<li>/sbin - 超级用户的二进制文件</li>
<li>/sys - 设备的伪文件系统</li>
<li>/tmp - 临时文件夹</li>
<li>/usr - 用户应用目录</li>
<li>/var - 变量数据目录</li>
</ul>
<h4 id="4-2-访问权限"><a href="#4-2-访问权限" class="headerlink" title="4.2 访问权限"></a>4.2 访问权限</h4><ul>
<li>chmod</li>
<li>chown</li>
</ul>
<h4 id="4-3-磁盘管理"><a href="#4-3-磁盘管理" class="headerlink" title="4.3 磁盘管理"></a>4.3 磁盘管理</h4><ul>
<li>列出文件系统的磁盘使用状况 - df</li>
<li>磁盘分区表操作 - fdisk</li>
<li>格式化文件系统 - mkfs</li>
<li>文件系统检查 - fsck</li>
<li>挂载/卸载 - mount / umount</li>
</ul>
<h3 id="5-环境变量"><a href="#5-环境变量" class="headerlink" title="5 环境变量"></a>5 环境变量</h3><ul>
<li>HOME</li>
<li>SHELL</li>
<li>HISTSIZE</li>
<li>RANDOM</li>
<li>PATH</li>
</ul>
<h3 id="6-软件安装和配置"><a href="#6-软件安装和配置" class="headerlink" title="6 软件安装和配置"></a>6 软件安装和配置</h3><h4 id="6-1-yum"><a href="#6-1-yum" class="headerlink" title="6.1 yum"></a>6.1 yum</h4><ul>
<li>yum update</li>
<li>yum install / yum remove</li>
<li>yum list / yum search</li>
<li>yum makecache</li>
</ul>
<h4 id="6-2-rpm"><a href="#6-2-rpm" class="headerlink" title="6.2 rpm"></a>6.2 rpm</h4><ul>
<li>rpm -ivh –force –nodeps</li>
<li>rpm -e</li>
<li>rpm -qa | grep</li>
</ul>
<h3 id="7-网络访问和管理"><a href="#7-网络访问和管理" class="headerlink" title="7 网络访问和管理"></a>7 网络访问和管理</h3><ol>
<li>通过网络获取资源 - <strong>wget</strong>。<ul>
<li>-b 后台下载模式</li>
<li>-O 下载到指定的目录</li>
<li>-r 递归下载</li>
</ul>
</li>
<li>显示/操作网络配置（旧） - <strong>ipconfig</strong>。</li>
<li>显示/操作网络配置（新） - <strong>ip</strong>。</li>
<li>网络可达性检查 - <strong>ping</strong>。</li>
<li>查看网络服务和端口 - <strong>netstat</strong>。</li>
<li>安全文件拷贝 - <strong>scp</strong>。</li>
<li>安全文件传输 - <strong>sftp</strong>。</li>
</ol>
<h3 id="8-课程学习"><a href="#8-课程学习" class="headerlink" title="8 课程学习"></a>8 课程学习</h3><ol>
<li>文件系统的启动过程：<ul>
<li><strong>BIOS –&gt; MBR –&gt; Boot loader –&gt; Init process –&gt; Done</strong></li>
<li>BIOS检查设备 –&gt; 加载并启动MBR –&gt; 加载MBR中的bootloader（常见有LILO和GRUB两种） –&gt; 启动Linux内核 –&gt; 完成（现在控制权已交给内核）</li>
</ul>
</li>
<li>硬链接和符号链接<ul>
<li>硬链接（不同的文件名对应同一个inode，不能跨越文件系统，对应系统调用<strong>link</strong>）：<ul>
<li><strong>ln</strong> 可以为文件创建硬链接，但不能为目录创建，硬链接并没有建立新文件</li>
<li>创建硬链接后，文件的inode会被多个文件项共用</li>
<li>文件的硬链接数可以在ls -l后的列表的第二列看到，无额外链接的文件的链接数为1</li>
<li>硬链接可以理解为多个文件指向同一个物理地址，所以不能对目录做硬链接，也不可以在不同的文件系统之间做硬链接</li>
</ul>
</li>
<li>软链接/符号链接（存储被链接文件的文件名与路径，可跨越文件系统，对应系统调用<strong>symlink</strong>）：<ul>
<li><strong>ln -s</strong> 将一个路径名链接到一个文件</li>
<li>软链接文件是一个文本文件，包含了链接时的源文件的路径名，而源文件才是实际包含数据的文件</li>
<li>软链接文件在<strong>ls -l</strong>中第一列显示一个<strong>l</strong>，表示符号链接文件（硬链接的第一列依然是<strong>-</strong>，表示文件）</li>
<li>软链接可以理解为快捷方式（通过它能迅速找到源文件，而不是直接找物理地址），它本身确实是一个新的文件，它的大小就是符号链接中路径的字节数，所以它具有和源文件不同的inode号</li>
<li>软链接可以对目录进行，也可以在不同的文件系统之间做符号链接</li>
</ul>
</li>
</ul>
</li>
<li>文件属性（<strong>ls -l</strong>）:文件类型 权限 硬链接数目 所有者 用户组 文件大小 修改时间 文件名</li>
<li>umask命令与默认权限<ul>
<li>umask命令用来设置限制新建文件权限的掩码</li>
<li>当新文件创建时，其最初的权限由默认权限与umask掩码共同决定。文件的默认权限是666，即rw-rw-rw-，目录的默认权限是777，即rwxrwxrwx。而在此基础之上，umask设置的掩码将会从以上权限中把相应位置的权限拿走（即删去指定位的权限）</li>
<li>如umask设置的掩码为022，那么新文件的权限上用户组和其他用户的write权限就会被拿走，也就是文件权限变成了644，即rw-r-r-，而新建文件夹的权限也变成了rwxr-xr-x，即755</li>
<li>umask掩码的作用是“拿走”相应位置上的权限（不管之前有没有，最终这个位置没有权限）</li>
<li>数字表示：<strong>umask</strong> 将会显示删掉的权限（如掩码022）</li>
<li>符号表示：<strong>umask -S</strong> 将会显示剩下的权限（如u=rwx,g=rx,o=rx）</li>
</ul>
</li>
<li>三种执行shell脚本的方法<ul>
<li>作为可执行程序：<ul>
<li><strong>chmod +x ./x.sh</strong> 使脚本具有可执行权限</li>
<li><strong>./x.sh</strong> 执行脚本</li>
</ul>
</li>
<li>作为解释器参数：<ul>
<li><strong>sh x.sh</strong> 或 <strong>/bin/sh x.sh</strong></li>
<li>这种方式不需要在脚本第一行指定解释器参数，即<strong>#!/bin/bash</strong></li>
</ul>
</li>
<li><strong>source x.sh</strong> 或 <strong>. x.sh</strong></li>
</ul>
</li>
<li>shell中的引号：<ul>
<li>单引号：单引号中的任何字符都会原样输出，转义失败，变量也是无效的</li>
<li>双引号：里面可以有变量，也可以出现转义字符（即$ 、``、 \将分别被bash解释）</li>
</ul>
</li>
<li>两个接口：<ul>
<li>用户与内核的接口：系统调用</li>
<li>用户与操作系统的接口：shell</li>
</ul>
</li>
<li>硬盘属于块设备 （block devices）</li>
<li>找出 /etc/my.conf 文件属于哪个包 （package）：<strong>rpm -qf /etc/my.conf</strong></li>
<li>用于改变 IDE 硬盘的设置：<strong>hdparm</strong></li>
<li>列出定义在以后特定时间运行一次的所有任务：<strong>atq</strong></li>
<li>改变命令提示符：<strong>set PS1=”[\u\w\t]\$” ; export PS1</strong></li>
<li>/etc/passwd和/etc/shadow两个文件的权限：<strong>-rw-r–r–</strong> , <strong>-r————</strong></li>
<li>查看Linux的启动信息：<strong>dmesg</strong></li>
<li>显示系统中各个分区中inode的使用情况：<strong>df -i</strong></li>
<li>显示 passwd 文件的结构：<strong>man 5 passwd</strong></li>
<li>检测基本网络连接：<strong>netstat</strong></li>
<li>网络服务的daemon是：<strong>netd</strong></li>
<li>定义bash环境的用户文件是：<strong>.bashrc</strong> &amp; <strong>.bash_profile</strong></li>
<li>卸载一个内核模块：<strong>rmmod</strong></li>
<li>显示所有装载的模块：<strong>lsmod</strong></li>
</ol>
<h3 id="9-查缺补漏"><a href="#9-查缺补漏" class="headerlink" title="9 查缺补漏"></a>9 查缺补漏</h3><ol>
<li><p>信号量属于SYSTEM V进程间通讯方式</p>
</li>
<li><p>Linux系统中，用户文件描述符0、1、2分别表示：标准输入、标准输出、标准错误输出</p>
</li>
<li><p>卸载一个软件包：rpm -e</p>
</li>
<li><p>关于i节点：</p>
<ul>
<li>i节点能描述文件占用的块数</li>
<li>i节点描述了文件大小和指向数据块的指针</li>
<li>通过i节点实现文件的逻辑结构和物理结构的转换</li>
<li>这是<strong>错误</strong>的：<strong>i节点和文件是一一对应的</strong></li>
</ul>
</li>
<li><p>在vi编辑器中的命令模式下，重复上一次对编辑的文本进行的操作，可使用 <strong>.</strong> 命令</p>
</li>
<li><p>Linux系统的进程类型：守护进程、交互进程、批处理进程</p>
</li>
<li><p>关于/etc/fstab文件描述：启动时按fstab文件描述内容加载文件系统</p>
</li>
<li><p>在Shell脚本中，用来读取文件内各个域的内容并将其赋值给Shell变量的命令是：<strong>read</strong></p>
</li>
<li><p>在Linux2.4.0版本中：</p>
<ul>
<li>进程有<strong>6</strong>种状态：可运行、可中断等待、不可中断等待、僵死、暂停、独占（替换了原来的交换）</li>
<li>进程使用<strong>exit</strong>系统调用后进入僵死状态</li>
</ul>
</li>
<li><p>在Linux 中管道分为<strong>2</strong>种类型，若创建或打开时获得的描述符存放在fd中，则fd[1]是<strong>管道写描述符</strong></p>
</li>
<li><p>Linux为用户提供的接口有：shell、XWINDOW、系统调用</p>
</li>
<li><p>超级块是描述<strong>文件系统属性</strong>信息的数据结构，索引节点是描述<strong>文件属性</strong>信息的数据结构</p>
</li>
<li><p>显示文件系统空间使用情况：<strong>df</strong> 命令</p>
</li>
<li><p>显示目录或文件占用磁盘空间容量：<strong>du</strong> 命令</p>
</li>
<li><p>命令组合<strong>（命令表）</strong>将<strong>建立新的子进程</strong>来执行命令</p>
</li>
<li><p>磁盘限额管理可以使用<strong>quota</strong>软件工具，其中硬限额的容量应该<strong>大于</strong>软限额</p>
</li>
<li><p>交换线程通过三种途径来缩减已使用的内存页面:</p>
<ul>
<li>减少buffer cache和page cache的大小</li>
<li>换出系统V类型的内存页面</li>
<li>换出或丢弃进程占用的页面</li>
</ul>
</li>
<li><p>安装Linux系统对硬盘分区时，必须有两种分区类型：<strong>Linux原始分区（根分区）</strong> 和 <strong>Linux交换分区</strong></p>
</li>
<li><p>在Linux的两种链接文件中，只能实现对文件链接的一种方式是：<strong>软链接（符号链接）</strong></p>
</li>
<li><p>Linux主要采用了<strong>请求调页</strong>和<strong>写时复制</strong>两种动态内存管理技术实现了物理内存以On demand方式动态分配</p>
</li>
<li><p>对于<strong>System V</strong>类型的共享内存页面，Linux基于<strong>Clock</strong>算法决定哪些页面应当被换出物理内存</p>
</li>
<li><p>在Linux与中断相关的三个核心数据结构中，用做抽象的中断控制器的数据结构是<strong>hw_interrupt_type</strong>，它包含一系列处理中断控制器特有的操作</p>
</li>
<li><p>通过将<strong>request</strong>动态链入块设备控制结构blk_dev_struct，Linux设备管理器有效的实现了物理设备和缓冲区之间的异步读写通讯</p>
</li>
<li><p>归档与解压命令：</p>
<ul>
<li><p>压缩</p>
<ul>
<li>命令格式：<strong>tar -zcvf 压缩命令的目标文件 待压缩的源文件</strong></li>
<li>例如：<strong>tar -zcvf wang.tar.gz /home/stud1/wang</strong>将/home/stud1/wang目录做归档压缩，压缩后生成wang.tar.gz文件，并将此文件保存到/home目录下</li>
</ul>
</li>
<li><p>解压：</p>
<ul>
<li>命令格式：<strong>tar -zxvf 待解压文件</strong></li>
<li>例如：<strong>tar -zxvf wang.tar.gz</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>对于Shell脚本程序，若输入参数数量多于9个，则程序遍历每个参数可通过使用<strong>shift</strong>命令实现</p>
</li>
<li><p>在System V进程通讯方式中，ipc_perm结构描述对一个系统IPC对象的存取权限，而用于定位IPC对象的引用标志符key可以依据键值分成<strong>公有</strong>、<strong>私有</strong>两种类型</p>
</li>
<li><p>底半技术：</p>
<ul>
<li>把一个中断处理分为2部分：顶半部分和底半部分</li>
<li>优势：<ul>
<li>使中断的总延迟时间最小化</li>
<li>加快对中断请求的响应速度</li>
<li>合并某些中断处理</li>
</ul>
</li>
</ul>
</li>
<li><p>Vi的工作模式</p>
<ul>
<li>三种工作模式：命令模式、输入模式、末行模式</li>
<li>如何切换模式：在命令模式下输入a、A、i、I、o、O等命令之一可以进入输入模式，在输入模式下按Esc键回到命令模式；在命令模式下输入：进入末行模式，末行命令执行完后回到命令模式</li>
</ul>
</li>
<li><p>Shell变量可以分为：用户自定义变量、环境变量、位置变量、特殊变量，其中<strong>位置变量</strong>是指命令行上传递给程序的参数</p>
</li>
<li><p>从内核实现的角度说明Linux进程共享文件的方式：</p>
<ul>
<li>进程通过多个file结构共享一个inode</li>
<li>进程共享一个file结构</li>
</ul>
</li>
<li><p>实时信号、非实时信号、可靠信号、不可靠信号：</p>
<ul>
<li>实时信号目前未用</li>
<li>非实时信号编号1～31、0表示空信号，非实时信号没有排队机制，可能丢失</li>
<li>不可靠信号0～31，不可靠信号每次处理完信号后，都将对信号的响应设置为默认动作，需要在结尾再次安装信号</li>
<li>可靠信号32～63，可靠信号和不可靠信号的安装函数也不同，主要在于信号类型取值，而不在于操纵他们的API</li>
</ul>
</li>
<li><p>Kswapd核心线程的动态特性：主要通过nr_async_pages参考free_pages_high和free_pages_low来判断交换数量和线程睡眠时间</p>
<ul>
<li>Nr_async_pages大于free_pages_high时每次释放6个页面，在free_pages_high和free_pages_low之间时释放3个，小于free_pages_low时不释放</li>
<li>若Kswapd被唤醒后发现Nr_async_pages小于free_pages_low则睡眠时间加班，反之则逐步延长睡眠时间    </li>
</ul>
</li>
<li><p>Linux通过i节点表将文件的逻辑结构和物理结构进行转换：</p>
<ul>
<li>i节点是一个64字节长的表，表中包含了文件的相关信息，其中有文件的大小、文件所有者、文件的存取许可方式以及文件的类型等重要信息</li>
<li>在i节点表中最重要的内容是磁盘地址表。在磁盘地址表中有13个块号，文件将以块号在磁盘地址表中出现的顺序依次读取相应的块。若文件空间大于13块，则分别用1次、2次、3次间接块实现对数据块的定位</li>
<li>此后，Linux文件系统通过把i节点和文件名进行连接，当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的i节点号，通过该i节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构</li>
</ul>
</li>
<li><p>在Linux系统中运行下面程序，最多可产生多少个进程？画出进程家族树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   fork();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   fork();</span></pre></td></tr><tr><td class="code"><pre><span class="line">   fork();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>最多可以产生7个进程，家族树如下：</p>
<p><img src="/assets/blogimg/fork.png" alt=""></p>
</li>
<li><p>统计文件<strong>file</strong>中所有包含字符串<strong>”WHU”</strong>的行数：<strong>grep WHU file | wc -l</strong></p>
</li>
<li><p>可以把两个文本文件合并成一个文件的命令是：<strong>cat</strong></p>
</li>
<li><p>为了统计文件系统中未用的磁盘空间，可以用命令：<strong>du</strong></p>
</li>
<li><p>Linux中内核进程init的进程标识符是：<strong>1</strong></p>
</li>
<li><p>proc文件系统存在于：<strong>内存</strong></p>
</li>
<li><p>只列出目录下的子目录：<strong>ls -F | grep /$</strong></p>
</li>
<li><p>统计某个目录下的文件数：<strong>ls -l * | grep “^-“ | wc -l</strong></p>
</li>
<li><p>统计某个目录下的目录数：<strong>ls -l * | grep “^d” | wc -l</strong></p>
</li>
<li><p>内核分为<strong>进程调度</strong>、<strong>内存管理</strong>、<strong>虚拟文件系统</strong>、<strong>网络接口</strong>、<strong>进程间通信</strong>等五个子系统</p>
</li>
<li><p>在Linux 中，进程的优先数值越<strong>小</strong>，其相应的优先权越<strong>高</strong></p>
</li>
<li><p>在Linux 中，用户账号包括<strong>超级用户</strong>、<strong>系统用户</strong>和<strong>普通用户</strong></p>
</li>
<li><p>信号与中断</p>
<ul>
<li>相似点<ul>
<li>采用了相同的异步通信方式</li>
<li>当检测出有信号或中断请求时，都暂停正在执行的程序而转去执行相应的处理程序</li>
<li>都在处理完毕后返回到原来的断点</li>
<li>对信号或中断都可进行屏蔽</li>
</ul>
</li>
<li>区别<ul>
<li>中断有优先级，而信号没有优先级，所有的信号都是平等的</li>
<li>信号处理程序是在用户态下运行的，而中断处理程序是在核心态下运行</li>
<li>中断响应是及时的，而信号响应通常都有较大的时间延迟</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux的引导程序：<strong>LILO和GRUB</strong></p>
<ul>
<li>LILO没有交互式命令界面，而Grub拥有</li>
<li>LILO不支持网络引导，而Grub支持</li>
<li>LILO将关于可以引导的操作系统位置的信息物理上存储在MBR中，如果修改了LILO配置文件，必须将LILO第一阶段引导加载程序重写到MBR。相对于Grub，这是一个更为危险的选择，因为错误配置的MBR可能会让系统无法引导。而使用Grub，如果配置文件配置错误，则只是默认转到Grub命令行界面。</li>
</ul>
</li>
<li><p>在LINUX运行的7个级别中，X—WINDOWS图形系统的运行级别为：<strong>5</strong></p>
</li>
<li><p>选择 “文本登录方式” 设定系统开始运行级为：<strong>3</strong></p>
</li>
<li><p>若在文字界面下，需要键入何种指令才能进入图形界面（Xwindow）：<strong>startx</strong></p>
</li>
<li><p>Linux内核引导时，从文件<strong>/etc/fstab</strong>中读取要加载的文件系统</p>
</li>
<li><p>用来存放系统所需要的配置文件和子目录的目录是<strong>/etc</strong></p>
</li>
<li><p>关闭linux系统（不重新启动）使用的命令：<strong>halt</strong></p>
</li>
<li><p>该命令可以实现关机：<strong>init 0</strong></p>
</li>
<li><p>存放Linux基本命令的目录是：<strong>/bin</strong></p>
</li>
<li><p>在shell编程时，使用方括号表示测试条件的规则是：方括号两边必有<strong>空格</strong></p>
</li>
<li><p>当系统管理员需升级内核版本和改变系统硬件配置时，应<strong>重新编译内核</strong></p>
</li>
<li><p><strong>Slab分配器思想</strong></p>
<ul>
<li>小对象的申请和释放通过slab分配器来管理</li>
<li>slab分配器有一组高速缓存，每个高速缓存保存同一种对象类型，如i节点缓存、PCB缓存等</li>
<li>内核从它们各自的缓存中分配和释放对象。系统分配对象时就从slab中取得。首先从这个cache中部分满的slab中分配，如果没有这样的slab, 便从空的slab中分配，如果也没有，就创建一个新的slab来分配即可。由于每个对象在释放时几乎处于分配好并且初始化好的状态，还可以节省不少初始化的时间</li>
<li>每种对象的缓存区由一连串slab构成，每个slab由一个或者多个连续的物理页面组成。这些页面种包含了已分配的缓存对象，也包含了空闲对象</li>
</ul>
</li>
<li><p><strong>Linux系统进程调度的总体思想</strong></p>
<p>实时进程优先于普通进程，实时进程以进程的紧急程度为优先顺序，普通进程以进程平等占用CPU时间为基本调度原则。</p>
</li>
<li><p><strong>Linux 内核的主要组成部分</strong></p>
<ul>
<li><p>进程调度负责控制进程对CPU的访问，调度程序使用一种策略确保所有的进程都能公平的访问CPU，并且确保内核在任意时刻能执行必要的硬件操作。</p>
</li>
<li><p>内存管理负责管理系统的物理内存，实现多进程安全享享计算机的内存。  </p>
</li>
<li><p>虚拟文件系统通过将各种设备抽象为一种公共接口，从而屏蔽了各种硬件设备的细节。虚拟文件系统可以分为逻辑文件系统和设备驱动程序两部分。</p>
</li>
<li><p>网络接口提供了对各种网络标准的存取和各种网络硬件的支持，实现了对各种网络标准和网络硬件的访问。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。</p>
</li>
<li><p>进程间通信子系统实现了系统内部进程间的多种通信机制。</p>
</li>
</ul>
<p>这五个子系统互相依赖，但相对来说进程调度处在比较重要的地位。其他子系统需要挂起和恢复进程的运行都必须依靠进程调度子系统的参与。</p>
</li>
<li><p><strong>基于虚拟内存技术的程序执行两次映射</strong></p>
<ul>
<li>应用程序向虚拟内存映射：用虚拟地址为程序编址，映射到虚拟内存空间；确定其代码段、数据段和堆栈段的地址空间，系统以逻辑地址访问虚拟内存中的某个程序段</li>
<li>把要运行的程序段复制到物理内存，映射到物理内存空间，确定程序的物理地址。虚拟内存逻辑地址与物理地址的对应记录表；系统自物理内存地址读取所需数据</li>
</ul>
</li>
<li><p><strong>Buddy算法-伙伴算法</strong></p>
<ul>
<li>把内存中所有页面按照2n划分，其中n=0~5，每个内存空间按1个页面、2个页面、4个页面、8个页面、16个页面、32个页面进行六次划分。划分后形成了大小不等的存储块，称为页面块，简称页块。包含1个页面的页块称为1页块，包含2个页面的称为2页块，依此类推。每种页块按前后顺序两两结合成一对Buddy“伙伴”</li>
<li>每个页块组用一个双向循环链表进行管理，共有６个链表，分别为1、2、4、8、16、32页块链表。分别挂到free_area[] 数组上</li>
<li>内存分配时，系统按照Buddy算法，根据请求的页面数在free_area[]对应的空闲页块组中搜索。若请求页面数不是2的整数次幂，则按照稍大于请求数的2的整数次幂的值搜索相应的页面块组。当相应页块组中没有可使用的空闲页面块时就查询更大一些的页块组，在找到可用的空闲页面块后，分配所需页面</li>
<li>当某一空闲页面块被分配后，若仍有剩余的空闲页面，则根据剩余页面的大小把它们加入到相应页块组中</li>
<li>内存页面释放时，系统将其做为空闲页面看待。检查是否存在与这些页面相邻的其它空闲页块，若存在，则合为一个连续的空闲区按Buddy算法重新分组</li>
</ul>
</li>
<li><p><strong>linux使用的进程间通信方式</strong></p>
<ul>
<li>管道（pipe）和有名管道（FIFO）</li>
<li>信号（signal）</li>
<li>消息队列：msgget可以创建一个新队列或打开一个存在的队列.  msgctl类似于驱动程序中的ioctl函数, 可对消息队列执行多种操作. 调用msgsnd将数据放到消息队列中. 调用msgrcv将从消息队列中取消息</li>
<li>共享内存：linux进程调用shmget（Shared Memory GET，获取共享内存）来分配一个共享内存块。shmat（SHared Memory Attach，绑定到共享内存）。shmctl（”Shared Memory Control”，控制共享内存）函数会返回一个共享内存块的相关信息。同时 shmctl 允许程序修改这些信息</li>
<li>信号量</li>
<li>套接字（socket)</li>
</ul>
</li>
<li><p>运行级别</p>
<p>运行级别是操作系统当前运行的功能级别，从0到6有不同的功能，在/etc/inittab文件中定义。运行级别可以由超级用户通过 telinit 命令来转换，此命令可以将转换信号传递给init，告诉它切换到哪个运行级别。也可以通过修改/etc/inittab文件来进行缺省运行级别的修改。</p>
<ul>
<li>0 - 关机（千万不要把initdefault 设置为0 ）</li>
<li>1 - 单用户模式，root权限，用于系统维护，禁止远程登陆</li>
<li>2 - 多用户模式，但是没有 NFS </li>
<li>3 - 完全多用户模式，标准运行级别，登录后进入命令行模式</li>
<li>4 - 没有用到，保留</li>
<li>5 - 多用户模式，X11控制台，登录后进入图形GUI模式</li>
<li>6 - 重启（千万不要把initdefault 设置为6 ）</li>
</ul>
</li>
</ol>
<h3 id="11-Shell编程"><a href="#11-Shell编程" class="headerlink" title="11 Shell编程"></a>11 Shell编程</h3><ol>
<li><p>以用户账号zheng，登录进入linux系统，查看当前登录到系统中的用户和当前系统运行的进程，再退出系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">login：zheng</span></pre></td></tr><tr><td class="code"><pre><span class="line">Password：口令</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">who</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ps</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">Ctrl+D</span></span></pre></td></tr></table></figure>
</li>
<li><p>在当前目录/home/zheng下新建一个目录back，将当前目录改为back，在back下新建2个长度为0的文件test1、test2，然后把test2移到其父目录中并改名为file12</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir back</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> back</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch  test1 test2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mv  test2   ../file2</span></span></pre></td></tr></table></figure>
</li>
<li><p>统计当前目录/home/zheng下普通文件的数目并显示结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">find –<span class="built_in">type</span> f | wc –l</span></span></pre></td></tr></table></figure>
</li>
<li><p>系统管理员需要增加一个新用户zheng，为其设置初始密码，锁定用户账号uly，并删除用户账号chang</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">useradd zheng</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">passwd  zheng</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">passwd –l uly</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">userdel chang</span></span></pre></td></tr></table></figure>
</li>
<li><p>将/home/zheng目录下的所有文件打包压缩成/tmp/zheng.tar.gz，怎么做？从压缩包中恢复，又该怎么做？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">tar –zcvf  /tmp/zheng.tar.gz  /home/zheng</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">tar -zxvf /tmp/zheng.tar.gz</span></span></pre></td></tr></table></figure>
</li>
<li><p>Shell程序添加一个新组为class1，添加属于这个组的30个用户，用户名形式为stdxx，xx从01到30</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">i=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">groupadd class1</span></pre></td></tr><tr><td class="code"><pre><span class="line">while [ $i -le 30 ]								</span></pre></td></tr><tr><td class="code"><pre><span class="line">do</span></pre></td></tr><tr><td class="code"><pre><span class="line">if [ $i -le 9 ] ;then</span></pre></td></tr><tr><td class="code"><pre><span class="line">USERNAME=stu0$&#123;i&#125;							</span></pre></td></tr><tr><td class="code"><pre><span class="line">else</span></pre></td></tr><tr><td class="code"><pre><span class="line">USERNAME=stu$&#123;i&#125;							</span></pre></td></tr><tr><td class="code"><pre><span class="line">fi</span></pre></td></tr><tr><td class="code"><pre><span class="line">useradd $USERNAME 							</span></pre></td></tr><tr><td class="code"><pre><span class="line">mkdir /home/$USERNAME</span></pre></td></tr><tr><td class="code"><pre><span class="line">chown -R $USERNAME /home/$USERNAME		</span></pre></td></tr><tr><td class="code"><pre><span class="line">chgrp -R class1 /home/$USERNAME </span></pre></td></tr><tr><td class="code"><pre><span class="line">i=$(($i + 1))	＃或let “i=i+1”					</span></pre></td></tr><tr><td class="code"><pre><span class="line">done</span></pre></td></tr></table></figure>
</li>
<li><p>写一个Shell程序，接收用户从键盘输入的100个整数，求出其总和、最大值及最小值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">read max</span></pre></td></tr><tr><td class="code"><pre><span class="line">min=$max</span></pre></td></tr><tr><td class="code"><pre><span class="line">sum=$max</span></pre></td></tr><tr><td class="code"><pre><span class="line">i=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">while [$i –lt 100]</span></pre></td></tr><tr><td class="code"><pre><span class="line">do</span></pre></td></tr><tr><td class="code"><pre><span class="line">	read  x </span></pre></td></tr><tr><td class="code"><pre><span class="line">	sum=`expr $sum + $x`</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if [ $max –lt  $x ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	then</span></pre></td></tr><tr><td class="code"><pre><span class="line">		max=$x</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fi</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if [ $ x –lt  $min ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	then</span></pre></td></tr><tr><td class="code"><pre><span class="line">		min=$x</span></pre></td></tr><tr><td class="code"><pre><span class="line">	fi    </span></pre></td></tr><tr><td class="code"><pre><span class="line">	i=`expr $i + 1`</span></pre></td></tr><tr><td class="code"><pre><span class="line">done</span></pre></td></tr><tr><td class="code"><pre><span class="line">echo "sum = $sum ;   max = $max    min = $min "</span></pre></td></tr></table></figure>
</li>
<li><p>在/home目录下查找文件名为<strong>.Profile</strong>的文件，找到后删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home -name .profile -exec rm &#123;&#125; \;</span></pre></td></tr></table></figure>
</li>
<li><p>创建一个用户，用户名为user02，所属私有组和标准组为stuff，用户家目录为/home/user2，用户登陆shell为/bin/bash</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd –g stuff –G stuff -d /home/user2 -s /bin/bash user02</span></pre></td></tr></table></figure>
</li>
<li><p>写一个shell脚本，检查给出的串是否为回文（palindrome）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">echo "Enter string"</span></pre></td></tr><tr><td class="code"><pre><span class="line">read str</span></pre></td></tr><tr><td class="code"><pre><span class="line">len=`echo $str | wc -c`</span></pre></td></tr><tr><td class="code"><pre><span class="line">len=`expr $len - 1`</span></pre></td></tr><tr><td class="code"><pre><span class="line">l=`expr $len / 2`</span></pre></td></tr><tr><td class="code"><pre><span class="line">ctr=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">flag=0</span></pre></td></tr><tr><td class="code"><pre><span class="line">while test $ctr -le $l</span></pre></td></tr><tr><td class="code"><pre><span class="line">do</span></pre></td></tr><tr><td class="code"><pre><span class="line">a=`echo $str | cut -c$ctr`</span></pre></td></tr><tr><td class="code"><pre><span class="line">b=`echo $str | cut -c$len`</span></pre></td></tr><tr><td class="code"><pre><span class="line">if test $a -ne $b</span></pre></td></tr><tr><td class="code"><pre><span class="line">then flag=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">break</span></pre></td></tr><tr><td class="code"><pre><span class="line">fi</span></pre></td></tr><tr><td class="code"><pre><span class="line">ctr=`expr $ctr + 1`</span></pre></td></tr><tr><td class="code"><pre><span class="line">len=`expr $len - 1`</span></pre></td></tr><tr><td class="code"><pre><span class="line">done</span></pre></td></tr><tr><td class="code"><pre><span class="line">if test $flag -eq 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">then echo "String is palindrome"</span></pre></td></tr><tr><td class="code"><pre><span class="line">else echo "String not a palindrome"</span></pre></td></tr><tr><td class="code"><pre><span class="line">fi</span></pre></td></tr></table></figure>
</li>
<li><p>用shell编写小九九乘法表程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">for i in 1 2 3 4 5 6 7 8 9</span></pre></td></tr><tr><td class="code"><pre><span class="line">do</span></pre></td></tr><tr><td class="code"><pre><span class="line">	for j in 1 2 3 4 5 6 7 8 9</span></pre></td></tr><tr><td class="code"><pre><span class="line">	do</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if ( test $j -le $i ) then</span></pre></td></tr><tr><td class="code"><pre><span class="line">			echo -ne `expr $i \* $j` "\t"</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else</span></pre></td></tr><tr><td class="code"><pre><span class="line">		echo</span></pre></td></tr><tr><td class="code"><pre><span class="line">			break </span></pre></td></tr><tr><td class="code"><pre><span class="line">		fi </span></pre></td></tr><tr><td class="code"><pre><span class="line">	done</span></pre></td></tr><tr><td class="code"><pre><span class="line">done</span></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="12-其他"><a href="#12-其他" class="headerlink" title="12 其他"></a>12 其他</h3><ol>
<li><p>进程编程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ntimes=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> pid,ppid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int p_action( ), c_action( );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    signal(SIGUSR1 , p_action);  # 在父进程中为信号SIGUSR1绑定函数p_action</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">switch</span>(pid=fork( )) &#123;  # 创建子进程</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> <span class="number">-1</span>: perror(<span class="string">"fork failed?"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="built_in">exit</span>(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: signal(SIGUSR1,c_action);</span></pre></td></tr><tr><td class="code"><pre><span class="line">				ppid=getppid( );</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">for</span> ( ; ; ) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">default</span>: &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span>( ; ; ) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					pause;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					sleep(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">					kill(pid,SIGUSR1);  # 向子进程发送信号SIGUSR1</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">p_action( ) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent caught signal #%d\n"</span>,++ntimes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">c_action( ) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"child caught signal #%d\n"</span>,++ntimes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ppid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ppid = getppid();  # 获取父进程的PID</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kill(ppid, SIGUSR1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep(<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>父进程无限循环向子进程发送信号，子进程收到信号后向父进程发送相同信号，父子进程之间各自记录全局变量的变化，前6行结果如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">child caught signal <span class="comment">#1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">parent caught signal <span class="comment">#1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">child caught signal <span class="comment">#2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">parent caught signal <span class="comment">#2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">child caught signal <span class="comment">#3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">parent caught signal <span class="comment">#3</span></span></pre></td></tr></table></figure>
</li>
<li><p>linux 进程及管道应用实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n,fd[<span class="number">2</span>];  <span class="comment">// 这里的fd是文件描述符的数组，用于创建管道做准备	</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">pid_t</span> pid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[<span class="number">100</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(pipe(fd)&lt;<span class="number">0</span>)  <span class="comment">// 创建管道</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe create error/n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>((pid=fork())&lt;<span class="number">0</span>)  <span class="comment">// 利用fork()创建新进程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error/n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;  <span class="comment">// 这里是父进程，先关闭管道的读出端，然后在管道的写端写入“hello world"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">"hello word/n"</span>,<span class="number">11</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);  <span class="comment">// 这里是子进程，先关闭管道的写入端，然后在管道的读出端读出数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        n= <span class="built_in">read</span>(fd[<span class="number">0</span>],<span class="built_in">line</span>,<span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO,<span class="built_in">line</span>,n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>直面挑战，重建战略</title>
    <url>/2018/10/08/%E7%9B%B4%E9%9D%A2%E6%8C%91%E6%88%98%EF%BC%8C%E9%87%8D%E5%BB%BA%E6%88%98%E7%95%A5/</url>
    <content><![CDATA[<p>读迈克尔·波特《什么是战略》有感。</p>
<a id="more"></a>

<p>文章一开始，波特就告诉我们：运营效益并不是战略。然而近20年来，各种管理工具和技巧的应用所带来的巨大收益，让企业管理者误认为运营效益就是战略。实质上，战略就是创造一种独特、有利的定位，涉及各种不同的营运活动。企业管理者要对战略有一个充分的认知，更要积极迈出战略重建的第一步。</p>
<h3 id="运营效益与战略"><a href="#运营效益与战略" class="headerlink" title="运营效益与战略"></a>运营效益与战略</h3><p>前者讨论的是持续变革、组织弹性以及如何实现最佳实践。而后者着重于独特定位的界定、如何做出明智的取舍以及如何加强各项活动之间的配称性。两者都是企业实现卓越绩效的关键内容，但是它们成效的方式不同。运营效益指相似的运营活动比竞争对手做的更出色，通过追求生产率、质量和速度，企业在运营效益上具有显著优势。但要靠这种高效、高质的运营效益来应对市场上的激烈竞争是远远不够的，何况很多企业根本无法将运营效益做到专业水准。这时候，战略重建便是一条康庄大道。战略定位意味着从事有别于竞争对手的运营活动，实施方式也与对手不同。要想在竞争中脱颖而出，企业必须有一种能长期保持的具有差异性的竞争优势。服务于运营效益的最佳实践容易被竞争对手模仿，而建立在独特运营活动之上的战略却有很高的保护墙，竞争对手很难模仿，并且很难成功布局和实施新战略。</p>
<h3 id="战略定位"><a href="#战略定位" class="headerlink" title="战略定位"></a>战略定位</h3><p>定位是如何在顾客心中建立特殊区间，是我们的品牌置于其中。简单的说，我们的战略定位就是顾客买我们的产品而不买竞争对手产品的理由。波特提出的战略定位三原点立足于行业、需求和途径，三者往往有明显的交集。直观地讲，三者都是抓住了特定情形下的顾客人群，更准确地说，是最佳受众。定位很重要，这就要求我们针对不同的客户制定相应的运营活动，不同与竞争对手的运营活动便是战略定位的本质所在。同选择做什么一样，选择不做什么同样重要。好的战略必定是善于取舍的，在定位过程中，精准分析、做出取舍，才能成就独特、有价值的战略定位。</p>
<h3 id="战略配称"><a href="#战略配称" class="headerlink" title="战略配称"></a>战略配称</h3><p>不同于运用效益将单项活动做到极致，战略更关心如何将运营活动有机组合，发挥其最大效用。从西南航空“环环相扣”产生的核心竞争力来看，战略配称能将企业的运营活动上链，联系密切的各项运营活动在链上的最优组合为企业带来了别人难以模仿的核心优势。我们的生活中有很多这样的例子：最优资产组合、学习模型参数配置、最有效用组合等等。运营活动彼此往往存在相互的影响与反馈，如何让积极影响显著提高，取决于战略配称的最优构造。由于战略配称强调整体效益最大化，而不是孤立的各项运营活动共同发挥作用，这就使得竞争对手在配称上的模仿难上加难，这也正是战略独特性的体现。</p>
<p>按这种分析，企业的长远优势发展离不开战略、好的战略。管理者们，那些不敢直面战略选择并以运营效益自欺的人们，是时候勇敢面对了。尽管很多例子表明，没有战略仍有巨大效益，如精益产业主导的日本，它们通过积极的运营活动取得了巨大收益。但客观来讲，长久的差异化的竞争优势才能立于长久的不败之地，这更能适应日新月异的社会变化。因此，好的管理者，应该认真审视自己的运营活动，通过细致地分析市场，分析客户群，以及研究企业价值链来重建企业战略。企业的挑战在于聚焦独特性和校正运营活动，而这一重任的完成，需要企业管理者做好自我定位并制定战略，做企业发展的总指挥。领导者应放眼全局，应对行业和需求变化作出反应、做出取舍，用新的思维方式看待运营活动与战略，带领团队在追求最大效益的路上勇往直前。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划初探</title>
    <url>/2018/09/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>通过“爬楼梯”，简单入门动态规划。</p>
<a id="more"></a>

<blockquote>
<p>【 爬楼梯】有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶，求一共有多少种走法。</p>
</blockquote>
<h3 id="思路一：简单递归算法"><a href="#思路一：简单递归算法" class="headerlink" title="思路一：简单递归算法"></a>思路一：简单递归算法</h3><p><strong>假设只差一步就走到第十级，则有两种情况：</strong></p>
<ul>
<li>从第九级走到第十级：最后一步上1级台阶</li>
<li>从第八级走到第十级：最后一步上2级台阶</li>
</ul>
<p><strong>所以得出问题模型：</strong></p>
<ul>
<li><strong>十级台阶的走法数 = 九级台阶的走法数 + 八级台阶的走法数</strong></li>
<li><strong>问题建模：<code>F(1) = 1;</code> <code>F(2) = 2;</code> <code>F(n) = F(n-1) + F(n-2) (n&gt;=3);</code></strong></li>
</ul>
<p><strong>动态规划中三个重要概念：</strong></p>
<ul>
<li><strong>最优子结构</strong>：例如在 <code>F(10) = F(9) + F(8)</code> 中，<code>F(9)</code> 和 <code>F(8)</code>是 <code>F(10)</code>的 <code>最优子结构</code></li>
<li><strong>边界</strong>：<code>F(1)</code> 和<code>F(2)</code>是<code>边界</code></li>
<li><strong>状态转移公式</strong>：<code>F(n) = F(n-1) + F(n-2)</code>是<code>状态转移公式</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划——爬楼梯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归求解: 时间复杂度：O(2^N),存在太多相同的参数被重新计算*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getClimbingWays</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)    <span class="keyword">return</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> getClimbingWays(n<span class="number">-1</span>) + getClimbingWays(n<span class="number">-2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; getClimbingWays(n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="思路二：备忘录算法"><a href="#思路二：备忘录算法" class="headerlink" title="思路二：备忘录算法"></a>思路二：备忘录算法</h3><ul>
<li>先创建一个哈希表，每次把不同参数的计算结果存入哈希</li>
<li>当遇到相同参数的时候，直接从哈希表中取出，不用重复计算</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划——爬楼梯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* 备忘录算法: 时间复杂度：O(N),空间复杂度：O(N)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             F(1)到F(N)有N个不同输入，哈希表中存放了N-2个结果*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; my_map;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getClimbingWays</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)    <span class="keyword">return</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(my_map.count(n))     <span class="keyword">return</span> my_map[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> value = getClimbingWays(n<span class="number">-1</span>) + getClimbingWays(n<span class="number">-2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        my_map[n] = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; getClimbingWays(n) &lt;&lt; <span class="built_in">endl</span>;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="思路三：真正的动态规划"><a href="#思路三：真正的动态规划" class="headerlink" title="思路三：真正的动态规划"></a>思路三：真正的动态规划</h3><table>
<thead>
<tr>
<th align="center">台阶数</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">走法数</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">5</td>
<td align="center">8</td>
<td align="center">13</td>
<td align="center">21</td>
<td align="center">34</td>
<td align="center">55</td>
<td align="center">89</td>
</tr>
</tbody></table>
<p><strong>逆向思路：因为<code>F(n) = F(n-1) + F(n-2)</code>，即每个台阶数的走法都只与前两个有关，故每次迭代只保留前两个状态即可，以最大化降低空间复杂度。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划——爬楼梯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* 动态规划求解: 时间复杂度：O(N),空间复杂度：O(1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">               利用简洁的自底向上的递推方式，实现时间和空间上的最优*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getClimbingWays</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)    <span class="keyword">return</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, tmp = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tmp = a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a = b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        b = tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; getClimbingWays(n) &lt;&lt; <span class="built_in">endl</span>;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<blockquote>
<p>【 国王和金矿】有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？5座金矿分别为：<code>400金/5人</code>、<code>500金/5人</code>、<code>200金/3人</code>、<code>300金/4人</code>、<code>350金/3人</code></p>
</blockquote>
<h3 id="动态规划分析"><a href="#动态规划分析" class="headerlink" title="动态规划分析"></a>动态规划分析</h3><ul>
<li><strong>最优子结构</strong>：<code>10人挖前4座金矿(此时不挖第5座金矿)</code> 和 <code>10-3人挖前4座金矿(第5座金矿剩余3人挖)</code>。所以挖5座金矿的最优选择是<code>上面两者挖金数量的最大值</code>。<ul>
<li>设金矿数为<code>N</code>，工人数为<code>W</code>，各金矿黄金数设为数组<code>G[]</code>，金矿用工量设为数组<code>P[]</code></li>
<li>5座金矿与4座金矿的最优选择关系：<code>F(5,10) = MAX(F(4,10), F(4,10-P[4])+G[4])</code></li>
</ul>
</li>
<li><strong>边界</strong>：按照工人数是否足够一座金矿的用工量分两种情况：<ul>
<li>当N=1，W&gt;=P[0]时，F(N,W) = G[0]</li>
<li>当N=1，W&lt;P[0]时，F(N,W) 0</li>
</ul>
</li>
<li><strong>状态转移公式</strong>：<ul>
<li>F(n,w) = 0 (n&lt;=1, w&lt;p[0]);</li>
<li>F(n,w) = g[0] (n==1, w&gt;=p[0]);</li>
<li>F(n,w) = F(n-1,w) (n&gt;1, w&lt;p[n-1])</li>
<li>F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1]) + g[n-1]) (n&gt;1, w&gt;=p[n-1])</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>工人数</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>1座金矿</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>400</td>
<td>400</td>
<td>400</td>
<td>400</td>
<td>400</td>
<td>400</td>
</tr>
<tr>
<td>2座金矿</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>500</td>
<td>500</td>
<td>500</td>
<td>500</td>
<td>500</td>
<td>900</td>
</tr>
<tr>
<td>3座金矿</td>
<td>0</td>
<td>0</td>
<td>200</td>
<td>200</td>
<td>500</td>
<td>500</td>
<td>500</td>
<td>700</td>
<td>700</td>
<td>900</td>
</tr>
<tr>
<td>4座金矿</td>
<td>0</td>
<td>0</td>
<td>200</td>
<td>300</td>
<td>500</td>
<td>500</td>
<td>500</td>
<td>700</td>
<td>800</td>
<td>900</td>
</tr>
<tr>
<td>5座金矿</td>
<td>0</td>
<td>0</td>
<td>350</td>
<td>350</td>
<td>500</td>
<td>550</td>
<td>650</td>
<td>850</td>
<td>850</td>
<td>900</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划——挖黄金</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* 动态规划求解: 时间复杂度：O(n*w),空间复杂度：O(w)*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMostGold</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w, <span class="keyword">int</span> g[], <span class="keyword">int</span> p[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> preResults[w+<span class="number">1</span>], Results[w+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=w; i++) <span class="comment">//填充边界格子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(i&lt;p[<span class="number">0</span>])  preResults[i] = <span class="number">0</span>; <span class="comment">//分配人数少于第i座金矿的用工量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> preResults[i] = g[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;  <span class="comment">//从第2座金矿开始计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=w; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(j &lt; p[i])    Results[j] = preResults[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> Results[j] = <span class="built_in">max</span>(preResults[j], preResults[j-p[i]] + g[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=w; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            preResults[i] = Results[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> Results[w];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n=<span class="number">5</span>, w=<span class="number">10</span>; <span class="comment">//金矿数、工人数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> g[] = &#123;<span class="number">400</span>, <span class="number">500</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">350</span>&#125;; <span class="comment">//各金矿的黄金数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> p[] = &#123;<span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>&#125;; <span class="comment">//各金矿的用工量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; getMostGold(n, w, g, p) &lt;&lt; <span class="built_in">endl</span>;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><strong>注意点：</strong></p>
<ul>
<li><code>动态规划方法</code>的<code>时间和空间</code>都和<code>W</code>成正比</li>
<li><code>简单递归算法</code>和<code>W</code>不相关</li>
<li>所以当<code>工人数W</code>很大时，<code>动态规划反而不如简单递归</code></li>
</ul>
<p><a href="https://www.sohu.com/a/153858619_466939" target="_blank" rel="noopener">漫画：什么是动态规划？</a><br><a href="http://www.cnblogs.com/wuyuegb2312/p/3281264.html#i1" target="_blank" rel="noopener">常见的动态规划问题分析与求解</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF CSP计划</title>
    <url>/2018/08/27/CCF-CSP%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<p>本文记录CCF-CSP算法题解。</p>
<a id="more"></a>

<p>注：#include&lt;bits/stdc++.h&gt;包含所有的C++头文件。</p>
<h1 id="2018年"><a href="#2018年" class="headerlink" title="2018年"></a>2018年</h1><h2 id="12月"><a href="#12月" class="headerlink" title="12月"></a>12月</h2><h3 id="201812-1-小明上学"><a href="#201812-1-小明上学" class="headerlink" title="201812-1 小明上学"></a>201812-1 小明上学</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r, y, g = map(int, input().split())</span></pre></td></tr><tr><td class="code"><pre><span class="line">n = int(input())</span></pre></td></tr><tr><td class="code"><pre><span class="line">t = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 出发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    path = list(map(int, input().split()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> path[<span class="number">0</span>]==<span class="number">0</span> <span class="keyword">or</span> path[<span class="number">0</span>] == <span class="number">1</span>:  <span class="comment"># 经过道路/等红灯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        t += path[<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">elif</span> path[<span class="number">0</span>] == <span class="number">2</span>:  <span class="comment"># 等黄灯（之后还要等红灯）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        t += path[<span class="number">1</span>] + r</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(t)</span></pre></td></tr></table></figure>

<h3 id="201812-2-小明放学"><a href="#201812-2-小明放学" class="headerlink" title="201812-2 小明放学"></a>201812-2 小明放学</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r, y, g = map(int, input().split())</span></pre></td></tr><tr><td class="code"><pre><span class="line">n = int(input())</span></pre></td></tr><tr><td class="code"><pre><span class="line">total_time = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 出发</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m_type, m_time = map(int, input().split())</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> m_type == <span class="number">0</span>: <span class="comment"># 经过道路</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        total_time += m_time</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 转成距绿灯结束的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> m_type == <span class="number">1</span>: <span class="comment"># 红灯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        m_time += g</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m_type = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> m_type == <span class="number">2</span>: <span class="comment"># 黄灯（之后还要等红灯）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        m_time += (r + g)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        m_type = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> m_type == <span class="number">3</span>: <span class="comment"># 绿灯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    now_time = (m_time - total_time) % (g+r+y)  <span class="comment"># 当前循环距绿灯结束的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> now_time &gt; g:  <span class="comment"># 经过该路口时不为绿灯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        total_time += (now_time - g)  <span class="comment"># 加上要等待的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(total_time)</span></pre></td></tr></table></figure>

<h3 id="201812-3-CIDR合并"><a href="#201812-3-CIDR合并" class="headerlink" title="201812-3 CIDR合并"></a>201812-3 CIDR合并</h3><h3 id="201812-4-数据中心"><a href="#201812-4-数据中心" class="headerlink" title="201812-4 数据中心"></a>201812-4 数据中心</h3><h3 id="201812-5-管道清洁"><a href="#201812-5-管道清洁" class="headerlink" title="201812-5 管道清洁"></a>201812-5 管道清洁</h3><h2 id="9月"><a href="#9月" class="headerlink" title="9月"></a>9月</h2><h3 id="201809-1-卖菜"><a href="#201809-1-卖菜" class="headerlink" title="201809-1 卖菜"></a>201809-1 卖菜</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span></pre></td></tr><tr><td class="code"><pre><span class="line">p = list(map(int, input().split()))  <span class="comment"># 0~n-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">o = [<span class="number">0</span>]*n</span></pre></td></tr><tr><td class="code"><pre><span class="line">o[<span class="number">0</span>] = int((p[<span class="number">0</span>]+p[<span class="number">1</span>])/<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">o[<span class="number">-1</span>] = int((p[<span class="number">-2</span>]+p[<span class="number">-1</span>])/<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    o[i] = int((p[i<span class="number">-1</span>]+p[i]+p[i+<span class="number">1</span>])/<span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> o:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(i, end=<span class="string">' '</span>)</span></pre></td></tr></table></figure>

<h3 id="201809-2-买菜"><a href="#201809-2-买菜" class="headerlink" title="201809-2 买菜"></a>201809-2 买菜</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = int(input())</span></pre></td></tr><tr><td class="code"><pre><span class="line">H = []  <span class="comment"># 小H装车时间段</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">W = []  <span class="comment"># 小W装车时间段</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    H.append(tuple(map(int, input().split())))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    W.append(tuple(map(int, input().split())))</span></pre></td></tr><tr><td class="code"><pre><span class="line">tlate = max(H[<span class="number">-1</span>][<span class="number">-1</span>], W[<span class="number">-1</span>][<span class="number">-1</span>])  <span class="comment"># 最晚时间点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">timecnt = [<span class="number">0</span>]*tlate  <span class="comment"># 时间点计数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> s, e <span class="keyword">in</span> H:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(s, e):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        timecnt[i] += <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> s, e <span class="keyword">in</span> W:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(s, e):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        timecnt[i] += <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(timecnt.count(<span class="number">2</span>))</span></pre></td></tr></table></figure>

<h3 id="201809-3-元素选择器"><a href="#201809-3-元素选择器" class="headerlink" title="201809-3 元素选择器"></a>201809-3 元素选择器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n, m = map(int, input().split())  <span class="comment"># 文档行数、待查询选择器个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">doc = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">sel = []</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 结构化文档内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    doc.append(input())</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 待查询的选择器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sel.append(input())</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 解析文档</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cons = []</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    level = doc[i].count(<span class="string">'.'</span>)//<span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tag = <span class="string">""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tid = <span class="string">""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> len(doc[i].split())==<span class="number">1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tag = doc[i][level*<span class="number">2</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        left, right = doc[i].split()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tag = left[level*<span class="number">2</span>:]  <span class="comment"># 标签大小写不敏感</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        tid = right  <span class="comment"># id大小写敏感</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pline = <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">0</span><span class="number">-1</span>, <span class="number">-1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> cons[j][<span class="string">"level"</span>] == level<span class="number">-1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pline = j + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cons.append(&#123;<span class="string">"tag"</span>:tag, <span class="string">"id"</span>:tid, <span class="string">"level"</span>:level, <span class="string">"pline"</span>:pline&#125;)  <span class="comment"># 存信息为字典添加到列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 元素选择器选择</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">collection = []  <span class="comment"># 结果保存列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    collection.append([])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> len(sel[i].split())==<span class="number">1</span>:  <span class="comment"># 选择器不含空格</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> sel[i][<span class="number">0</span>]!=<span class="string">'#'</span>:  <span class="comment"># 标签选择器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> cons[j][<span class="string">"tag"</span>].lower() == sel[i].lower():  <span class="comment"># 标签大小写不敏感</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    collection[i].append(j+<span class="number">1</span>)   </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>:  <span class="comment"># id选择器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> cons[j][<span class="string">"id"</span>] == sel[i]:  <span class="comment"># id大小写敏感</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    collection[i].append(j+<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 后代选择器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        p = sel[i].split()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            parent = j + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            k = len(p) - <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> k &gt;= <span class="number">0</span>:  <span class="comment"># 从后向前迭代检查是否匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                match = <span class="literal">False</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> p[k][<span class="number">0</span>]!=<span class="string">'#'</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> cons[parent<span class="number">-1</span>][<span class="string">"tag"</span>].lower() == p[k].lower():</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        match = <span class="literal">True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">elif</span> parent == j+<span class="number">1</span> <span class="keyword">and</span> k==len(p)<span class="number">-1</span>:  <span class="comment"># 第一次必须匹配上不然直接退出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> cons[parent<span class="number">-1</span>][<span class="string">"id"</span>] == p[k]:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        match = <span class="literal">True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">elif</span> parent==j+<span class="number">1</span> <span class="keyword">and</span> k==len(p)<span class="number">-1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> match:</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    k -= <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> k &lt; <span class="number">0</span>:  <span class="comment"># 匹配成功</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        collection[i].append(j+<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">break</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> cons[parent<span class="number">-1</span>][<span class="string">"pline"</span>]==<span class="number">-1</span>:  <span class="comment"># 没有父节点了仍未匹配成功即匹配失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 匹配失败退出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                parent = cons[parent<span class="number">-1</span>][<span class="string">"pline"</span>]  <span class="comment"># 取父节点继续检查匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> collection:    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(len(x), <span class="string">" "</span>.join(map(str, x)))</span></pre></td></tr></table></figure>

<h3 id="201809-4-再卖菜"><a href="#201809-4-再卖菜" class="headerlink" title="201809-4 再卖菜"></a>201809-4 再卖菜</h3><h3 id="201809-5-线性递推式"><a href="#201809-5-线性递推式" class="headerlink" title="201809-5 线性递推式"></a>201809-5 线性递推式</h3><h2 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h2><h3 id="201803-1-跳一跳"><a href="#201803-1-跳一跳" class="headerlink" title="201803-1 跳一跳"></a>201803-1 跳一跳</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201803-1 跳一跳</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span> &amp;score, <span class="keyword">int</span> &amp;temp)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        score += <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jump(score, temp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        temp += <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        score += temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        jump(score, temp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> score;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> score = <span class="number">0</span>, temp = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    score = jump(score, temp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; score &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201803-2-碰撞的小球"><a href="#201803-2-碰撞的小球" class="headerlink" title="201803-2 碰撞的小球"></a>201803-2 碰撞的小球</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201803-2 碰撞的小球</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, L, t, i, j, k; <span class="comment">//小球个数、线段长度、计算时刻等</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; L &gt;&gt; t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> A[<span class="number">100</span>]; <span class="comment">//n个小球的初始位置（都为偶数）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> dirA[<span class="number">100</span>]; <span class="comment">//存放n个小球当前的运动方向：1为右、-1为左</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; A[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dirA[i] = <span class="number">1</span>; <span class="comment">//所有小球方向初始化为右</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=t; i++)&#123; <span class="comment">//t秒的循环</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>((A[j]==L &amp;&amp; dirA[j]==<span class="number">1</span>) || (A[j]==<span class="number">0</span> &amp;&amp; dirA[j]==<span class="number">-1</span>)) <span class="comment">//位于两个端点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                dirA[j] *= <span class="number">-1</span>; <span class="comment">//掉头</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;n; k++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(A[j]==A[k] &amp;&amp; j!=k) &#123;<span class="comment">//小球发生碰撞</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        dirA[j] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        dirA[k] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A[j] += dirA[j]; <span class="comment">//更新当前位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; A[i] &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201803-3-URL映射"><a href="#201803-3-URL映射" class="headerlink" title="201803-3 URL映射"></a>201803-3 URL映射</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201803-3 URL映射</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> name; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; regV;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    reg(<span class="built_in">string</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v):name(n), regV(v)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;; <span class="comment">//规则结构体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;reg&gt; regS; <span class="comment">//规则向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str2regV(<span class="built_in">string</span> str)&#123; <span class="comment">//字符串转化为规则向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    str = str.substr(<span class="number">1</span>, str.<span class="built_in">size</span>()<span class="number">-1</span>); <span class="comment">//substr: 从字符串指定位置复制指定数量的字符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    res.push_back(<span class="string">"/"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">"/"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(pos != <span class="built_in">string</span>::npos)&#123; <span class="comment">//npos: npos表示string的结束位子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        res.push_back(str.substr(<span class="number">0</span>, pos));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res.push_back(<span class="string">"/"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str = str.substr(pos+<span class="number">1</span>); <span class="comment">//没有指定长度，从pos+1复制到字符串结尾</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pos = str.<span class="built_in">find</span>(<span class="string">"/"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(str.<span class="built_in">size</span>())  res.push_back(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">urlMap</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123; <span class="comment">//完成URL映射</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = str2regV(str); <span class="comment">//目标URL的规则向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>( <span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;regS.<span class="built_in">size</span>(); i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;r = regS[i].regV; <span class="comment">//所有规则向量的每一项规则</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> res = regS[i].name; <span class="comment">////所有规则向量的每一项规则名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">size_t</span> lr = r.<span class="built_in">size</span>(), lv = v.<span class="built_in">size</span>(), j = <span class="number">0</span>, k = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(j&lt;lr &amp;&amp; k&lt;lv)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(r[j] == v[k])&#123; j++, k++; <span class="keyword">continue</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(r[j] == <span class="string">"&lt;path&gt;"</span>)&#123; <span class="comment">//路径 &lt;path&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(v[lv<span class="number">-1</span>] == <span class="string">"/"</span>) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                res += <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span>(k &lt; lv)   res += v[k++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r[j] == <span class="string">"&lt;int&gt;"</span>)&#123; <span class="comment">//整数 &lt;int&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">string</span> num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">bool</span> tag = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">size_t</span> l=<span class="number">0</span>; l&lt;v[k].<span class="built_in">size</span>(); l++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(<span class="built_in">isdigit</span>(v[k][l]))    num+= v[k][l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span>&#123; tag = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(tag == <span class="number">0</span>)    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">size_t</span> uz = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span>(num[uz]==<span class="string">'0'</span> &amp;&amp; uz&lt;num.<span class="built_in">size</span>()<span class="number">-1</span>) ++uz; <span class="comment">//去除前导0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                res += <span class="string">" "</span> + num.substr(uz, num.<span class="built_in">size</span>()-uz);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r[j] == <span class="string">"&lt;str&gt;"</span>)&#123; <span class="comment">//字符串 &lt;str&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                res += <span class="string">" "</span> + v[k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            j++; k++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(j==lr &amp;&amp; k==lv)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"404"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//匹配失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">//规则数、URL数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> regStr, name; <span class="comment">//规则字符串及其名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; regStr &gt;&gt; name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        regS.push_back(reg(name, str2regV(regStr))); <span class="comment">//构建规则向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(m--)&#123; <span class="comment">//对每一个url依次映射</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        urlMap(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201803-4-棋局评估"><a href="#201803-4-棋局评估" class="headerlink" title="201803-4 棋局评估"></a>201803-4 棋局评估</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201803-4 棋局评估</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">3</span>][<span class="number">3</span>]; <span class="comment">//棋盘 空白为0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isrowsame</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">//横向第i行都相同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> A[i][<span class="number">0</span>]==val &amp;&amp; A[i][<span class="number">1</span>]==val &amp;&amp; A[i][<span class="number">2</span>]==val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">iscolsame</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">//竖向第j列都相同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>][j]==val &amp;&amp; A[<span class="number">1</span>][j]==val &amp;&amp; A[<span class="number">2</span>][j]==val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isdiagsame</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">//斜方向的三个位置都相同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (A[<span class="number">0</span>][<span class="number">0</span>]==val &amp;&amp; A[<span class="number">1</span>][<span class="number">1</span>]==val &amp;&amp; A[<span class="number">2</span>][<span class="number">2</span>]==val) || (A[<span class="number">0</span>][<span class="number">2</span>]==val &amp;&amp; A[<span class="number">1</span>][<span class="number">1</span>]==val &amp;&amp; A[<span class="number">2</span>][<span class="number">0</span>]==val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countempty</span><span class="params">()</span> </span>&#123; <span class="comment">//计算空白格子个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(A[i][j] == <span class="number">0</span>) res++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iswin</span><span class="params">(<span class="keyword">int</span> player)</span> </span>&#123; <span class="comment">//player: 1代表Alice, 2代表Bob</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> r = isrowsame(<span class="number">0</span>, player) || isrowsame(<span class="number">1</span>, player) || isrowsame(<span class="number">2</span>, player);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> c = iscolsame(<span class="number">0</span>, player) || iscolsame(<span class="number">1</span>, player) || iscolsame(<span class="number">2</span>, player);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> d = isdiagsame(player);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> w = r || c || d; <span class="comment">//判断当前状态玩家是否胜出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(w == <span class="number">0</span>)  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//未胜出，继续游戏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    w = countempty() + <span class="number">1</span>; <span class="comment">//该玩家胜出，计算分数，游戏结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> player==<span class="number">1</span> ? w : -w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> player)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(countempty() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//棋盘已满，平局</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> Min = <span class="number">10</span>, Max = <span class="number">-10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(A[i][j] == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                A[i][j] = player;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> w = iswin(player);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(w) &#123; <span class="comment">//棋局结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    A[i][j] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> w&gt;<span class="number">0</span> ? <span class="built_in">max</span>(Max, w) : <span class="built_in">min</span>(Min, w);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(player == <span class="number">1</span>) Max = <span class="built_in">max</span>(Max, dfs(<span class="number">2</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span>    Min = <span class="built_in">min</span>(Min, dfs(<span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                A[i][j] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> player==<span class="number">1</span> ? Max : Min;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> T; <span class="comment">//输入数据的组数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(T--)&#123;  <span class="comment">//依次处理每组数据并输出当前局面的得分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cin</span> &gt;&gt; A[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x = iswin(<span class="number">1</span>), y = iswin(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(x)   <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y)  <span class="built_in">cout</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>    <span class="built_in">cout</span> &lt;&lt; dfs(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：</p>
<ul>
<li><a href="http://www.xqbase.com/computer/search_minimax.htm" target="_blank" rel="noopener">最小-最大搜索</a></li>
<li><a href="https://blog.csdn.net/u013351484/article/details/50789521" target="_blank" rel="noopener">博弈基础——极大极小搜索</a></li>
<li><a href="https://blog.csdn.net/hzk_cpp/article/details/79275772" target="_blank" rel="noopener">极大极小搜索算法以及alpha-beta优化（按顺序选数）</a></li>
</ul>
<h3 id="201803-5-二次求和"><a href="#201803-5-二次求和" class="headerlink" title="201803-5 二次求和"></a>201803-5 二次求和</h3><h1 id="2017年"><a href="#2017年" class="headerlink" title="2017年"></a>2017年</h1><h2 id="12月-1"><a href="#12月-1" class="headerlink" title="12月"></a>12月</h2><h3 id="201712-1-最小差值"><a href="#201712-1-最小差值" class="headerlink" title="201712-1 最小差值"></a>201712-1 最小差值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201712-1 最小差值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, num[<span class="number">1024</span>], minval=<span class="number">10000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; num[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(num, num+n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minval = <span class="built_in">min</span>(minval,num[i]-num[i<span class="number">-1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; minval &lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201712-2-游戏"><a href="#201712-2-游戏" class="headerlink" title="201712-2 游戏"></a>201712-2 游戏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201712-2 游戏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; win; <span class="comment">//剩余人序列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        win.push_back(i); </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//开始报数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(win.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        n = win.<span class="built_in">size</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ++num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(num%k &amp;&amp; num%<span class="number">10</span>!=k)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                win[len++] = win[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)  win[len++] = win.back();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        win.resize(len); <span class="comment">//重置个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; win[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201712-3-Crontab"><a href="#201712-3-Crontab" class="headerlink" title="201712-3 Crontab"></a>201712-3 Crontab</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201712-3 Crontab</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> vMon[][<span class="number">4</span>]=&#123;<span class="string">""</span>,<span class="string">"jan"</span>,<span class="string">"feb"</span>,<span class="string">"mar"</span>,<span class="string">"apr"</span>,<span class="string">"may"</span>,<span class="string">"jun"</span>,<span class="string">"jul"</span>,<span class="string">"aug"</span>,<span class="string">"sep"</span>,<span class="string">"oct"</span>,<span class="string">"nov"</span>,<span class="string">"dec"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> vWek[][<span class="number">4</span>]=&#123;<span class="string">"sun"</span>,<span class="string">"mon"</span>,<span class="string">"tue"</span>,<span class="string">"wed"</span>,<span class="string">"thu"</span>,<span class="string">"fri"</span>,<span class="string">"sat"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mtharray[]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mMon,mWek;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; mrt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMonAndWekMap</span><span class="params">()</span></span>&#123; <span class="comment">//初始化月份和工作日对应的序号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;++i) mMon[vMon[i]]=i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">6</span>;++i) mWek[vWek[i]]=i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi_x</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str)</span></span>&#123; <span class="comment">//string转int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(str)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ss&gt;&gt;ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">toStandard</span><span class="params">(<span class="built_in">string</span> &amp;str)</span></span>&#123; <span class="comment">//标准话：转化为小写</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> len=str.<span class="built_in">size</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)  str[i]=<span class="built_in">tolower</span>(str[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">to_string_x</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//int转string</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">stringstream</span> ss;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ss&lt;&lt;n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ss.str();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitStringAndbuildVector(<span class="built_in">string</span> &amp;str,<span class="keyword">int</span> TAG)&#123; <span class="comment">//切分string构建vector</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    str+=<span class="string">","</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vret;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> found=str.<span class="built_in">find</span>(<span class="string">","</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(found!=<span class="built_in">string</span>::npos)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> x=str.substr(<span class="number">0</span>,found);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str=str.substr(found+<span class="number">1</span>,str.<span class="built_in">size</span>()-found<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">size_t</span> fdx=x.<span class="built_in">find</span>(<span class="string">"-"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(fdx==<span class="built_in">string</span>::npos)&#123; <span class="comment">//非连续值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(TAG==<span class="number">1</span>&amp;&amp;<span class="built_in">isalpha</span>(x[<span class="number">0</span>])) x=to_string_x(mMon[x]);<span class="comment">//是month英文缩写，转换为数字</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(TAG==<span class="number">2</span>&amp;&amp;<span class="built_in">isalpha</span>(x[<span class="number">0</span>])) x=to_string_x(mWek[x]);<span class="comment">//是day of week英文缩写，转换为数字</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(x.<span class="built_in">size</span>()==<span class="number">1</span>) x=<span class="string">"0"</span>+x;<span class="comment">//添加0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            vret.push_back(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//连续值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">string</span> L=x.substr(<span class="number">0</span>,fdx),R=x.substr(fdx+<span class="number">1</span>,x.<span class="built_in">size</span>()-fdx<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> left,right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(TAG==<span class="number">0</span>) left=stoi_x(L),right=stoi_x(R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(TAG==<span class="number">1</span>)&#123;<span class="comment">//month</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                left=(<span class="built_in">isalpha</span>(L[<span class="number">0</span>]))?mMon[L]:stoi_x(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                right=(<span class="built_in">isalpha</span>(R[<span class="number">0</span>]))?mMon[R]:stoi_x(R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(TAG==<span class="number">2</span>)&#123;<span class="comment">//day of week</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                left=(<span class="built_in">isalpha</span>(L[<span class="number">0</span>]))?mWek[L]:stoi_x(L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                right=(<span class="built_in">isalpha</span>(R[<span class="number">0</span>]))?mWek[R]:stoi_x(R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(left&lt;=right)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">string</span> num=to_string_x(left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(num.<span class="built_in">size</span>()==<span class="number">1</span>)num=<span class="string">"0"</span>+num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                vret.push_back(num);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ++left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        found=str.<span class="built_in">find</span>(<span class="string">","</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> vret;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isleapyear</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//判断是否闰年</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">100</span>)||y%<span class="number">400</span>==<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getWeekday</span><span class="params">(<span class="built_in">string</span> year,<span class="built_in">string</span> month,<span class="built_in">string</span> day)</span></span>&#123; <span class="comment">//计算星期几</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> y=stoi_x(year),m=stoi_x(month),d=stoi_x(day);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> by=<span class="number">1970</span>,countday=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(by&lt;y)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        countday+=(isleapyear(by))?<span class="number">366</span>:<span class="number">365</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++by;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;++i) countday+=mtharray[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    countday+=d<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="string">"0"</span>+to_string_x((<span class="number">4</span>+countday%<span class="number">7</span>)%<span class="number">7</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> st,et;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    buildMonAndWekMap();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;st&gt;&gt;et;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> syy=st.substr(<span class="number">0</span>,<span class="number">4</span>),smm=st.substr(<span class="number">4</span>,<span class="number">2</span>),sdd=st.substr(<span class="number">6</span>,<span class="number">2</span>),sHH=st.substr(<span class="number">8</span>,<span class="number">2</span>),sMM=st.substr(<span class="number">10</span>,<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> eyy=et.substr(<span class="number">0</span>,<span class="number">4</span>),emm=et.substr(<span class="number">4</span>,<span class="number">2</span>),edd=et.substr(<span class="number">6</span>,<span class="number">2</span>),eHH=et.substr(<span class="number">8</span>,<span class="number">2</span>),eMM=et.substr(<span class="number">10</span>,<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> syInt=stoi_x(syy),eyInt=stoi_x(eyy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(n--)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vmts,vhur,vdfm,vmth,vdfw;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> minutes,hours,dofmon,month,dofwek,command;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span>&gt;&gt;minutes&gt;&gt;hours&gt;&gt;dofmon&gt;&gt;month&gt;&gt;dofwek&gt;&gt;command;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        toStandard(month);<span class="comment">//不区别大小写，转化为标准小写</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        toStandard(dofwek);<span class="comment">//不区别大小写，转化为标准小写</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(minutes==<span class="string">"*"</span>) minutes=<span class="string">"0-59"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vmts=splitStringAndbuildVector(minutes,<span class="number">0</span>);<span class="comment">//应该执行的分钟</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(hours==<span class="string">"*"</span>) hours=<span class="string">"0-23"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vhur=splitStringAndbuildVector(hours,<span class="number">0</span>); <span class="comment">//应该执行的小时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(dofmon==<span class="string">"*"</span>) dofmon=<span class="string">"1-31"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vdfm=splitStringAndbuildVector(dofmon,<span class="number">0</span>);<span class="comment">//应该执行的日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(month==<span class="string">"*"</span>) month=<span class="string">"1-12"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vmth=splitStringAndbuildVector(month,<span class="number">1</span>);<span class="comment">//应该执行的月份</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(dofwek==<span class="string">"*"</span>) dofwek=<span class="string">"0-6"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vdfw=splitStringAndbuildVector(dofwek,<span class="number">2</span>);<span class="comment">//应该周几执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; wekexist;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;vdfw.<span class="built_in">size</span>();++i) wekexist.insert(vdfw[i]);<span class="comment">//更快的检索当前日期（dayofweek）是不是应该执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> curyear=syInt;<span class="comment">//从开始年份执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(curyear&lt;=eyInt)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(isleapyear(curyear)) mtharray[<span class="number">2</span>]=<span class="number">29</span>;<span class="comment">//leapyear的2月份应该是29天</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> mtharray[<span class="number">2</span>]=<span class="number">28</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">string</span> year=to_string_x(curyear);<span class="comment">//年份</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> mi=<span class="number">0</span>;mi&lt;vmth.<span class="built_in">size</span>();mi++)&#123; <span class="comment">//month</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">string</span> curm=vmth[mi];<span class="comment">//当前月份</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">size_t</span> di=<span class="number">0</span>;di&lt;vdfm.<span class="built_in">size</span>();di++)&#123; <span class="comment">//day of month</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">string</span> curd=vdfm[di];<span class="comment">//当前日期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">string</span> wd=getWeekday(year,curm,curd);<span class="comment">//该年，该月，该日是星期几</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(wekexist.count(wd)==<span class="number">0</span>||stoi_x(curd)&gt;mtharray[stoi_x(curm)])<span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">//命令行中不包含该星期或者当前天数超过当前月份的应有天数时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span>(<span class="keyword">size_t</span> Hi=<span class="number">0</span>;Hi&lt;vhur.<span class="built_in">size</span>();++Hi) <span class="comment">//hour</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">for</span>(<span class="keyword">size_t</span> Mi=<span class="number">0</span>;Mi&lt;vmts.<span class="built_in">size</span>();++Mi)&#123; <span class="comment">//minutes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="built_in">string</span> datetime=year+curm+curd+vhur[Hi]+vmts[Mi];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">if</span>(datetime&gt;=st&amp;&amp;datetime&lt;et) mrt[datetime].push_back(command);<span class="comment">//在当前日期时间内</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ++curyear;<span class="comment">//进入下一年</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt;::iterator it=mrt.<span class="built_in">begin</span>();it!=mrt.<span class="built_in">end</span>();++it)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; isprt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>;i&lt;it-&gt;second.<span class="built_in">size</span>();++i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">string</span> dis=it-&gt;first+<span class="string">" "</span>+it-&gt;second[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(isprt.count(dis)==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span>&lt;&lt;dis&lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                isprt[dis]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>（学习参考：<a href="https://blog.csdn.net/gl486546/article/details/79057666" target="_blank" rel="noopener">201712-3 Crontab ccf</a>）</p>
<h3 id="201712-4-行车路线"><a href="#201712-4-行车路线" class="headerlink" title="201712-4 行车路线"></a>201712-4 行车路线</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201712-4 行车路线</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> bigR[<span class="number">505</span>][<span class="number">505</span>], smallR[<span class="number">505</span>][<span class="number">505</span>]; <span class="comment">//大路长度，小路长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tiredB[<span class="number">505</span>], tiredS[<span class="number">505</span>]; <span class="comment">//大路的疲劳度，小路的疲劳度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[<span class="number">505</span>]; <span class="comment">//经过路口：1为已经过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//路口数，道路数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123; <span class="comment">//预处理小路的连通性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(smallR[i][j]&gt;smallR[i][k]+smallR[k][j] &amp;&amp; smallR[i][k]!=INF &amp;&amp; smallR[k][j]!=INF)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    smallR[i][j] = smallR[i][k] + smallR[k][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(smallR, INF, <span class="keyword">sizeof</span>(smallR));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(bigR, INF, <span class="keyword">sizeof</span>(bigR));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> t, a, b, c; <span class="comment">//道路类型，起点路口，终点路口，道路长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span>&gt;&gt; t &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span> &amp;&amp; smallR[a][b]&gt;c) <span class="comment">//t==1 小道</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            smallR[a][b] = smallR[b][a] = c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">0</span> &amp;&amp; bigR[a][b]&gt;c) <span class="comment">//t==0 大道</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            bigR[a][b] = bigR[b][a] = c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    floyd();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(tiredB, INF, <span class="keyword">sizeof</span>(tiredB));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(tiredS, INF, <span class="keyword">sizeof</span>(tiredS));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//经过路口队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tiredB[<span class="number">1</span>] = tiredS[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//初始化大路小路的疲劳度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    q.push(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    visited[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> now = q.front();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        q.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        visited[now] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123; <span class="comment">//依次遍历n个路口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> v = bigR[now][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(tiredB[i] &gt; tiredB[now]+v) &#123; <span class="comment">//大路加大路</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                tiredB[i] = tiredB[now] + v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(visited[i])  <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                visited[i] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                q.push(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(tiredB[i] &gt; tiredS[now]+v) &#123; <span class="comment">//大路加小路</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                tiredB[i] = tiredS[now]+v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(visited[i])  <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                visited[i] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                q.push(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(smallR[now][i] &lt; <span class="number">1e10</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                v = smallR[now][i] * smallR[now][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(tiredS[i] &gt; tiredB[now]+v) &#123; <span class="comment">//小路加大路</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    tiredS[i] = tiredB[now]+v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(visited[i])  <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    visited[i] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    q.push(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">min</span>(tiredB[n], tiredS[n]) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：</p>
<ul>
<li><a href="https://blog.csdn.net/amazingcode/article/details/53038977" target="_blank" rel="noopener">Floyd最短路算法</a></li>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/60875818" target="_blank" rel="noopener">最短路径问题—Floyd算法详解</a></li>
<li><a href="https://blog.csdn.net/m0_37345402/article/details/76695930" target="_blank" rel="noopener">最短路径—Dijkstra算法和Floyd算法（理解）</a></li>
</ul>
<h3 id="201712-5-商路"><a href="#201712-5-商路" class="headerlink" title="201712-5 商路"></a>201712-5 商路</h3><h2 id="9月-1"><a href="#9月-1" class="headerlink" title="9月"></a>9月</h2><h3 id="201709-1-打酱油"><a href="#201709-1-打酱油" class="headerlink" title="201709-1 打酱油"></a>201709-1 打酱油</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201709-1 打酱油</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buy</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">50</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> n&lt;<span class="number">30</span> ? n/<span class="number">10</span> : <span class="number">4</span>+(n<span class="number">-30</span>)/<span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">4</span>+buy(n<span class="number">-30</span>), <span class="number">7</span>+buy(n<span class="number">-50</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> N; <span class="comment">//小明的钱数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; buy(N) &lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201709-2-公共钥匙盒"><a href="#201709-2-公共钥匙盒" class="headerlink" title="201709-2 公共钥匙盒"></a>201709-2 公共钥匙盒</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201709-2 公共钥匙盒</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> num, s, e; <span class="comment">//老师要使用的钥匙编号、开始上课的时间、上课的时长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    teacher(<span class="keyword">int</span> x=<span class="number">0</span>, <span class="keyword">int</span> y=<span class="number">0</span>, <span class="keyword">int</span> z=<span class="number">0</span>):num(x), s(y), e(z)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;teacher&gt; p, q;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> keyN, teaN, key[<span class="number">1024</span>]; <span class="comment">//钥匙数、老师数、挂钩上的钥匙组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpStart</span><span class="params">(<span class="keyword">const</span> teacher &amp;a, <span class="keyword">const</span> teacher &amp;b)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a.s &lt; b.s; <span class="comment">//比较开始使用时刻</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpStop</span><span class="params">(<span class="keyword">const</span> teacher &amp;a, <span class="keyword">const</span> teacher &amp;b)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a.e==b.e ? a.num&lt;b.num : a.e&lt;b.e; <span class="comment">//比较使用的钥匙或使用时长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchKeyPos</span><span class="params">(<span class="keyword">int</span> keyId)</span></span>&#123; <span class="comment">//搜索钥匙位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=keyN; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(keyId == key[i]) <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"can't find "</span> &lt;&lt; keyId &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; keyN &gt;&gt; teaN; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=keyN; i++) <span class="comment">//初始化钥匙序号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        key[i] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;teaN; i++)&#123; <span class="comment">//初始化老师使用钥匙情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        teacher x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x.num &gt;&gt; x.s &gt;&gt; x.e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x.e += x.s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p.push_back(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        q.push_back(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), cmpStart); <span class="comment">//根据开始时间从小到大排 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), cmpStop); <span class="comment">//根据结束时间从小到大排 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i&lt;teaN &amp;&amp; j&lt;teaN)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p[i].s &lt; q[j].e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> pos = searchKeyPos(p[i++].num);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            key[pos] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p[i].s &gt;= q[j].e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> pos = searchKeyPos(<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            key[pos] = q[j++].num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(j &lt; teaN)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> pos = searchKeyPos(<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        key[pos] = q[j++].num;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=keyN; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; key[i] &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201709-3-JSON查询"><a href="#201709-3-JSON查询" class="headerlink" title="201709-3 JSON查询"></a>201709-3 JSON查询</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201709-3 JSON查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsRoot</span><span class="params">(<span class="built_in">string</span> &amp;json_str, <span class="keyword">size_t</span> pos)</span></span>&#123; <span class="comment">//判断是否为根元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> p_cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;pos; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(json_str[i] == <span class="string">'&#123;'</span>) p_cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(json_str[i] == <span class="string">'&#125;'</span>) p_cnt--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> p_cnt==<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Split(<span class="built_in">string</span> str)&#123; <span class="comment">//将字符串按'.'分割为字符串向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">"."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(pos != <span class="built_in">string</span>::npos)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ret.push_back(str.substr(<span class="number">0</span>, pos));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str = str.substr(pos+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pos = str.<span class="built_in">find</span>(<span class="string">"."</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ret.push_back(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ret;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">SubJsonStr</span><span class="params">(<span class="built_in">string</span> json_str, <span class="keyword">int</span> l_pos)</span></span>&#123; <span class="comment">//返回子JSON串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> p_cnt = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> r_pos = l_pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(p_cnt)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(json_str[r_pos]==<span class="string">'&#123;'</span>)    p_cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(json_str[r_pos]==<span class="string">'&#125;'</span>)   p_cnt--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        r_pos++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> json_str.substr(l_pos, r_pos-l_pos<span class="number">-1</span>) + <span class="string">','</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;ret, <span class="built_in">string</span> json_str)</span></span>&#123; <span class="comment">//JSON查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i &lt; ret.<span class="built_in">size</span>()<span class="number">-1</span>)&#123; <span class="comment">//依次遍历待查询JSON串向量的每一项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">size_t</span> pos = json_str.<span class="built_in">find</span>(ret[i]+<span class="string">":&#123;"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(pos==<span class="built_in">string</span>::npos || !IsRoot(json_str, pos))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NOTEXIST\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        json_str = SubJsonStr(json_str, pos+ret[i].<span class="built_in">size</span>()+<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> pos = json_str.<span class="built_in">find</span>(ret.back()+<span class="string">":"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(pos==<span class="built_in">string</span>::npos || !IsRoot(json_str, pos))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NOTEXIST\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i = pos + ret.back().<span class="built_in">size</span>() + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(json_str[i] == <span class="string">'&#123;'</span>)  <span class="built_in">cout</span> &lt;&lt; <span class="string">"OBJECT\n"</span>; <span class="comment">//是对象的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">size_t</span> dp = json_str.<span class="built_in">find</span>(<span class="string">","</span>, i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(dp == <span class="built_in">string</span>::npos)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"NOTEXIST\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">string</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(i &lt; dp)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                x += json_str[i++];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"STRING "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//是字符串的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> json_str; <span class="comment">//JSON字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>(); <span class="built_in">cin</span>.<span class="built_in">get</span>();  <span class="comment">// '&#123;' 与 '\n'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>((ch=<span class="built_in">cin</span>.<span class="built_in">get</span>()) != <span class="string">'\n'</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(ch==<span class="string">' '</span> || ch==<span class="string">'"'</span>) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(ch == <span class="string">'\\'</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                json_str += <span class="built_in">cin</span>.<span class="built_in">get</span>(); <span class="comment">//至包含一个 '\'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            json_str += ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    json_str[json_str.length()<span class="number">-1</span>] = <span class="string">','</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(m--)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> str;  <span class="comment">//待查询JSON字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret = Split(str);  <span class="comment">//将待查询JSON分割为字符串向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        Search(ret, json_str);  <span class="comment">//JSON查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201709-4-通信网络"><a href="#201709-4-通信网络" class="headerlink" title="201709-4 通信网络"></a>201709-4 通信网络</h3><h3 id="201709-5-除法"><a href="#201709-5-除法" class="headerlink" title="201709-5 除法"></a>201709-5 除法</h3><p>简单尝试的超时代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201709-5 除法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l, r, v, sum = <span class="number">0</span>; <span class="comment">//起点、终点、除数、和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDivid</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> *a)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a[i]%v == <span class="number">0</span>)   </span></pre></td></tr><tr><td class="code"><pre><span class="line">            a[i] /= v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += a[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">//数的个数和操作的次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n+<span class="number">1</span>]; <span class="comment">//n个整数：下标为1～n</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> opt; <span class="comment">//操作标识</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; opt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>) <span class="comment">//倍数做除法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            doDivid(n, a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>) <span class="comment">//求和运算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; getSum(n, a) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>下面是上网学习到的<code>树形数组</code>解决方案：<a href="https://blog.csdn.net/gl486546/article/details/78359480" target="_blank" rel="noopener">源代码地址</a>  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201709-5 除法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tree[<span class="number">101024</span>]; <span class="comment">//树形数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">101024</span>]; <span class="comment">//数的个数、操作的次数、一组数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span></span>&#123; <span class="comment">//更新树形数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tree[i] += val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i += -i &amp; i; <span class="comment">//i+(-i&amp;i)是i的父节点，-i&amp;i得出i末尾0的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//求和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += tree[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i -= -i &amp; i; <span class="comment">//i-(-i&amp;i)是前一个棵树的根节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        update(i, a[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; ++i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> opt, l, r, w; <span class="comment">//操作标识、起点、终点、除数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;opt, &amp;l, &amp;r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(opt == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getsum(r)-getsum(l<span class="number">-1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(w == <span class="number">1</span>) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(a[l]&gt;=w &amp;&amp; a[l]%w==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    update(l, -(a[l]-a[l]/w));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    a[l] /= w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ++l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/xudong-bupt/p/3484080.html" target="_blank" rel="noopener">树状数组(Binary Indexed Tree) 总结</a></li>
<li><a href="https://blog.csdn.net/flushhip/article/details/79165701" target="_blank" rel="noopener">树状数组简单易懂的详解</a></li>
<li><a href="https://www.cnblogs.com/George1994/p/7710886.html" target="_blank" rel="noopener">树状数组的原理和实现</a></li>
</ul>
<h2 id="3月-1"><a href="#3月-1" class="headerlink" title="3月"></a>3月</h2><h3 id="201703-1-分蛋糕"><a href="#201703-1-分蛋糕" class="headerlink" title="201703-1 分蛋糕"></a>201703-1 分蛋糕</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201703-1 分蛋糕</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>; <span class="comment">//每个人依次分到蛋糕的总重量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//已分配的蛋糕数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> w; <span class="comment">//依次输入的每块蛋糕的重量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>; <span class="comment">//分到蛋糕的朋友数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        s = w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(i&lt;n &amp;&amp; s&lt;k)&#123; <span class="comment">//当还有蛋糕并且此人分到蛋糕重量少于k</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            s += w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ++i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201703-2-学生排队"><a href="#201703-2-学生排队" class="headerlink" title="201703-2 学生排队"></a>201703-2 学生排队</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201703-2 学生排队</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mpos[<span class="number">1024</span>], ran[<span class="number">1024</span>]; <span class="comment">//移动位置数组， 队伍排序数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> len, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>&#123; <span class="comment">//位置，长度，步长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> temp = ran[pos];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(len)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ran[pos] = ran[pos+<span class="built_in">step</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mpos[ran[pos]] = pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pos += <span class="built_in">step</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mpos[temp] = pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ran[pos] = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ran[i] = mpos[i] = i; <span class="comment">//1-n做标记</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> id, val; <span class="comment">//序号，移动数值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> pos = mpos[id]; <span class="comment">//开始移动的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        val&lt;<span class="number">0</span> ? <span class="built_in">move</span>(pos, -val, <span class="number">-1</span>) : <span class="built_in">move</span>(pos, val, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; ran[i] &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201703-3-Markdown"><a href="#201703-3-Markdown" class="headerlink" title="201703-3 Markdown"></a>201703-3 Markdown</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201703-3 Markdown</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> <span class="built_in">line</span>, <span class="built_in">text</span>; <span class="comment">//Md文本行与html文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> is_over = <span class="literal">false</span>; <span class="comment">//判断是否结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    getline(<span class="built_in">cin</span>, <span class="built_in">line</span>); <span class="comment">//读取一行数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="built_in">line</span>.<span class="built_in">size</span>()&gt;<span class="number">0</span>)   <span class="built_in">text</span> += <span class="built_in">line</span> + <span class="string">"\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">line</span>.<span class="built_in">size</span>()==<span class="number">0</span> &amp;&amp; <span class="built_in">text</span>.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">size_t</span> pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"_"</span>); <span class="comment">//强调文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(pos != <span class="built_in">string</span>::npos)&#123; <span class="comment">//用 &lt;em&gt; 替换 _</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span>.replace(pos, <span class="number">1</span>, <span class="string">"&lt;em&gt;"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">size_t</span> next_pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"_"</span>, pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span>.replace(next_pos, <span class="number">1</span>, <span class="string">"&lt;/em&gt;"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"_"</span>, next_pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"["</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(pos != <span class="built_in">string</span>::npos)&#123; <span class="comment">//用 &lt;a&gt; 替换 []()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">size_t</span> next_pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"]"</span>, pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">size_t</span> left_pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"("</span>, next_pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">size_t</span> right_pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">")"</span>, left_pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">string</span> text_for_link = <span class="built_in">text</span>.substr(pos+<span class="number">1</span>, next_pos-pos<span class="number">-1</span>); <span class="comment">//链接文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">string</span> link = <span class="built_in">text</span>.substr(left_pos+<span class="number">1</span>, right_pos-left_pos<span class="number">-1</span>); <span class="comment">//链接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span>.replace(<span class="built_in">text</span>.<span class="built_in">begin</span>()+pos, <span class="built_in">text</span>.<span class="built_in">begin</span>()+right_pos+<span class="number">1</span>, <span class="string">"&lt;a href=\""</span>+link+<span class="string">"\"&gt;"</span>+text_for_link+<span class="string">"&lt;/a&gt;"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"["</span>, right_pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">text</span>[<span class="number">0</span>] == <span class="string">'#'</span>)&#123; <span class="comment">//用 &lt;h1&gt;标题&lt;/h1&gt; 替换 # 标题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span>(<span class="built_in">text</span>[i]==<span class="string">'#'</span>) ++i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span> = <span class="built_in">text</span>.substr(i+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span> = <span class="string">"&lt;h"</span> + <span class="built_in">string</span>(<span class="number">1</span>, <span class="string">'0'</span>+i) + <span class="string">"&gt;"</span> + <span class="built_in">text</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span>.insert(<span class="built_in">text</span>.<span class="built_in">size</span>()<span class="number">-1</span>, <span class="string">"&lt;/h"</span>+<span class="built_in">string</span>(<span class="number">1</span>, <span class="string">'0'</span>+i)+<span class="string">"&gt;"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">text</span>[<span class="number">0</span>] == <span class="string">'*'</span>)&#123; <span class="comment">//用 &lt;ul&gt;&lt;li&gt;组合 替换 * 列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span>.insert(<span class="number">0</span>, <span class="string">"&lt;ul&gt;\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span>.insert(<span class="built_in">text</span>.<span class="built_in">size</span>(), <span class="string">"&lt;/ul&gt;\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">size_t</span> pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"*"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span>(pos != <span class="built_in">string</span>::npos)&#123; <span class="comment">//用 &lt;li&gt; 替换 * 列表项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">size_t</span> next_pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"\n"</span>, pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">text</span>.insert(next_pos, <span class="string">"&lt;/li&gt;"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">text</span>.replace(pos, <span class="number">2</span>, <span class="string">"&lt;li&gt;"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    pos = <span class="built_in">text</span>.<span class="built_in">find</span>(<span class="string">"*"</span>, next_pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//正常段落格式 &lt;p&gt;段落文本&lt;/p&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span> = <span class="string">"&lt;p&gt;"</span> + <span class="built_in">text</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">text</span>.insert(<span class="built_in">text</span>.<span class="built_in">size</span>()<span class="number">-1</span>, <span class="string">"&lt;/p&gt;"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">text</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">text</span> = <span class="string">""</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">line</span> = <span class="string">""</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(is_over) <span class="keyword">break</span>; <span class="comment">//结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            is_over = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">line</span> = <span class="string">""</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201703-4-地铁修建"><a href="#201703-4-地铁修建" class="headerlink" title="201703-4 地铁修建"></a>201703-4 地铁修建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201703-4 地铁修建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> u, v; <span class="comment">//隧道的开始枢纽，终点枢纽</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> w; <span class="comment">//建造所需时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : u(a), v(b), w(c)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> edge &amp;p) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> w &lt; p.w; <span class="comment">//自定义比较方式：比较建造所需时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;; <span class="comment">//隧道的结构体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;edge&gt; tunnel; <span class="comment">//隧道向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//交通枢纽数，候选隧道数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> company[<span class="number">100001</span>]; <span class="comment">//n个公司负责的枢纽</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x==company[x] ? x : company[x]=<span class="built_in">find</span>(company[x]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) company[i] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(tunnel[i].u), y = <span class="built_in">find</span>(tunnel[i].v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(x != y)  company[x] = y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(<span class="number">1</span>) == <span class="built_in">find</span>(n))  <span class="keyword">return</span> tunnel[i].w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> a, b, c; <span class="comment">//枢纽a，枢纽b，a与b之间隧道建造的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tunnel.push_back(edge(a, b, c));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(tunnel.<span class="built_in">begin</span>(), tunnel.<span class="built_in">end</span>()); <span class="comment">//按照修建时间生序排列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; kruskal();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/JoshuaMK/p/prim_kruskal.html" target="_blank" rel="noopener">最小生成树Prim算法和Kruskal算法</a></li>
<li><a href="https://www.cnblogs.com/yoke/p/6697013.html" target="_blank" rel="noopener">最小生成树之克鲁斯卡尔（Kruskal）算法</a></li>
</ul>
<h3 id="201703-5-引水入城"><a href="#201703-5-引水入城" class="headerlink" title="201703-5 引水入城"></a>201703-5 引水入城</h3><h1 id="2016年"><a href="#2016年" class="headerlink" title="2016年"></a>2016年</h1><h2 id="12月-2"><a href="#12月-2" class="headerlink" title="12月"></a>12月</h2><h3 id="201612-1-中间数"><a href="#201612-1-中间数" class="headerlink" title="201612-1 中间数"></a>201612-1 中间数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201612-1 中间数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v.push_back(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> j = v.<span class="built_in">size</span>()/<span class="number">2</span>, i = (v.<span class="built_in">size</span>()%<span class="number">2</span>==<span class="number">0</span>) ? j<span class="number">-1</span> : j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> e = v[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n &amp;&amp; v[i]==v[j] &amp;&amp; v[i]==e)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --i, ++j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; (v[i]==e || v[j]==e))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201612-2-工资计算"><a href="#201612-2-工资计算" class="headerlink" title="201612-2 工资计算"></a>201612-2 工资计算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201612-2 工资计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> rate[] = &#123;<span class="number">0</span>, <span class="number">0.03</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.25</span>, <span class="number">0.3</span>, <span class="number">0.35</span>, <span class="number">0.45</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v[]=&#123;<span class="number">3500</span>,<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">4500</span>,<span class="number">26000</span>,<span class="number">20000</span>,<span class="number">25000</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> u[]=&#123;<span class="number">3500</span>,<span class="number">1500</span>,<span class="number">3000</span>,<span class="number">4500</span>,<span class="number">26000</span>,<span class="number">20000</span>,<span class="number">25000</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpt</span><span class="params">()</span></span>&#123; <span class="comment">//计算各个工资临界值的税费</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">7</span>; ++i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        u[i] += u[i<span class="number">-1</span>]; <span class="comment">//u的循环结果依次为各个临界工资值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        v[i] = v[i<span class="number">-1</span>] + v[i]*(<span class="number">1</span>-rate[i]);  <span class="comment">//v的循环结果依次为各个临界工资值对应的税费</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> t, i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(t &lt;= <span class="number">3500</span>)&#123; <span class="comment">//税后所得少于3500，则S少于3500，即不交税</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; t &lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cpt(); <span class="comment">//计算临界工资对应的税费</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(v[i]&lt;=t &amp;&amp; i&lt;<span class="number">7</span>) ++i;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    --i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> s = u[i] + (t-v[i])/(<span class="number">1</span>-rate[i+<span class="number">1</span>]); <span class="comment">//计算税前工资</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201612-3-权限查询"><a href="#201612-3-权限查询" class="headerlink" title="201612-3 权限查询"></a>201612-3 权限查询</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201612-3 权限查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NOVALUE = <span class="number">-1</span>; <span class="comment">//不分等级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> TRUE = <span class="number">-2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FALSE = <span class="number">-3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">privilege</span> &#123;</span> <span class="comment">//权限</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> category;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> level;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;_privilege&gt; privilege;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">role</span> &#123;</span> <span class="comment">//角色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> role;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;_privilege&gt; privilege; <span class="comment">//每个角色有多个权限</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;_role&gt; role;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">user</span> &#123;</span> <span class="comment">//用户</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> user;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; role; <span class="comment">//每个用户有多个角色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;_user&gt; user;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getcategory</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span>&#123; <span class="comment">//得到权限类别</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> pos = s.<span class="built_in">find</span>(<span class="string">":"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(pos == (<span class="keyword">int</span>)<span class="built_in">string</span>::npos)    <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> s.substr(<span class="number">0</span>, pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlevel</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123; <span class="comment">//得到权限等级</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> pos = s.<span class="built_in">find</span>(<span class="string">":"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(pos == (<span class="keyword">int</span>)<span class="built_in">string</span>::npos)    <span class="keyword">return</span> NOVALUE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> atoi(s.substr(pos+<span class="number">1</span>, s.length()<span class="number">-1</span>).c_str());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//atoi: 将string转换为int</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">privilegematch</span><span class="params">(_privilege&amp; p1, _privilege&amp; p2)</span></span>&#123; <span class="comment">//权限匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(p1.category != p2.category)  <span class="keyword">return</span> FALSE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p2.level == NOVALUE) &#123; <span class="comment">//不分等级查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p1.level == NOVALUE) <span class="keyword">return</span> TRUE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> p1.level;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//分等级查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(p1.level == NOVALUE) <span class="keyword">return</span> TRUE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(p1.level &gt;= p2.level)    <span class="keyword">return</span> TRUE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>    <span class="keyword">return</span> FALSE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rolematch</span><span class="params">(<span class="built_in">string</span>&amp; rl, _privilege&amp; prvl)</span></span>&#123; <span class="comment">//角色匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = FALSE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)role.<span class="built_in">size</span>(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(role[i].role == rl) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;role[i].s; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> rt = privilegematch(role[i].privilege[j], prvl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(rt &gt; ans)    ans = rt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span>&amp; usr, _privilege&amp; prvl)</span></span>&#123; <span class="comment">//查询用户权限</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)user.<span class="built_in">size</span>(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(user[i].user == usr) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> ans = FALSE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;user[i].t; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> rt = rolematch(user[i].role[j], prvl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(rt &gt; ans)    ans = rt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> FALSE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> p, r, u, q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; p; <span class="comment">//权限类别数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> c; <span class="comment">//每个权限类别</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _privilege prvl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=p; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prvl.category = getcategory(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prvl.level = getlevel(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        privilege.push_back(prvl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; r; <span class="comment">//角色数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=r; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _role rl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; rl.role &gt;&gt; rl.s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=rl.s; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            prvl.category = getcategory(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            prvl.level = getlevel(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            rl.privilege.push_back(prvl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        role.push_back(rl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; u; <span class="comment">//用户数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=u; i++) &#123; <span class="comment">//输入每个用户</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        _user us;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; us.user &gt;&gt; us.t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=us.t; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            us.role.push_back(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        user.push_back(us);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; q; <span class="comment">//查询数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> suser; <span class="comment">//每个授权查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=q; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; suser &gt;&gt; c; <span class="comment">//查询用户、权限</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        prvl.category = getcategory(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prvl.level = getlevel(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> ans = query(suser, prvl);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(ans == TRUE) <span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans == FALSE)   <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：<a href="http://www.voidcn.com/article/p-ddgtoqww-bqh.html" target="_blank" rel="noopener">201612-3 权限查询</a></p>
<h3 id="201612-4-压缩编码"><a href="#201612-4-压缩编码" class="headerlink" title="201612-4 压缩编码"></a>201612-4 压缩编码</h3><h3 id="201612-5-卡牌游戏"><a href="#201612-5-卡牌游戏" class="headerlink" title="201612-5 卡牌游戏"></a>201612-5 卡牌游戏</h3><h2 id="9月-2"><a href="#9月-2" class="headerlink" title="9月"></a>9月</h2><h3 id="201609-1-最大波动"><a href="#201609-1-最大波动" class="headerlink" title="201609-1 最大波动"></a>201609-1 最大波动</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201609-1 最大波动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, <span class="built_in">max</span> = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> tmp = <span class="built_in">abs</span>(a[i]-a[i<span class="number">-1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">max</span> = <span class="built_in">max</span> &gt; tmp ? <span class="built_in">max</span> : tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201609-2-火车购票"><a href="#201609-2-火车购票" class="headerlink" title="201609-2 火车购票"></a>201609-2 火车购票</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201609-2 火车购票</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">20</span>, <span class="number">5</span>); <span class="comment">//一节车厢有20排、每一排5个座位</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x; <span class="comment">//输入要购入的票数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;<span class="number">20</span>&amp;&amp;x&gt;<span class="number">0</span>; r++) <span class="comment">//逐行查找</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(v[r] &gt;= x)&#123; <span class="comment">//该行空余座位大于需求x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> seat = r*<span class="number">5</span>+<span class="number">5</span>-v[r]+<span class="number">1</span>; <span class="comment">//给空闲座位编号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                v[r] -= x; <span class="comment">//x个已购，更新空余座位</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span>(x--)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; seat++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(x&gt;<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>) <span class="comment">//没有连续座位</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;<span class="number">20</span>&amp;&amp;x&gt;<span class="number">0</span>; r++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span>(v[r]&gt;<span class="number">0</span> &amp;&amp; x&gt;<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">int</span> seat = r*<span class="number">5</span>+<span class="number">5</span>-v[r]+<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="built_in">cout</span> &lt;&lt; seat++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    --v[r];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    --x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(x&gt;<span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201609-3-炉石传说"><a href="#201609-3-炉石传说" class="headerlink" title="201609-3 炉石传说"></a>201609-3 炉石传说</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201609-3 炉石传说</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">role</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> attack, health; <span class="comment">//每个角色的攻击力和健康值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    role(<span class="keyword">int</span> ak, <span class="keyword">int</span> ht):attack(ak), health(ht)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;role&gt; va, vb; <span class="comment">//两个角色vector</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, <span class="built_in">turn</span> = <span class="number">0</span>; <span class="comment">//操作个数、转换回合标志</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="built_in">vector</span>&lt;role&gt; &amp;v)</span></span>&#123; <span class="comment">//输出生命值、随从个数等信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; v[<span class="number">0</span>].health &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.<span class="built_in">size</span>()<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i&lt;v.<span class="built_in">size</span>(); i++)    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; v[i].health;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    va.push_back(role(<span class="number">0</span>,<span class="number">30</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vb.push_back(role(<span class="number">0</span>,<span class="number">30</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> action; <span class="comment">//每个操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; action;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(action == <span class="string">"summon"</span>)&#123; <span class="comment">//召唤随从</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> pos, ak, ht; <span class="comment">//位置、攻击力、健康值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; pos &gt;&gt; ak &gt;&gt; ht;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">turn</span>==<span class="number">0</span>) va.insert(va.<span class="built_in">begin</span>()+pos,role(ak,ht));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> vb.insert(vb.<span class="built_in">begin</span>()+pos,role(ak,ht));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(action==<span class="string">"end"</span>) <span class="comment">//结束该回合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">turn</span> = (<span class="built_in">turn</span>+<span class="number">1</span>)%<span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(action==<span class="string">"attack"</span>)&#123; <span class="comment">//攻击</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> i, j; <span class="comment">//发起攻击的随从号、被攻击的对方角色号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">turn</span>==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                va[i].health -= vb[j].attack;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                vb[j].health -= va[i].attack;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(va[i].health&lt;=<span class="number">0</span>&amp;&amp;i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    va.erase(va.<span class="built_in">begin</span>()+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(vb[j].health&lt;=<span class="number">0</span>&amp;&amp;j)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    vb.erase(vb.<span class="built_in">begin</span>()+j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                vb[i].health -= va[j].attack;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                va[j].health -= vb[i].attack;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(va[j].health&lt;=<span class="number">0</span>&amp;&amp;j)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    va.erase(va.<span class="built_in">begin</span>()+j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(vb[i].health&lt;=<span class="number">0</span>&amp;&amp;i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    vb.erase(vb.<span class="built_in">begin</span>()+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(va[<span class="number">0</span>].health&lt;=<span class="number">0</span> || vb[<span class="number">0</span>].health&lt;=<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(va[<span class="number">0</span>].health&lt;=<span class="number">0</span>&amp;&amp;vb[<span class="number">0</span>].health&gt;<span class="number">0</span>) <span class="comment">//后手玩家胜</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(va[<span class="number">0</span>].health&gt;<span class="number">0</span>&amp;&amp;vb[<span class="number">0</span>].health&lt;=<span class="number">0</span>) <span class="comment">//先手玩家胜</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//游戏尚未结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">display</span>(va);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">display</span>(vb);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201609-4-交通规划"><a href="#201609-4-交通规划" class="headerlink" title="201609-4 交通规划"></a>201609-4 交通规划</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201609-4 交通规划</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//城市数，铁路数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cost;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    edge(<span class="keyword">int</span> x, <span class="keyword">int</span> c) : v(x), cost(c)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(edge &amp;a, edge &amp;b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;edge&gt; vg[<span class="number">10000</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> a, b, c; <span class="comment">//城市a，城市b，a与b之间双向铁路的长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        --a, --b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vg[a].push_back(edge(b, c));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vg[b].push_back(edge(a, c));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//dijkstra</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    priority_queue&lt;edge,<span class="built_in">vector</span>&lt;edge&gt;,cmp&gt; pq;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n, INF);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cost(n, INF);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pq.push(edge(<span class="number">0</span>, <span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dist[<span class="number">0</span>] = cost[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        edge t = pq.top(); <span class="comment">//最短路径（花费）边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        pq.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        visit[t.v] = <span class="number">1</span>; <span class="comment">//访问该节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;vg[t.v].<span class="built_in">size</span>(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            edge e = vg[t.v][i]; <span class="comment">//该节点的所有邻接边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(visit[e.v])  <span class="keyword">continue</span>; <span class="comment">//另外一端节点访问过了，跳过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(dist[e.v] &gt; dist[t.v]+e.cost) &#123; <span class="comment">//更新最短路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                dist[e.v] = dist[t.v] + e.cost;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cost[e.v] = e.cost;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                pq.push(edge(e.v, dist[e.v])); <span class="comment">//新的更新边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[e.v] == dist[t.v]+e.cost)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cost[e.v] = <span class="built_in">min</span>(cost[e.v], e.cost);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += cost[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：</p>
<ul>
<li><a href="https://blog.csdn.net/gl486546/article/details/79159274" target="_blank" rel="noopener">201609-4 交通规划 ccf</a></li>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener">最短路径问题—Dijkstra算法详解</a></li>
</ul>
<h3 id="201609-5-祭坛"><a href="#201609-5-祭坛" class="headerlink" title="201609-5 祭坛"></a>201609-5 祭坛</h3><h2 id="4月"><a href="#4月" class="headerlink" title="4月"></a>4月</h2><h3 id="201604-1-折点计数"><a href="#201604-1-折点计数" class="headerlink" title="201604-1 折点计数"></a>201604-1 折点计数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201604-1 折点计数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, num = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[<span class="number">0</span>] &gt;&gt; a[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>((a[i<span class="number">-2</span>]&gt;a[i<span class="number">-1</span>] &amp;&amp; a[i<span class="number">-1</span>]&lt;a[i]) || (a[i<span class="number">-2</span>]&lt;a[i<span class="number">-1</span>] &amp;&amp; a[i<span class="number">-1</span>]&gt;a[i]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            num++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201604-2-俄罗斯方块"><a href="#201604-2-俄罗斯方块" class="headerlink" title="201604-2 俄罗斯方块"></a>201604-2 俄罗斯方块</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201604-2 俄罗斯方块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ROW = <span class="number">15</span>; <span class="comment">//方格图行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> COL = <span class="number">10</span>; <span class="comment">//方格图列数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4</span>;    <span class="comment">//新方块阶数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> board[ROW+<span class="number">1</span>][COL]; <span class="comment">//初始方格图，最下面一行全为1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> block[N][N]; <span class="comment">//新方块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> row, col; &#125; coords[N];  <span class="comment">//新方块的模式块数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> row, col;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 输入数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ROW; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;COL; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; board[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; block[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; col; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 底边全放1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;COL; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        board[ROW][j] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 提取新方块的模式块坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(block[i][j] == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                coords[k].row = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                coords[k].col = j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                k++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 模拟新方块落下过程</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    row = <span class="number">1</span>, col--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> checkflag;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        checkflag = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(board[row + coords[i].row][col + coords[i].col] == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                checkflag = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(checkflag)   <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        row++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    row--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 合并新方块到方格图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        board[row + coords[i].row][col + coords[i].col] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 输出结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;ROW; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;COL; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(j != <span class="number">0</span>)  <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; board[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201604-3-路径解析"><a href="#201604-3-路径解析" class="headerlink" title="201604-3 路径解析"></a>201604-3 路径解析</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201604-3 路径解析</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n; <span class="comment">//路径个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> curDir; <span class="comment">//当前目录</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; curDir;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    getchar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> <span class="built_in">line</span>; <span class="comment">//每一个待处理路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        getline(<span class="built_in">cin</span>, <span class="built_in">line</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">size_t</span> pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//添加当前目录</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="built_in">line</span>[<span class="number">0</span>] != <span class="string">'/'</span>)  <span class="built_in">line</span> = curDir + <span class="string">'/'</span> + <span class="built_in">line</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="built_in">line</span>.<span class="built_in">size</span>() == <span class="number">0</span>)    <span class="built_in">line</span> = curDir;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//除去多个'///'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>((pos = <span class="built_in">line</span>.<span class="built_in">find</span>(<span class="string">"//"</span>)) != <span class="number">-1</span>)&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> count = <span class="number">2</span>; <span class="comment">// '/'的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(<span class="built_in">line</span>[pos + count] == <span class="string">'/'</span>) count++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">line</span>.erase(pos, count<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//除去'../'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>((pos = <span class="built_in">line</span>.<span class="built_in">find</span>(<span class="string">"/../"</span>)) != <span class="number">-1</span>)&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(pos == <span class="number">0</span>)    <span class="built_in">line</span>.erase(pos+<span class="number">1</span>, <span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">size_t</span> nxp = <span class="built_in">line</span>.rfind(<span class="string">"/"</span>, pos<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">line</span>.erase(nxp, pos-nxp+<span class="number">3</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>((pos = <span class="built_in">line</span>.<span class="built_in">find</span>(<span class="string">"/./"</span>)) != <span class="number">-1</span>) <span class="comment">//除去'./'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">line</span>.erase(pos+<span class="number">1</span>, <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="built_in">line</span>.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; <span class="built_in">line</span>[<span class="built_in">line</span>.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="string">'/'</span>) <span class="comment">//除去末尾'/'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">line</span>.erase(<span class="built_in">line</span>.<span class="built_in">size</span>()<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201604-4-游戏"><a href="#201604-4-游戏" class="headerlink" title="201604-4 游戏"></a>201604-4 游戏</h3><h3 id="201604-5-网络连接"><a href="#201604-5-网络连接" class="headerlink" title="201604-5 网络连接"></a>201604-5 网络连接</h3><h1 id="2015年"><a href="#2015年" class="headerlink" title="2015年"></a>2015年</h1><h2 id="12月-3"><a href="#12月-3" class="headerlink" title="12月"></a>12月</h2><h3 id="201512-1-数位之和"><a href="#201512-1-数位之和" class="headerlink" title="201512-1 数位之和"></a>201512-1 数位之和</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201512-1 数位之和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> t = n%<span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        n /= <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201512-1 数位之和——改进版</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>((x=getchar()) != <span class="string">'\n'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += x-<span class="string">'0'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201512-2-消除类游戏"><a href="#201512-2-消除类游戏" class="headerlink" title="201512-2 消除类游戏"></a>201512-2 消除类游戏</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201512-2 消除类游戏</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">30</span>][<span class="number">30</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//输入数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//行可消除的标记为负</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m<span class="number">-2</span>; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][j])==<span class="built_in">abs</span>(a[i][j+<span class="number">1</span>]) &amp;&amp; <span class="built_in">abs</span>(a[i][j+<span class="number">1</span>])==<span class="built_in">abs</span>(a[i][j+<span class="number">2</span>]))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(a[i][j] &gt; <span class="number">0</span>) a[i][j] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(a[i][j+<span class="number">1</span>] &gt; <span class="number">0</span>) a[i][j+<span class="number">1</span>] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(a[i][j+<span class="number">2</span>] &gt; <span class="number">0</span>) a[i][j+<span class="number">2</span>] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//列可消除的标记为负</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-2</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i][j])==<span class="built_in">abs</span>(a[i+<span class="number">1</span>][j]) &amp;&amp; <span class="built_in">abs</span>(a[i+<span class="number">1</span>][j])==<span class="built_in">abs</span>(a[i+<span class="number">2</span>][j]))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(a[i][j] &gt; <span class="number">0</span>) a[i][j] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(a[i+<span class="number">1</span>][j] &gt; <span class="number">0</span>) a[i+<span class="number">1</span>][j] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(a[i+<span class="number">2</span>][j] &gt; <span class="number">0</span>) a[i+<span class="number">2</span>][j] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//完成消除</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(a[i][j] &lt; <span class="number">0</span>) a[i][j] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(j != <span class="number">0</span>)  <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201512-3-画图"><a href="#201512-3-画图" class="headerlink" title="201512-3 画图"></a>201512-3 画图</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201512-3 画图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DIRECTSIZE = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">direct</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> dx, dy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; direct[DIRECTSIZE] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> grid[N+<span class="number">1</span>][N+<span class="number">1</span>]; <span class="comment">//画布</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> c, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//递归填充：被填充的点的四周也要填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> nx, ny;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grid[y][x] = c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;DIRECTSIZE; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ny = y + direct[i].dy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        nx = x + direct[i].dx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>&lt;=nx &amp;&amp; nx&lt;m &amp;&amp; <span class="number">0</span>&lt;=ny &amp;&amp; ny&lt;n &amp;&amp; grid[ny][nx]!=<span class="string">'|'</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">            &amp;&amp; grid[ny][nx]!=<span class="string">'-'</span> &amp;&amp; grid[ny][nx]!=<span class="string">'+'</span> &amp;&amp; grid[ny][nx]!=c)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">fill</span>(nx, ny, c, m, n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m, n, q; <span class="comment">//画布的宽度、高度、画图操作个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2; <span class="comment">//坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> start, <span class="built_in">end</span>; <span class="comment">//线段起点和终点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(grid, <span class="string">'.'</span>, <span class="keyword">sizeof</span>(grid)); <span class="comment">// 变量初始化：全部设置为“.”</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=q; i++) &#123; <span class="comment">//依次完成q个画图操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> option; <span class="comment">//每行的画图形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; option;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(option == <span class="number">0</span>) &#123; <span class="comment">//画线段</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(x1 == x2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                start = <span class="built_in">min</span>(y1, y2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">end</span> = <span class="built_in">max</span>(y1, y2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=start; j&lt;=<span class="built_in">end</span>; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(grid[j][x1] == <span class="string">'-'</span> || grid[j][x1] == <span class="string">'+'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        grid[j][x1] = <span class="string">'+'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span>    grid[j][x1] = <span class="string">'|'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(y1 == y2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                start = <span class="built_in">min</span>(x1, x2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">end</span> = <span class="built_in">max</span>(x1, x2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=start; j&lt;=<span class="built_in">end</span>; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(grid[y1][j] == <span class="string">'|'</span> || grid[y1][j] == <span class="string">'+'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        grid[y1][j] = <span class="string">'+'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span>    grid[y1][j] = <span class="string">'-'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(option == <span class="number">1</span>) &#123; <span class="comment">//填充字符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">char</span> c; <span class="comment">//填充字符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">fill</span>(x1, y1, c, m, n); <span class="comment">//递归填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; grid[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：<a href="http://www.voidcn.com/article/p-hnsghtoe-bqh.html" target="_blank" rel="noopener">201512-3 画图</a></p>
<h3 id="201512-4-送货"><a href="#201512-4-送货" class="headerlink" title="201512-4 送货"></a>201512-4 送货</h3><h3 id="201512-5-矩阵"><a href="#201512-5-矩阵" class="headerlink" title="201512-5 矩阵"></a>201512-5 矩阵</h3><h2 id="9月-3"><a href="#9月-3" class="headerlink" title="9月"></a>9月</h2><h3 id="201509-1-数列分段"><a href="#201509-1-数列分段" class="headerlink" title="201509-1 数列分段"></a>201509-1 数列分段</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201509-1 数列分段</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, s = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; a[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a[i]!=a[i<span class="number">-1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            s++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201509-2-日期计算"><a href="#201509-2-日期计算" class="headerlink" title="201509-2 日期计算"></a>201509-2 日期计算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201509-2 日期计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> y, d, k = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; y &gt;&gt; d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> limit[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(y%<span class="number">400</span>==<span class="number">0</span> || (y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">100</span>)) <span class="comment">//是闰年</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        limit[<span class="number">1</span>] = <span class="number">29</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">12</span>; i++) <span class="comment">// 每月的临界天数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        limit[i] += limit[i<span class="number">-1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(d &gt; limit[k])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        k++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> month = k + <span class="number">1</span>, day = d - limit[k<span class="number">-1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; month &lt;&lt; <span class="built_in">endl</span> &lt;&lt; day &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201509-3-模板生成系统"><a href="#201509-3-模板生成系统" class="headerlink" title="201509-3 模板生成系统"></a>201509-3 模板生成系统</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201509-3 模板生成系统</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span>.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> str_in, str_out; <span class="comment">//输入和输出的字符串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mmp; <span class="comment">//需要处理的map键值对</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(n--)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> <span class="built_in">line</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        getline(<span class="built_in">cin</span>, <span class="built_in">line</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str_in += <span class="built_in">line</span> + <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(m--)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> key, val; <span class="comment">//map的键与值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; key;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span>.<span class="built_in">get</span>();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        getline(<span class="built_in">cin</span>, val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        val = val.substr(<span class="number">1</span>, val.<span class="built_in">size</span>()<span class="number">-2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mmp[key] = val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> pos, next_pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>((pos=str_in.<span class="built_in">find</span>(<span class="string">"&#123;&#123; "</span>)) != <span class="built_in">string</span>::npos)&#123; <span class="comment">//完成值的填充</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        next_pos = str_in.<span class="built_in">find</span>(<span class="string">" &#125;&#125;"</span>) + <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">key</span><span class="params">(str_in.<span class="built_in">begin</span>()+pos+<span class="number">3</span>, str_in.<span class="built_in">begin</span>()+next_pos<span class="number">-3</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str_out += str_in.substr(<span class="number">0</span>, pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str_in = str_in.substr(next_pos);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> var = mmp.count(key) ? mmp[key] : <span class="string">""</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str_out += var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    str_out += str_in;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; str_out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201509-4-高速公路"><a href="#201509-4-高速公路" class="headerlink" title="201509-4 高速公路"></a>201509-4 高速公路</h3><h3 id="201509-5-最佳文章"><a href="#201509-5-最佳文章" class="headerlink" title="201509-5 最佳文章"></a>201509-5 最佳文章</h3><h2 id="3月-2"><a href="#3月-2" class="headerlink" title="3月"></a>3月</h2><h3 id="201503-1-图像旋转"><a href="#201503-1-图像旋转" class="headerlink" title="201503-1 图像旋转"></a>201503-1 图像旋转</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201503-1 图像旋转</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1024</span>][<span class="number">1024</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201503-2-数字排序"><a href="#201503-2-数字排序" class="headerlink" title="201503-2 数字排序"></a>201503-2 数字排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201503-2 数字排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, a[<span class="number">1024</span>]; <span class="comment">//整数个数与整数序列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> id, cnt; <span class="comment">//每个整数的序号和出现次数值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    node(<span class="keyword">int</span> a, <span class="keyword">int</span> b):id(a), cnt(b)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;node&gt; v; <span class="comment">//node结构体类型的vector</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span></span>&#123; <span class="comment">//次数相同时候升序为真</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a.cnt==b.cnt ? a.id&lt;b.id : a.cnt&gt;b.cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a[t]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">1000</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a[i])    v.push_back(node(i, a[i]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp); <span class="comment">//自定义比较规则cmp排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++) <span class="comment">//size_t: unsigned int类型的别名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i].id &lt;&lt; <span class="string">" "</span> &lt;&lt; v[i].cnt &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201503-3-节日"><a href="#201503-3-节日" class="headerlink" title="201503-3 节日"></a>201503-3 节日</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201503-3 节日</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> month[] = &#123;<span class="number">-1</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;; <span class="comment">//不是闰年</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsLeapYear</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//判断是否是闰年</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (y%<span class="number">400</span>==<span class="number">0</span>)||(y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">100</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">HowManyDays</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> y, <span class="keyword">int</span> m)</span></span>&#123; <span class="comment">//计算s年1月1日离y年m月1日有多少天</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> days = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(s &lt; y)    days += IsLeapYear(s++) ? <span class="number">366</span> : <span class="number">365</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(IsLeapYear(y))   month[<span class="number">2</span>] = <span class="number">29</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++)  days += month[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> days;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WhichDayInWeek</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="comment">//第b个星期c是几号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> day = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(w != c)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        day++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        w++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(w == <span class="number">8</span>) w = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> day + <span class="number">7</span>*(b<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a, b, c, y1, y2; <span class="comment">//a月第b个星期c、起始年份、终止年份</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; y1 &gt;&gt; y2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> year=y1; year&lt;=y2; year++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> w = (HowManyDays(<span class="number">1850</span>, year, a)+<span class="number">2</span>)%<span class="number">7</span>; <span class="comment">//y1-y2每年a月1日是星期几</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(w == <span class="number">0</span>)  w = <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> day = WhichDayInWeek(w, b, c); <span class="comment">//求出是a月的几号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(day &gt; month[a])  <span class="built_in">cout</span> &lt;&lt; <span class="string">"none"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d/%02d/%02d\n"</span>, year, a, day);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        month[<span class="number">2</span>] = <span class="number">28</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201503-4-网络延时"><a href="#201503-4-网络延时" class="headerlink" title="201503-4 网络延时"></a>201503-4 网络延时</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201503-4 网络延时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[<span class="number">20018</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> depth, <span class="keyword">int</span> &amp;maxdepth, <span class="keyword">int</span> &amp;maxdepvertex, <span class="keyword">bool</span> visit[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    visit[u] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(depth &gt; maxdepth) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxdepth = depth;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxdepvertex = u;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;v[u].<span class="built_in">size</span>(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> w = v[u][i]; <span class="comment">//u的邻接点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!visit[w]) </span></pre></td></tr><tr><td class="code"><pre><span class="line">            dfs(w, depth+<span class="number">1</span>, maxdepth, maxdepvertex, visit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m; <span class="comment">//交换机数，终端电脑数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x; <span class="comment">//第2～n台交换机连接的上一层交换机的编号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v[x].push_back(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v[i].push_back(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x; <span class="comment">//第1～m台终端连接的交换机的编号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v[x].push_back(<span class="number">10000</span>+i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v[<span class="number">10000</span>+i].push_back(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> v1[<span class="number">20018</span>] = &#123;<span class="number">0</span>&#125;, v2[<span class="number">20018</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//visit数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxdepth = <span class="number">-1</span>, maxdepvertex = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, maxdepth, maxdepvertex, v1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dfs(maxdepvertex, <span class="number">0</span>, maxdepth, maxdepvertex, v2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxdepth;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：<a href="https://blog.csdn.net/gl486546/article/details/79154493" target="_blank" rel="noopener">201503-4 网络延时 ccf</a></p>
<h3 id="201503-5-最小花费"><a href="#201503-5-最小花费" class="headerlink" title="201503-5 最小花费"></a>201503-5 最小花费</h3><h1 id="2014年"><a href="#2014年" class="headerlink" title="2014年"></a>2014年</h1><h2 id="12月-4"><a href="#12月-4" class="headerlink" title="12月"></a>12月</h2><h3 id="201412-1-门禁系统"><a href="#201412-1-门禁系统" class="headerlink" title="201412-1 门禁系统"></a>201412-1 门禁系统</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFF 201412-1 门禁系统</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//每条记录依次出现的实时次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//每条记录第几次出现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt[x]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a[i] = cnt[x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201412-2-Z字形扫描"><a href="#201412-2-Z字形扫描" class="headerlink" title="201412-2 Z字形扫描"></a>201412-2 Z字形扫描</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201412-2 Z字形扫描</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, a[<span class="number">500</span>][<span class="number">500</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++)&#123; <span class="comment">//一共有 2*n-1 条斜线 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> s = i&lt;n ? <span class="number">0</span> : (i-n+<span class="number">1</span>); </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> e = i&lt;n ? i : (n<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) <span class="comment">//第i条斜线编号是偶数: 从左下打印到右上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> j=s; j&lt;=e; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">cout</span> &lt;&lt; a[i-j][j] &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="comment">//第i条斜线编号是奇数: 从右上打印到左下 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=s; j&lt;=e; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="built_in">cout</span> &lt;&lt; a[j][i-j] &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201412-3-集合竞价"><a href="#201412-3-集合竞价" class="headerlink" title="201412-3 集合竞价"></a>201412-3 集合竞价</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201412-3 集合竞价</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span>; <span class="comment">//交易行数最大值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trading</span> &#123;</span> <span class="comment">//交易</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> orderno; <span class="comment">//交易编号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> t; <span class="comment">//买（buy）、卖（sell）标志，取值为b、s</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> price; <span class="comment">//价格</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> quantity; <span class="comment">//数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> trading&amp; n) <span class="keyword">const</span> &#123; <span class="comment">// &lt; 操作符重载</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(t == <span class="string">'s'</span>)    <span class="keyword">return</span> price &gt; n.price;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> price &lt; n.price; <span class="comment">// t == 'b'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> canceltrading[N+<span class="number">1</span>]; <span class="comment">//标记是否撤销了第i行交易记录</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//初始化与输入部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    trading t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> strading; <span class="comment">//每一行交易操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tradingno = <span class="number">0</span>, cancelno; <span class="comment">//交易号码、撤销的交易号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    priority_queue&lt;trading&gt; sell, buy; <span class="comment">//卖、买两个优先队列：数字大的优先级高</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(canceltrading, <span class="literal">false</span>, <span class="keyword">sizeof</span>(canceltrading)); <span class="comment">//变量初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; strading) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(strading[<span class="number">0</span>] == <span class="string">'c'</span>) &#123; <span class="comment">//撤销交易</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            tradingno++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; cancelno;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            canceltrading[cancelno] = <span class="literal">true</span>; <span class="comment">//设置撤销标志</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(strading[<span class="number">0</span>] == <span class="string">'b'</span> || strading[<span class="number">0</span>] == <span class="string">'s'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            t.orderno = ++tradingno;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span> &gt;&gt; t.price &gt;&gt; t.quantity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(strading[<span class="number">0</span>] == <span class="string">'b'</span>) &#123; <span class="comment">//将交易放入买入的优先队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                t.t = strading[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                buy.push(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//将交易放入卖出的优先队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                t.t = strading[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                sell.push(t);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span>  <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//集合竞价处理部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    t.price = <span class="number">0</span>; <span class="comment">//开盘价</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    t.quantity = <span class="number">0</span>; <span class="comment">//此开盘价下的成交量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    trading b, s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(!buy.empty()) &#123; <span class="comment">//清除被取消的buy订单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            b = buy.top(); <span class="comment">//b为买队列的队头</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(canceltrading[b.orderno])   buy.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(!sell.empty()) &#123; <span class="comment">//清除被取消的sell订单</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            s = sell.top(); <span class="comment">//s为卖队列的队头</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(canceltrading[s.orderno])   sell.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(buy.empty() || sell.empty()) <span class="keyword">break</span>; <span class="comment">//买卖队列只要有一个为空就结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(b.price &gt;= s.price) &#123; <span class="comment">//买卖交易开始处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            t.quantity += <span class="built_in">min</span>(b.quantity, s.quantity);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            t.price = b.price;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(b.quantity == s.quantity) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                buy.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                sell.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(b.quantity &gt; s.quantity) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                b.quantity -= s.quantity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                buy.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                buy.push(b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                sell.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                buy.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                s.quantity -= b.quantity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                sell.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                sell.push(s);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span>  <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 输出结果部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f"</span>, t.price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; t.quantity &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：</p>
<ul>
<li><a href="https://blog.csdn.net/pzhu_cg_csdn/article/details/79166858" target="_blank" rel="noopener">priority_queue</a></li>
<li><a href="https://blog.csdn.net/c20182030/article/details/70757660" target="_blank" rel="noopener">优先队列 priority_queue 详解</a></li>
</ul>
<h3 id="201412-4-最优灌溉"><a href="#201412-4-最优灌溉" class="headerlink" title="201412-4 最优灌溉"></a>201412-4 最优灌溉</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201412-4 最优灌溉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1061109567</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mmp[<span class="number">1010</span>][<span class="number">1010</span>]; <span class="comment">//各个麦田之间的水渠费用map</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> lowdist[<span class="number">1010</span>]; <span class="comment">//最小花费数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> visit[<span class="number">1010</span>]; <span class="comment">//建水渠的麦田数组 1:建 0:不建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//Prim算法(最小生成树算法)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        lowdist[i] = mmp[<span class="number">1</span>][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    visit[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> k, sum = <span class="number">0</span>; <span class="comment">//sum为总费用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> min_val = INF; <span class="comment">//动态变化的最小费用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(!visit[j] &amp;&amp; lowdist[j] &lt; min_val)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                min_val = lowdist[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                k = j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        visit[k] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += min_val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(!visit[j] &amp;&amp; mmp[k][j] &lt; lowdist[j])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                lowdist[j] = mmp[k][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">//麦田数、可建的水渠数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(mmp, INF, <span class="keyword">sizeof</span>(mmp)); <span class="comment">//将mmp的内容全设为INF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit)); <span class="comment">//初始化所有麦田不建水渠</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> start, <span class="built_in">end</span>, value; <span class="comment">//水渠起点、终点以及费用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; start &gt;&gt; <span class="built_in">end</span> &gt;&gt; value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(mmp[start][<span class="built_in">end</span>] &gt; value)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mmp[start][<span class="built_in">end</span>] = mmp[<span class="built_in">end</span>][start] = value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    prim(n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：<a href="https://blog.csdn.net/yeruby/article/details/38615045" target="_blank" rel="noopener">最小生成树Prim算法理解</a></p>
<h3 id="201412-5-货物调度"><a href="#201412-5-货物调度" class="headerlink" title="201412-5 货物调度"></a>201412-5 货物调度</h3><h2 id="9月-4"><a href="#9月-4" class="headerlink" title="9月"></a>9月</h2><h3 id="201409-1-相邻数对"><a href="#201409-1-相邻数对" class="headerlink" title="201409-1 相邻数对"></a>201409-1 相邻数对</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 201409-1 相邻数对</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, num = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(a, a+n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a[i]-a[i<span class="number">-1</span>] == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            num++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201409-2-画图"><a href="#201409-2-画图" class="headerlink" title="201409-2 画图"></a>201409-2 画图</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201409-2 画图</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, xy[<span class="number">100</span>][<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//矩形个数、坐标系大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2, sum = <span class="number">0</span>; <span class="comment">//每个矩形的坐标、颜色方块数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">//处理每一个矩形</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x1; j&lt;x2; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=y1; k&lt;y2; k++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(!xy[j][k])&#123; <span class="comment">//避免重复</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    sum++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    xy[j][k] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201409-3-字符串匹配"><a href="#201409-3-字符串匹配" class="headerlink" title="201409-3 字符串匹配"></a>201409-3 字符串匹配</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201409-3 字符串匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> str; <span class="comment">//待匹配字符串、输出文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> is_dif, n; <span class="comment">//大小写敏感标识符、文本行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; is_dif &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(n--)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> new_str;  <span class="comment">//每一行识别文本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; new_str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(is_dif == <span class="number">1</span>)&#123; <span class="comment">//大小写敏感</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">size_t</span> pos = new_str.<span class="built_in">find</span>(str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(pos != <span class="built_in">string</span>::npos)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; new_str &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//大小写不敏感: 全转化为小写再匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">string</span> tmp, txt; <span class="comment">//临时的str、new_str</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                tmp += <span class="built_in">tolower</span>(str[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;new_str.<span class="built_in">size</span>(); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                txt += <span class="built_in">tolower</span>(new_str[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">size_t</span> pos = txt.<span class="built_in">find</span>(tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(pos != <span class="built_in">string</span>::npos)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; new_str &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201409-4-最优配餐"><a href="#201409-4-最优配餐" class="headerlink" title="201409-4 最优配餐"></a>201409-4 最优配餐</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201409-4 最优配餐</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DIRECTSIZE = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">direct</span> &#123;</span> <span class="comment">//前进方向</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> drow, dcol;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; direct[DIRECTSIZE] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buyer[N+<span class="number">1</span>][N+<span class="number">1</span>]; <span class="comment">//客户坐标下的订餐量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> visited[N+<span class="number">1</span>][N+<span class="number">1</span>]; <span class="comment">//经过的点坐标 1:不可再经过 0:可经过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> buyercount = <span class="number">0</span>; <span class="comment">//客户数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>; <span class="comment">//最终送餐费用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> row, col, <span class="built_in">step</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node()&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> s)&#123;row=r, col=c, <span class="built_in">step</span>=s;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;node&gt; q; <span class="comment">//分店节点队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//广度优先搜索</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    node front, v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        front = q.front();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        q.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;DIRECTSIZE; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//移动一格</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            v.row = front.row + direct[i].drow;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v.col = front.col + direct[i].dcol;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v.<span class="built_in">step</span> = front.<span class="built_in">step</span> + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//行列越界则跳过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(v.row&lt;<span class="number">1</span> || v.row&gt;n || v.col&lt;<span class="number">1</span> || v.col&gt;n) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 已经访问过的点不再访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(visited[v.row][v.col]) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果是订餐点，则计算成本并且累加</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(buyer[v.row][v.col] &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                visited[v.row][v.col] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans += buyer[v.row][v.col] * v.<span class="built_in">step</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(--buyercount == <span class="number">0</span>)   <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 向前搜索：标记v点为已经访问过，v点加入队列中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            visited[v.row][v.col] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            q.push(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m, k, d; <span class="comment">//方格图大小、分店数、客户数、禁止通行点的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x, y, c; <span class="comment">//分店/客户/禁止点坐标与订餐量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(buyer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buyer));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(visited));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123; <span class="comment">//依次输入分店坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        q.push(node(x, y, <span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        visited[x][y] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++)&#123; <span class="comment">//依次输入客户坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(buyer[x][y]==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            buyercount++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        buyer[x][y] += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=d; i++)&#123; <span class="comment">//依次输入禁止通行的点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        visited[x][y] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    bfs(n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：</p>
<ul>
<li><a href="https://www.2cto.com/kf/201605/509249.html" target="_blank" rel="noopener">广度/宽度优先搜索(BFS)详解</a></li>
<li><a href="https://www.cnblogs.com/George1994/p/6581032.html" target="_blank" rel="noopener">BFS－基础简单的算法</a></li>
</ul>
<h3 id="201409-5-拼图"><a href="#201409-5-拼图" class="headerlink" title="201409-5 拼图"></a>201409-5 拼图</h3><h2 id="3月-3"><a href="#3月-3" class="headerlink" title="3月"></a>3月</h2><h3 id="201403-1-相反数"><a href="#201403-1-相反数" class="headerlink" title="201403-1 相反数"></a>201403-1 相反数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 201403-1 相反数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, num = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a[<span class="built_in">abs</span>(x)]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            num++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt;<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201403-2-窗口"><a href="#201403-2-窗口" class="headerlink" title="201403-2 窗口"></a>201403-2 窗口</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201403-2 窗口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">window</span>&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2, num; <span class="comment">//窗口位置坐标、窗口序号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    window(<span class="keyword">int</span> a=<span class="number">0</span>,<span class="keyword">int</span> b=<span class="number">0</span>,<span class="keyword">int</span> c=<span class="number">0</span>,<span class="keyword">int</span> d=<span class="number">0</span>,<span class="keyword">int</span> x=<span class="number">0</span>):x1(a),y1(b),x2(c),y2(d),num(x)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;window&gt; v;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, window &amp;w)</span></span>&#123; <span class="comment">//检查(x, y)是否在窗口w上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (x&gt;=w.x1 &amp;&amp; y&gt;=w.y1 &amp;&amp; x&lt;=w.x2 &amp;&amp; y&lt;=w.y2) ? <span class="literal">true</span> : <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">todo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i &lt; v.<span class="built_in">size</span>())&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(check(x, y, v[i]))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            window temp = v[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v.erase(v.<span class="built_in">begin</span>()+i); <span class="comment">//删除第i项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            v.insert(v.<span class="built_in">begin</span>(), temp); <span class="comment">//重新插入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; temp.num &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"IGNORED\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">//n个窗口、m次点击操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v.resize(n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123; <span class="comment">//依次建立各个窗口结构体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v[i] = window(x1, y1, x2, y2, n-i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(m--)&#123; <span class="comment">//依次执行操作</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        todo(x, y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201403-3-命令行选项"><a href="#201403-3-命令行选项" class="headerlink" title="201403-3 命令行选项"></a>201403-3 命令行选项</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201403-3 命令行选项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">256</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> delimiter[] = <span class="string">" "</span>; <span class="comment">//字符串分割符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spilt</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; v, <span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> *sp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sp = strtok(s, t); <span class="comment">//字符串切割函数，参数为字符串和分割符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(sp) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v.push_back(sp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sp = strtok(<span class="literal">NULL</span>, t); <span class="comment">//第一次用一个字符串做第一个参数，以后用NULL做第一个参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mygetline</span><span class="params">(<span class="keyword">char</span> *pc)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>((c=getchar()) != <span class="string">'\n'</span> &amp;&amp; c !=EOF)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        *pc++ = c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *pc = <span class="string">'\0'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> format; <span class="comment">//命令格式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n; <span class="comment">//命令行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> s[N+<span class="number">1</span>]; <span class="comment">//每行命令</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; format &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    getchar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123; <span class="comment">// 输入n行命令行进行处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sv; <span class="comment">//分割后的命令行片段vector</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mygetline(s); <span class="comment">// 输入命令行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        spilt(sv, s, delimiter); <span class="comment">// 切分命令行：命令和各个参数分开</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;(<span class="keyword">int</span>)sv.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 处理各个参数，放入map变量ｍ中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(sv[j].<span class="built_in">size</span>() == <span class="number">2</span> &amp;&amp; sv[j][<span class="number">0</span>] == <span class="string">'-'</span>) &#123; <span class="comment">// 判断是否是选项，选项则处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> pos = format.<span class="built_in">find</span>(sv[j][<span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(pos == <span class="number">-1</span>) <span class="comment">// 选项在格式中未找到则出错结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">break</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(m.<span class="built_in">find</span>(sv[j]) == m.<span class="built_in">end</span>()) <span class="comment">// 选项未出现过则添加</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    m[sv[j]] = <span class="string">""</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(format[pos+<span class="number">1</span>] == <span class="string">':'</span> &amp;&amp; j+<span class="number">1</span> &lt; (<span class="keyword">int</span>)sv.<span class="built_in">size</span>()) &#123; <span class="comment">// 更新参数：后出现优先</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    m[sv[j]] = sv[j+<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    j++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 输出结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator iter=m.<span class="built_in">begin</span>(); iter!=m.<span class="built_in">end</span>(); iter++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;first;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(iter-&gt;second != <span class="string">""</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201403-4-无线网络"><a href="#201403-4-无线网络" class="headerlink" title="201403-4 无线网络"></a>201403-4 无线网络</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF CCF201403-4 无线网络</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">100</span>; <span class="comment">//路由器最大数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  <span class="keyword">long</span> <span class="keyword">long</span> x, y;  &#125; coord[MAXN+<span class="number">1</span>]; <span class="comment">//n+m个路由器的坐标结构数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">status</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span>, kcount; <span class="comment">//步数，可连接路由器数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAXN+<span class="number">1</span>]; <span class="comment">//已访问过的路由器设置为true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">router</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">long</span> <span class="keyword">long</span> r)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(visited, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visited));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    status start, front, v; <span class="comment">//开始路由器，队头路由器，访问路由器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    start.x = coord[<span class="built_in">begin</span>].x; <span class="comment">//设置根结点start</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    start.y = coord[<span class="built_in">begin</span>].y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    start.<span class="built_in">step</span> = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    start.kcount = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">queue</span>&lt;status&gt; q; <span class="comment">//路由器访问队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    q.push(start);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    visited[<span class="built_in">begin</span>] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        front = q.front(); <span class="comment">//依次出队列访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        q.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(front.x==coord[<span class="built_in">end</span>].x &amp;&amp; front.y==coord[<span class="built_in">end</span>].y) <span class="comment">//到达终点 结束</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> front.<span class="built_in">step</span> - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(front.kcount == k)   <span class="built_in">max</span> = n; <span class="comment">//搜索可以连接的路由器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>    <span class="built_in">max</span> = n + m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">max</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(visited[i])  <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>((front.x-coord[i].x)*(front.x-coord[i].x)+(front.y-coord[i].y)*(front.y-coord[i].y) &gt; r*r)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span>; <span class="comment">//判定下一个路由器坐标是否在半径r之内，不在则跳过，在则继续搜索</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                visited[i] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//计算步数，并且将第i个路由器加入队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                v.x = coord[i].x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                v.y = coord[i].y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                v.<span class="built_in">step</span> = front.<span class="built_in">step</span> + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(i &gt;= n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    v.kcount = front.kcount + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    v.kcount = front.kcount;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                q.push(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m, k; <span class="comment">//已放置路由器数，可再放置的位置数，新增路由器最大数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> r; <span class="comment">//确保网络间连接的最大距离</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n+m; i++) <span class="comment">//依次输入原路由器和新增路由器的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; coord[i].x &gt;&gt; coord[i].y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; router(n, m, k, <span class="number">0</span>, <span class="number">1</span>, r) &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201403-5-任务调度"><a href="#201403-5-任务调度" class="headerlink" title="201403-5 任务调度"></a>201403-5 任务调度</h3><h1 id="2013年"><a href="#2013年" class="headerlink" title="2013年"></a>2013年</h1><h2 id="12月-5"><a href="#12月-5" class="headerlink" title="12月"></a>12月</h2><h3 id="201312-1-出现次数最多的数"><a href="#201312-1-出现次数最多的数" class="headerlink" title="201312-1 出现次数最多的数"></a>201312-1 出现次数最多的数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CCF 201312-1 出现次数最多的数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, maxval = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[<span class="number">10001</span>] = &#123;<span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a[t]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10000</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxval = <span class="built_in">max</span>(maxval, a[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10000</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(maxval == a[i])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201312-2-ISBN号码"><a href="#201312-2-ISBN号码" class="headerlink" title="201312-2 ISBN号码"></a>201312-2 ISBN号码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201312-2 ISBN号码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">valX</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> s%<span class="number">11</span>==<span class="number">10</span> ? <span class="string">'X'</span> : <span class="string">'0'</span>+s%<span class="number">11</span>; <span class="comment">//数字转字符: +'0'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, i = <span class="number">1</span>, j = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> str[<span class="number">16</span>], ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>((ch=<span class="built_in">cin</span>.<span class="built_in">get</span>()) != <span class="string">'\n'</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str[j++] = ch;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(ch))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(i&lt;=<span class="number">9</span>)    sum += i*(ch-<span class="string">'0'</span>); <span class="comment">//字符转数字: -'0'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    str[j] = <span class="string">'\0'</span>; <span class="comment">//空字符表示字符串末尾</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> x = valX(sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(str[j<span class="number">-1</span>] == x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Right\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        str[j<span class="number">-1</span>] = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201312-3-最大的矩形"><a href="#201312-3-最大的矩形" class="headerlink" title="201312-3 最大的矩形"></a>201312-3 最大的矩形</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201312-3 最大的矩形</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, ans = <span class="number">-1</span>, <span class="built_in">height</span>[<span class="number">1024</span>]; <span class="comment">//矩阵个数、最大矩形面积、矩形高度数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">height</span>[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> min_height = <span class="built_in">height</span>[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            min_height = <span class="built_in">min</span>(min_height, <span class="built_in">height</span>[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans = <span class="built_in">max</span>(min_height*(j-i+<span class="number">1</span>), ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="201312-4-有趣的数"><a href="#201312-4-有趣的数" class="headerlink" title="201312-4 有趣的数"></a>201312-4 有趣的数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CCF 201312-4 有趣的数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* 方法一：组合数学的思路：（假设0、1、2、3分别有a、b、c、d个）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   （1）0在1前面且不在首位：a+b-1种</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   （2）2和3其中一个在首位，假设是2在首位。将剩余c-1个2和d个3插入已经放好的a+b+1个数中，</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">       即：把c+d-1个相同球放入a+b+1个相同的盒子（可空）中，即C(a+b+1+c+d-1-1,c+d-1)种</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   （3）2和3一共有c+d-1种</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    故总共有： C(a+b+1+c+d-1-1,c+d-1) * （a+b-1） * （c+d-1）种</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1010</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> MOD=<span class="number">1000000007</span>, n, s[MAX][MAX], ans=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;MAX; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        s[i][i]=<span class="number">1</span>, s[i][<span class="number">1</span>]=i, s[i][<span class="number">0</span>]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;MAX; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            s[i][j] = (s[i<span class="number">-1</span>][j<span class="number">-1</span>]+s[i<span class="number">-1</span>][j]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n<span class="number">-2</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = (ans+s[n<span class="number">-1</span>][i<span class="number">-1</span>]*(i<span class="number">-1</span>)*(n-i<span class="number">-1</span>)) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* 方法二：动态规划</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">题目给出了0，1，2，3四个数，现考察一系列中间状态，即选取四个数的子集，在满足题设条件下，共有如下6种状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">状态0：2 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">状态1：0 2 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">状态2：2 3 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">状态3：0 1 2 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">状态4：0 2 3 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">状态5：0 1 2 3 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">最终我们需要求得的结果是状态5，用sta[i][j]表示一系列中间过程，其中i表示数的位数，j表示状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">显然，i=0时，所有的不同结果都为0（边界条件）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">对于状态0来说，所选取的集合只有2，所以对于任意数位n，其不同个数始终为1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">对于状态1来说，数位为i时的结果可以通过第i-1位状态获得，包括</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">              (1)通过状态0获得，只能在第i位时添加0，即sta[i-1][0]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">              (2)通过本身状态1获得，在第i位添加0或者2，即sta[i-1][1]*2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">              所以，sta[i][1]=sta[i-1][0]+sta[i-1][1]*2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">对于状态2来说，数位为i时的结果可以通过第i-1位状态获得，包括</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">              (1)通过状态0获得，只能在第i位时添加3，即sta[i-1][0]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">              (2)通过本身状态2获得，只能在第i位添加3，即sta[i-1][2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">              所以，sta[i][2]=sta[i-1][0]+sta[i-1][2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">其余状态同理，也即是，对于任意状态，总可以通过前序状态或者本身状态获得</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">所有转移方程如下</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">sta[i][0]=1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">sta[i][1]=sta[i-1][0]+sta[i-1][1]*2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">sta[i][2]=sta[i-1][0]+sta[i-1][2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">sta[i][3]=sta[i-1][1]+sta[i-1][3]*2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">sta[i][4]=sta[i-1][1]+sta[i-1][2]+sta[i-1][4]*2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">sta[i][5]=sta[i-1][3]+sta[i-1][4]+sta[i-1][5]*2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">对状态的补充：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">一个数情况，必须是2（首位必须是2）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">           (0)2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">两个数情况，必须有2，其余只能是0，3（0必须在1前面）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">           (1)0 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">           (2)2 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">三个数情况，必须有2，其余可能是0，1或者0，3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">           (3)0 1 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">           (4)0 2 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">四个数情况，(5)0 1 2 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">6种状态整理完毕</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod=<span class="number">1000000007</span>, sta[<span class="number">1024</span>][<span class="number">6</span>], n;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sta[i][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sta[i][<span class="number">1</span>] = (sta[i<span class="number">-1</span>][<span class="number">0</span>]+sta[i<span class="number">-1</span>][<span class="number">1</span>]*<span class="number">2</span>) % mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sta[i][<span class="number">2</span>] = (sta[i<span class="number">-1</span>][<span class="number">0</span>]+sta[i<span class="number">-1</span>][<span class="number">2</span>]) % mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sta[i][<span class="number">3</span>] = (sta[i<span class="number">-1</span>][<span class="number">1</span>]+sta[i<span class="number">-1</span>][<span class="number">3</span>]*<span class="number">2</span>) % mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sta[i][<span class="number">4</span>] = (sta[i<span class="number">-1</span>][<span class="number">1</span>]+sta[i<span class="number">-1</span>][<span class="number">2</span>]+sta[i<span class="number">-1</span>][<span class="number">4</span>]*<span class="number">2</span>) % mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sta[i][<span class="number">5</span>] = (sta[i<span class="number">-1</span>][<span class="number">3</span>]+sta[i<span class="number">-1</span>][<span class="number">4</span>]+sta[i<span class="number">-1</span>][<span class="number">5</span>]*<span class="number">2</span>) % mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sta[n][<span class="number">5</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>学习参考：</p>
<ul>
<li><a href="https://blog.csdn.net/u011589125/article/details/51058777" target="_blank" rel="noopener">组合数学法</a></li>
<li><a href="https://blog.csdn.net/gl486546/article/details/79194977" target="_blank" rel="noopener">动态规划</a></li>
</ul>
<h3 id="201312-5-I’m-stuck"><a href="#201312-5-I’m-stuck" class="headerlink" title="201312-5 I’m stuck!"></a>201312-5 I’m stuck!</h3>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python惯例</title>
    <url>/2018/07/08/Python%E6%83%AF%E4%BE%8B/</url>
    <content><![CDATA[<p>掌握Python惯例（<strong>Python Idioms</strong>），写出<code>Pythonic</code>的代码。</p>
<a id="more"></a>

<ol>
<li><p>让代码既可以被导入又可以被执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr></table></figure>
</li>
<li><p>用下面的方式判断逻辑“真”或“假”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x:</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> x:</span></pre></td></tr></table></figure>

<p><strong>好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'CoolR'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fruits = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'grape'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">owners = &#123;<span class="string">'1001'</span>: <span class="string">'CoolR'</span>, <span class="string">'1002'</span>: <span class="string">'Tom'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name <span class="keyword">and</span> fruits <span class="keyword">and</span> owners:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'I love fruits!'</span>)</span></pre></td></tr></table></figure>

<p><strong>不好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'CoolR'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">fruits = [<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'grape'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">owners = &#123;<span class="string">'1001'</span>: <span class="string">'CoolR'</span>, <span class="string">'1002'</span>: <span class="string">'Tom'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name != <span class="string">''</span> <span class="keyword">and</span> len(fruits) &gt; <span class="number">0</span> <span class="keyword">and</span> owners != &#123;&#125;:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'I love fruits!'</span>)</span></pre></td></tr></table></figure>
</li>
<li><p>善于使用in运算符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x <span class="keyword">in</span> items: <span class="comment"># 包含</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> items: <span class="comment"># 迭代</span></span></pre></td></tr></table></figure>

<p><strong>好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'CoolR'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'R'</span> <span class="keyword">in</span> name:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'The name has an R in it.'</span>)</span></pre></td></tr></table></figure>

<p><strong>不好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'CoolR'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> name.find(<span class="string">'R'</span>) != <span class="number">-1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(<span class="string">'This name has an R in it!'</span>)</span></pre></td></tr></table></figure>
</li>
<li><p>不使用临时变量交换两个值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = b, a</span></pre></td></tr></table></figure>
</li>
<li><p>用序列构建字符串。</p>
<p><strong>好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chars = [<span class="string">'C'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>, <span class="string">'l'</span>, <span class="string">'R'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">name = <span class="string">''</span>.join(chars)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(name)  <span class="comment"># CoolR</span></span></pre></td></tr></table></figure>

<p><strong>不好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chars = [<span class="string">'C'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>, <span class="string">'l'</span>, <span class="string">'R'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">name = <span class="string">''</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> chars:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name += char</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(name)  <span class="comment"># CoolR</span></span></pre></td></tr></table></figure>
</li>
<li><p>EAFP优于LBYL。</p>
<p>EAFP - <strong>E</strong>asier to <strong>A</strong>sk <strong>F</strong>orgiveness than <strong>P</strong>ermission.</p>
<p>LBYL - <strong>L</strong>ook <strong>B</strong>efore <strong>Y</strong>ou <strong>L</strong>eap.</p>
<p><strong>好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'x'</span>: <span class="string">'5'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value = int(d[<span class="string">'x'</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(value)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> (KeyError, TypeError, ValueError):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value = <span class="literal">None</span></span></pre></td></tr></table></figure>

<p><strong>不好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'x'</span>: <span class="string">'5'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">'x'</span> <span class="keyword">in</span> d <span class="keyword">and</span> isinstance(d[<span class="string">'x'</span>], str) <span class="keyword">and</span> d[<span class="string">'x'</span>].isdigit():</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value = int(d[<span class="string">'x'</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(value)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    value = <span class="literal">None</span></span></pre></td></tr></table></figure>
</li>
<li><p>使用enumerate进行迭代。</p>
<p><strong>好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = [<span class="string">'orange'</span>, <span class="string">'grape'</span>, <span class="string">'pitaya'</span>, <span class="string">'blueberry'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, fruit <span class="keyword">in</span> enumerate(fruits):</span></pre></td></tr><tr><td class="code"><pre><span class="line">	print(index, <span class="string">':'</span>, fruit)</span></pre></td></tr></table></figure>

<p><strong>不好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruits = [<span class="string">'orange'</span>, <span class="string">'grape'</span>, <span class="string">'pitaya'</span>, <span class="string">'blueberry'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">index = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(index, <span class="string">':'</span>, fruit)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    index += <span class="number">1</span></span></pre></td></tr></table></figure>
</li>
<li><p>用生成式生成列表。</p>
<p><strong>好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="number">7</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">11</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">result = [num * <span class="number">3</span> <span class="keyword">for</span> num <span class="keyword">in</span> data <span class="keyword">if</span> num &gt; <span class="number">10</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(result)  <span class="comment"># [60, 45, 33]</span></span></pre></td></tr></table></figure>

<p><strong>不好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = [<span class="number">7</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">11</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">result = []</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        result.append(i * <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(result)  <span class="comment"># [60, 45, 33]</span></span></pre></td></tr></table></figure>
</li>
<li><p>用zip组合键和值来创建字典。</p>
<p><strong>好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keys = [<span class="string">'1001'</span>, <span class="string">'1002'</span>, <span class="string">'1003'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">values = [<span class="string">'CoolR'</span>, <span class="string">'Tom'</span>, <span class="string">'Jerry'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">d = dict(zip(keys, values))</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(d)</span></pre></td></tr></table></figure>

<p><strong>不好</strong>的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keys = [<span class="string">'1001'</span>, <span class="string">'1002'</span>, <span class="string">'1003'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">values = [<span class="string">'CoolR'</span>, <span class="string">'Tom'</span>, <span class="string">'Jerry'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">d = &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, key <span class="keyword">in</span> enumerate(keys):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d[key] = values[i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(d)</span></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p><strong>说明</strong>：文章内容源于网络，有兴趣的读者可以阅读<a href="http://safehammad.com/downloads/python-idioms-2014-01-16.pdf" target="_blank" rel="noopener">原文</a>。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网指南</title>
    <url>/2018/06/07/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>为了科学上网和进一步学习，我决定动手搭建一个自己的服务器。在搭建过程中遇到了一些阻碍，这里非常感谢大神的帮助 @<a href="https://github.com/PlatypusPro" target="_blank" rel="noopener">PlatypusPro</a> 。本文记录搭建服务器、使用 <a href="https://www.digitalocean.com/" target="_blank" rel="noopener">Digital Ocean</a> 和 <a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank" rel="noopener">Shadowsocks</a> 实现科学上网的过程。</p>
<a id="more"></a>

<h3 id="1-注册DigitalOcean账号"><a href="#1-注册DigitalOcean账号" class="headerlink" title="1 注册DigitalOcean账号"></a>1 注册DigitalOcean账号</h3><p>首先注册一个属于你自己的Digital Ocean账号，此时你需要绑定信用卡💳，或者使用你的PayPal账户支付5$，方可使用。这里附上我的邀请链接  <a href="http://www.digitalocean.com/?refcode=804fc47b7367" target="_blank" rel="noopener">http://www.digitalocean.com/?refcode=804fc47b7367</a> ，使用此邀请链接注册你的Digital Ocean账户，你将获得10$。</p>
<p>另外，如果你是在校学生，使用你的 <code>.edu</code> 邮箱通过 <a href="https://education.github.com/" target="_blank" rel="noopener">GitHub Education</a> 验证，你的Digital Ocean账户可再得50$。</p>
<h3 id="2-创建Droplet云主机"><a href="#2-创建Droplet云主机" class="headerlink" title="2 创建Droplet云主机"></a>2 创建Droplet云主机</h3><p>你可以根据你的实际情况来选择。选择前记得对各节点主机测速，比如 <a href="http://speedtest-sfo1.digitalocean.com/" target="_blank" rel="noopener">San Francisco 1</a> 。我选择的配置为：<code>1 GB Memory / 25 GB Disk / SFO2 - Ubuntu 16.04.4 x64</code> 。</p>
<p>最好添加你的<code>SSH Keys</code>，这样连接你的远程设备将会更加方便。先查看你本地是否有SSH Keys，你可以这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span></pre></td></tr><tr><td class="code"><pre><span class="line">ls *.pub</span></pre></td></tr></table></figure>

<p>如果没有任何输出，那你需要创建一个新的SSH Key：(记得将下面的邮箱替换为你自己的邮箱)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"email@example.com"</span></span></pre></td></tr></table></figure>

<p>剩下的工作就交给你了，直到你成功创建了你的SSH Key。比如我的公钥就生成于：<code>/Users/hcr/.ssh/id_rsa.pub</code>，接下来你就可以把公钥内容传到Digital Ocean上。好了，你的云主机创建完成。</p>
<h3 id="3-安装配置启动Shadowsocks"><a href="#3-安装配置启动Shadowsocks" class="headerlink" title="3 安装配置启动Shadowsocks"></a>3 安装配置启动Shadowsocks</h3><h4 id="3-1-服务器端安装SS"><a href="#3-1-服务器端安装SS" class="headerlink" title="3.1 服务器端安装SS"></a>3.1 服务器端安装SS</h4><p>参考<a href="https://github.com/shadowsocks/shadowsocks/tree/master" target="_blank" rel="noopener">Shadowsocks 使用说明</a>，例如在Debian / Ubuntu下:</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install python-pip</span></pre></td></tr><tr><td class="code"><pre><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span></pre></td></tr></table></figure>

<h4 id="3-2-服务器端配置"><a href="#3-2-服务器端配置" class="headerlink" title="3.2 服务器端配置"></a>3.2 服务器端配置</h4><p>参考<a href="https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File" target="_blank" rel="noopener">Configuration via Config File</a>，你需要创建一个配置文件 <code>/etc/shadowsocks.json</code> :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch /etc/shadowsocks.json</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	"server":"your_server_ip", </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	"server_port":your_server_port, </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	"local_address": "127.0.0.1",</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	"local_port":1080, </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	"password":"yourpassword", </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	"timeout":300, </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	"method":"aes-256-cfb", </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	"fast_open": true &#125;'</span> &gt; /etc/shadowsocks.json</span></pre></td></tr></table></figure>

<h4 id="3-3-服务器端启动与停止"><a href="#3-3-服务器端启动与停止" class="headerlink" title="3.3 服务器端启动与停止"></a>3.3 服务器端启动与停止</h4><p>远程登录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@your_server_ip</span></pre></td></tr></table></figure>

<p>启动运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span></pre></td></tr><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d stop</span></pre></td></tr></table></figure>

<p>重新启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d restart</span></pre></td></tr></table></figure>

<p>除了上述启动运行方法，你也可以使用SS客户端：</p>
<p>下载链接 <a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG</a> 。</p>
<h3 id="4-完成"><a href="#4-完成" class="headerlink" title="4 完成"></a>4 完成</h3><p>到此，你就可以使用你的 Safari 科学上网了。对于 Chrome ，推荐使用 <a href="https://chrome.google.com/webstore/search/SwitchyOmega?hl=zh-CN" target="_blank" rel="noopener">Proxy SwitchyOmega</a>。</p>
]]></content>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>谁是小王子</title>
    <url>/2018/05/17/%E8%B0%81%E6%98%AF%E5%B0%8F%E7%8E%8B%E5%AD%90/</url>
    <content><![CDATA[<p>小王子是一个小男孩，也是法国作家<a href="https://baike.baidu.com/item/%E5%AE%89%E6%89%98%E4%B8%87%C2%B7%E5%BE%B7%C2%B7%E5%9C%A3-%E5%9F%83%E5%85%8B%E8%8B%8F%E4%BD%A9%E9%87%8C/19777081?fr=aladdin" target="_blank" rel="noopener">安托万·德·圣-埃克苏佩里</a>于1942年写成的著名儿童文学短篇小说《小王子》的主人公。</p>
<a id="more"></a>

<blockquote>
<p>It is the time you have wasted for your rose that makes your rose so important.<br>你在你的玫瑰花身上耗费的时间使得你的玫瑰花变得如此重要。</p>
</blockquote>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>本书的主人公是来自外星球的小王子。本书中故事的叙述者是一名飞行员，讲述了小王子从自己星球出发前往地球的过程中，所经历的各种历险。作者以孩子般的眼光、孩子般的纯真和善良，折射出成人世界的空虚、自大、盲目和死板教条，用浅显天真的语言写出了人类孤独寂寞、没有根基随风流浪的命运。于此同时，本书也是对作者批判金钱关系、讴歌真善美对真情流露。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>故事开始于小飞行员六岁那年。那个时候他看了一本关于原始森林的书，书名叫《真实的故事》。充满好奇心的他开始对丛林中的种种历险产生了无尽的遐想，以致于他立马用彩色铅笔勾画出了他的处女作，但是大人们都很实际，直截了当地建议他应该把心思放在地理、历史、算数和语法上。后来小飞行员都会拿一号作品来试探那些看起来头脑还算清楚的大人，不出意外，这些大人眼里只有桥牌、高尔夫球、政治和领带。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>小飞行员孤独地生活着，没有一个真正可以交谈的朋友。直到有一天，他的飞机被迫降落在撒哈拉大沙漠，那个真正懂他的人才出现。</p>
<p>第二天一大早，一个表情严肃，看起来非常奇怪的小男孩望着飞行员。他不慌不忙，郑重其事地说“请你……请你给我画只绵羊吧……”。这时，飞行员突然想起那些现实的大人们，于是他拿出自己的处女作给了这个小家伙。“不，不，不！我不想要在蟒蛇肚子里的大象。我要的是绵羊，给我画只绵羊吧。”</p>
<p>就这样，飞行员认识了小王子。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>神秘的小王子说自己和飞机一样，也是从天上掉下来的，这让飞行员猛然捕捉到关于小王子神秘出现的一抹微光。然而，小王子并没有回答他，只是想让他的小羊在晚上可以住在飞行员的箱子里。他还有些伤感，“我住的地方，一切那么小。就算一直走，也走不了多远……”</p>
<p>在遇见小王子的第三天，小飞行员才听说了猴面包树的悲剧。后来他才知道，原来小王子的星球上也有益虫和害虫之分。根据小王子的描述，小飞行员画出了小王子生活的那颗星球。</p>
<p>静静地看着日落是小王子唯一的乐趣。“那天你看了四十四次日落，一定很难过吧？”</p>
<p>绵羊是不可以吃了小王子心爱的花的。“如果有人爱着一朵花，千万颗星星上独一无二的一朵，当他仰望星空时就会感到幸福。他会告诉自己，‘星空某处，有我的花在那里呢……’”</p>
<p>这朵花，就是小王子心爱的玫瑰花。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>在来地球之前，小王子还去了六颗星星。</p>
<p>第一颗星星上住着一个没有臣民的国王，总是摆出一副高高在上的姿态。</p>
<p>第二颗星星上只有一个爱慕虚荣的人，想要所有人都崇拜他。</p>
<p>第三颗星星上的酒鬼陷入了忧郁与羞愧，却无法自拔。</p>
<p>第四颗星星上的生意人忙着算钱，心里想的都是他所谓的正经的事情。</p>
<p>第五颗星星上的点灯人很是忠于职守，没有时间休息，“尽职尽责”得可怜。</p>
<p>第六颗星星上有一个地理学家，他没空到处闲逛，只是忙于记录探险家的见闻。</p>
<p>第七颗星星就是地球。</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>“请你……请你驯服我吧！” 狐狸说。</p>
<p>你只能了解你所驯服的东西。人们已经没有时间去了解任何东西了，需要什么商店里都可以买现成的。但没有能买到友谊的商店，所以人们再也交不到朋友了。</p>
<p>“如果你想找个朋友，请驯服我吧！”</p>
<p>“我愿意，很愿意。”</p>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>“你知道的，我的花……我要对她负责！她是那么柔弱！那么天真！她只有四根微不足道的刺来保护自己……” 小王子说。</p>
<p>小王子走了，回到了他自己的星球。</p>
<p>没有人知道飞行员在难受什么，心里在想什么。他想知道自己画给小王子的羊到底有没有吃掉小王子的玫瑰花……但他知道，如果小王子回去了，回到了他心爱的玫瑰花身边，那么就没有人能够伤害他的玫瑰花。</p>
<p>而这所有的事情，大人们都不会明白。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>小飞行员身旁的大人们和那六颗奇怪星星上的居民们，他们是绝对不会理解小王子的。</p>
<p>小王子的身上承载着作者祈望回归纯真世界的愿望，他代表着儿童纯净无暇的精神世界。他单纯的内心给予他洞悉一切本质的能力，让他在对爱与责任的认知中发掘世间的真情和温馨。在小王子的旅行中，他懂得了交往的真谛：爱一个人，就要对他负有责任。</p>
<p>《小王子》以小孩子的视角和口吻展现人间百态，让作品趣味性与哲理性融为一体。运用浅显易懂的语言、富于哲理意味的对话和典型的人物意象，让读者每一次阅读都能获得全新的感悟和体会。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>春分未至</title>
    <url>/2018/03/10/%E6%98%A5%E5%88%86%E6%9C%AA%E8%87%B3/</url>
    <content><![CDATA[<p>初春乍到，春分未至，趁着新来的暖意，迫切想在暖洋洋的街头走走。懒洋洋，慢悠悠，<a href="https://baike.baidu.com/item/昙华林/9550906" target="_blank" rel="noopener">昙华林</a>和<a href="https://baike.baidu.com/item/黎黄陂路" target="_blank" rel="noopener">黎黄陂路</a>即是首选。</p>
<a id="more"></a>

<h3 id="1-昙华林"><a href="#1-昙华林" class="headerlink" title="1 昙华林"></a>1 昙华林</h3><p>这的确是一条走在时间后面的老街。华洋杂处的特色，使这里的建筑呈现出不同的风格，舒缓且静谧，着实不同于大都市的快节奏。昙华林第一家，是家小书局，敞开的红色窗户下面是画上去的信封，慢递，从此开始。</p>
<p>在汉味明信片和各种小玩意儿装饰的小店里，不是只有店主售卖的手工，许多慢时光旅客也在这里留下了只言片语。对于多年以后，我们总是充满了憧憬，总是竭力用自己的想法描绘遥远的以后。很多人应该都会很好奇吧，以多年后的视角重新审视现在的自己，会产生怎样的化学反应。</p>
<p>出门右转，再进店，这次就真的回到了时间的最前头。第一个被我视线捕捉到的，是那种发条青蛙，那种拧一下蹬蹬蹬跳好远的铁皮青蛙。记忆之门好像被瞬间开启，儿时玩儿的不亦乐乎的发条铁皮青蛙，竟又在我面前。说不出什么具体感受，只觉得亲切又熟悉。</p>
<p>满街的书屋、工艺品商店和咖啡屋在阳光漫射下被进进出出的人流填满，不觉无趣。但前面的画廊让我眼前一亮。小王子对着他心爱的玫瑰花，提着水壶，看不出在说什么，但这画面却如此吸引人。墙上各式各样的油画和木板画，并非什么传世之作，但却有一股力量，让所有美好的场景和画面在我们面前重现，之前的阅历重新清晰起来，让人浮想联翩。</p>
<p>在这条慢悠悠的老街上，不乏身怀绝技的手艺人，也不乏浓浓的汉味。搅搅糖、纸雕、糖人等传统手艺，随处可见。当然，萌萌的棉花糖也会有大变身。</p>
<p>趁着青春年少，抓紧时间拍照。<br>趁着年华未老，抓紧沉淀阅历。</p>
<p>昙华林并不长，但街上熙熙攘攘，甚是热闹。绝大部分游客都是三五好友，或者两两结伴，在旅行路途中，把酒言欢。一个人走在这里，不知他们的感受，或许更觉得时间又放慢了脚步吧。</p>
<p>昙华林——武汉的文艺第一街，这里浓缩了整个武汉的文艺情怀。你可以拍照、闲逛，或者是找寻一间门口有猫咪迎接的咖啡屋，翻看老武汉的珍藏本，消遣一整个下午。你也可以沿街走过，触摸街边饱经风霜的老建筑，你会发现昙华林有的不仅仅是文艺，老武汉的历史痕迹同样留在了这里。</p>
<h3 id="2-黎黄陂路"><a href="#2-黎黄陂路" class="headerlink" title="2 黎黄陂路"></a>2 黎黄陂路</h3><p>文艺气息浓郁的地方，除了昙华林，还有黎黄陂路。</p>
<p>搭两站地铁，骑车一公里左右，到达目的地。这里给我的感觉，并非网上说的那般文艺有趣。今天这里人很少，街边一排咖啡馆剩余的座位还有很多。但这里和昙华林一样，都是走在时间后面的老街，不同于大城市的快节奏，就像一片世外桃源，有属于自我的静谧与惬意。</p>
<p>这里留给我最大的印象应该就是黎黄陂路2号的仟僖雅画廊了。在黎黄陂路的最开头，加上画廊里的几何风格，特别显眼。这是一个与我同年的艺术家，有着20岁这个年龄活跃的思维。喜欢画画，极度注重自我感知，他的画风为抽象与写意边缘的几何风格，这更像是对未知时空的畅想。开办个人画廊，创办服装品牌，他的作品大多由点、线、面这些几何元素构成，创作前后都充满了仪式感。</p>
<p>慢时光旅程到此结束，记忆之门却没有瞬间关闭。<br>多年以后不再多年，眼前之景不在眼前。<br>寄一封慢信，时光与阅历一起沉淀。<br>收信之日，年华重现。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo基本操作</title>
    <url>/2018/03/04/Hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>是一个快速、简洁且高效的博客框架，可以让上百个页面在几秒内完成渲染。Hexo支持Github Flavored Markdown的所有功能，甚至可以整合Octopress的大多数插件，并且自己也拥有强大的插件系统。</p>
<a id="more"></a>

<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h3><p>Hexo是基于node.js的, 所以我们在安装之前需要用到npm安装工具, 即先要安装 node.js.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 node.js</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get install -y nodejs</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 npm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo apt-get install npm</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Hexo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo npm install hexo-cli -g</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 升级 Hexo</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ sudo npm update hexo -g</span></pre></td></tr></table></figure>
<h3 id="2-简便操作"><a href="#2-简便操作" class="headerlink" title="2 简便操作"></a>2 简便操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo init</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建文章</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo n <span class="string">"blog"</span> == hexo new <span class="string">"blog"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 清除缓存文件db.json和生成的静态文件public</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo clean</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 生成静态文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo g == hexo generate</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 以调试模式启动本地网站</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo s == hexo server</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 部署</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo d == hexo deploy</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo d -g <span class="comment">#hexo g与hexo d的合并写法</span></span></pre></td></tr></table></figure>

<h3 id="3-写作"><a href="#3-写作" class="headerlink" title="3 写作"></a>3 写作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一篇新文章</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 例如:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"Hexo教程"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 即可在 source/_posts 目录下新建 Hexo教程.md 文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个新页面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo new page &lt;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 例如:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo new page aboutme</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 即可在 source 目录下新建 aboutme 文件夹</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 默认链接地址为 主页地址/aboutme/</span></span></pre></td></tr></table></figure>
<h4 id="3-1-布局"><a href="#3-1-布局" class="headerlink" title="3.1 布局"></a>3.1 布局</h4><ul>
<li>你可以在命令中指定文章的布局<code>layout</code>,默认<code>post</code>. 你可以修改<code>_config.yml</code>中的 <code>default_layout</code>参数来指定默认布局。</li>
<li><code>Hexo</code>有三种默认布局:<code>post</code>、<code>page</code>和<code>draft</code>, 他们的存储目录:</li>
</ul>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody></table>
<p>你自定义的布局将储存在<code>source/_posts</code>文件夹.</p>
<h4 id="3-2-草稿"><a href="#3-2-草稿" class="headerlink" title="3.2 草稿"></a>3.2 草稿</h4><p>草稿默认不会显示在页面中,在执行时加上<code>--draft</code>参数, 也可把<code>render_drafts</code>参数设为<code>true</code>来预览草稿。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一篇草稿</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo new draft <span class="string">"草稿名"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 发布草稿</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示草稿</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo --draft</span></pre></td></tr></table></figure>
<h3 id="4-其他命令"><a href="#4-其他命令" class="headerlink" title="4 其他命令"></a>4 其他命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出网站资料</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo list &lt;<span class="built_in">type</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示Hexo版本号</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo version</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 调试模式，调试信息输出到debug.log中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo --debug</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 安全模式， 不载入插件和脚本</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo --save</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 简洁模式，隐藏终端信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo --silent</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义使用的配置文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo --config custom.yml</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基本操作</title>
    <url>/2018/03/04/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</p>
<a id="more"></a>

<p><img src="/assets/blogimg/git.png" alt=""></p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h3 id="1-创建用户及配置"><a href="#1-创建用户及配置" class="headerlink" title="1 创建用户及配置"></a>1 创建用户及配置</h3><p>Git的设置文件为<code>.gitconfig</code>，既可全局配置，也可项目配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git config --list</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑Git配置文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git config -e [--global]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 查看用户信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git config user.name <span class="comment">#查看用户名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git config user.email <span class="comment">#查看用户邮箱</span></span></pre></td></tr></table></figure>
<h3 id="2-创建一个版本库"><a href="#2-创建一个版本库" class="headerlink" title="2 创建一个版本库"></a>2 创建一个版本库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git版本库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git init</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个目录并将其初始化为Git版本库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git init [project-name]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 下载一个项目和它的整个代码史</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> [url]</span></pre></td></tr></table></figure>
<h3 id="3-文件操作"><a href="#3-文件操作" class="headerlink" title="3 文件操作"></a>3 文件操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看文件状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git add [file1] [file2] ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git add [dir]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git add .</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git add -p</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git rm [file1] [file2] ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git rm --cached [file]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git mv [file-original] [file-renamed]</span></pre></td></tr></table></figure>

<h3 id="4-代码提交"><a href="#4-代码提交" class="headerlink" title="4 代码提交"></a>4 代码提交</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git commit -m [message]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git commit [file1] [file2] ... -m [message]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git commit -a</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git commit -v</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git commit --amend -m [message]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git commit --amend [file1] [file2] ...</span></pre></td></tr></table></figure>
<h3 id="5-分支"><a href="#5-分支" class="headerlink" title="5 分支"></a>5 分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有远程分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch -r</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch -a</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch [branch-name]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout -b [branch]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch [branch] [commit]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch --track [branch] [remote-branch]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout [branch-name]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到上一个分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout -</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git merge [branch]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git cherry-pick [commit]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删除分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch -d [branch-name]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删除远程分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git push origin --delete [branch-name]</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git branch -dr [remote/branch]</span></pre></td></tr></table></figure>
<h3 id="6-查看日志信息"><a href="#6-查看日志信息" class="headerlink" title="6 查看日志信息"></a>6 查看日志信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --follow [file]</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git whatchanged [file]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p [file]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示过去5次提交</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 单行显示日志</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git shortlog -sn</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git blame [file]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff --cached [file]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff HEAD</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff [first-branch]...[second-branch]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git show [commit]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git show --name-only [commit]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git show [commit]:[filename]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reflog</span></pre></td></tr></table></figure>
<h3 id="7-标签"><a href="#7-标签" class="headerlink" title="7 标签"></a>7 标签</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git tag</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git tag [tag]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git tag [tag] [commit]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删除本地tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git tag -d [tag]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删除远程tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/[tagName]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 查看tag信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git show [tag]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 提交指定tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git push [remote] [tag]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 提交所有tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git push [remote] --tags</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout -b [branch] [tag]</span></pre></td></tr></table></figure>
<h3 id="8-远程同步"><a href="#8-远程同步" class="headerlink" title="8 远程同步"></a>8 远程同步</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git fetch [remote]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示所有远程仓库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git remote -v</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git remote show [remote]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git remote add [shortname] [url]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git pull [remote] [branch]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git push [remote] [branch]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git push [remote] --force</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git push [remote] --all</span></pre></td></tr></table></figure>
<h3 id="9-撤销操作"><a href="#9-撤销操作" class="headerlink" title="9 撤销操作"></a>9 撤销操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout [file]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout [commit] [file]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git checkout .</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset [file]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset --hard</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset [commit]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset --hard [commit]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git reset --keep [commit]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git revert [commit]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git stash</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git stash pop</span></pre></td></tr></table></figure>
<h3 id="10-其他"><a href="#10-其他" class="headerlink" title="10 其他"></a>10 其他</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git archive</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#文件A在缓存中和版本1的不同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff --cached [版本1] 文件A</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#文件A 在版本1与 版本2的不同</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git diff 版本1 版本2 文件A</span></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/03/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
